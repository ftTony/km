<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>理解 EventLoop | 小武子知识库</title>
    <meta name="description" content="用心，谈技术。大前端">
    <link rel="icon" href="/hero.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.56546b06.css" as="style"><link rel="preload" href="/assets/js/app.9f912bc1.js" as="script"><link rel="preload" href="/assets/js/2.67134772.js" as="script"><link rel="preload" href="/assets/js/141.282ec3ff.js" as="script"><link rel="preload" href="/assets/js/3.65dbdf4c.js" as="script"><link rel="prefetch" href="/assets/js/10.ccb8d81d.js"><link rel="prefetch" href="/assets/js/100.67b92753.js"><link rel="prefetch" href="/assets/js/101.a3a95912.js"><link rel="prefetch" href="/assets/js/102.8097f956.js"><link rel="prefetch" href="/assets/js/103.0a81c358.js"><link rel="prefetch" href="/assets/js/104.04506f20.js"><link rel="prefetch" href="/assets/js/105.04d492a0.js"><link rel="prefetch" href="/assets/js/106.3d351fdb.js"><link rel="prefetch" href="/assets/js/107.017c9f64.js"><link rel="prefetch" href="/assets/js/108.5575f3cf.js"><link rel="prefetch" href="/assets/js/109.706acc5c.js"><link rel="prefetch" href="/assets/js/11.874d2f25.js"><link rel="prefetch" href="/assets/js/110.7ce92663.js"><link rel="prefetch" href="/assets/js/111.645fa839.js"><link rel="prefetch" href="/assets/js/112.4e2a5574.js"><link rel="prefetch" href="/assets/js/113.552ba773.js"><link rel="prefetch" href="/assets/js/114.e966f0b3.js"><link rel="prefetch" href="/assets/js/115.df17520f.js"><link rel="prefetch" href="/assets/js/116.d31eff3d.js"><link rel="prefetch" href="/assets/js/117.4cacd460.js"><link rel="prefetch" href="/assets/js/118.0026b51f.js"><link rel="prefetch" href="/assets/js/119.a1852194.js"><link rel="prefetch" href="/assets/js/12.320fc3c1.js"><link rel="prefetch" href="/assets/js/120.041d64db.js"><link rel="prefetch" href="/assets/js/121.fa4fff07.js"><link rel="prefetch" href="/assets/js/122.7627979a.js"><link rel="prefetch" href="/assets/js/123.250ab4e6.js"><link rel="prefetch" href="/assets/js/124.de444c11.js"><link rel="prefetch" href="/assets/js/125.8cb9c188.js"><link rel="prefetch" href="/assets/js/126.6cd5cdc1.js"><link rel="prefetch" href="/assets/js/127.0a48ab4e.js"><link rel="prefetch" href="/assets/js/128.8082cb6b.js"><link rel="prefetch" href="/assets/js/129.4ba098d3.js"><link rel="prefetch" href="/assets/js/13.a13dfe15.js"><link rel="prefetch" href="/assets/js/130.85098665.js"><link rel="prefetch" href="/assets/js/131.cbc7e9aa.js"><link rel="prefetch" href="/assets/js/132.9a47facf.js"><link rel="prefetch" href="/assets/js/133.e36396c4.js"><link rel="prefetch" href="/assets/js/134.6a2bb3a1.js"><link rel="prefetch" href="/assets/js/135.cc810691.js"><link rel="prefetch" href="/assets/js/136.42257541.js"><link rel="prefetch" href="/assets/js/137.e4549850.js"><link rel="prefetch" href="/assets/js/138.fa9c345a.js"><link rel="prefetch" href="/assets/js/139.e86b3ed6.js"><link rel="prefetch" href="/assets/js/14.9f41a97e.js"><link rel="prefetch" href="/assets/js/140.edebfad9.js"><link rel="prefetch" href="/assets/js/142.f627f01d.js"><link rel="prefetch" href="/assets/js/143.75c9f155.js"><link rel="prefetch" href="/assets/js/144.e49a26a5.js"><link rel="prefetch" href="/assets/js/145.0fb681a8.js"><link rel="prefetch" href="/assets/js/146.c2f758a2.js"><link rel="prefetch" href="/assets/js/147.ff7736f8.js"><link rel="prefetch" href="/assets/js/148.97c3007e.js"><link rel="prefetch" href="/assets/js/149.21aa8990.js"><link rel="prefetch" href="/assets/js/15.a5a7e987.js"><link rel="prefetch" href="/assets/js/150.3829e474.js"><link rel="prefetch" href="/assets/js/151.27fa8be2.js"><link rel="prefetch" href="/assets/js/152.a48ff84a.js"><link rel="prefetch" href="/assets/js/153.80a9c0da.js"><link rel="prefetch" href="/assets/js/154.e36dccaf.js"><link rel="prefetch" href="/assets/js/155.2755d60e.js"><link rel="prefetch" href="/assets/js/156.544c6aa8.js"><link rel="prefetch" href="/assets/js/157.cb925cb1.js"><link rel="prefetch" href="/assets/js/158.9bef0b20.js"><link rel="prefetch" href="/assets/js/159.78e1580d.js"><link rel="prefetch" href="/assets/js/16.8241b7da.js"><link rel="prefetch" href="/assets/js/160.c9c45b53.js"><link rel="prefetch" href="/assets/js/161.0d8c2ee0.js"><link rel="prefetch" href="/assets/js/162.d07b59db.js"><link rel="prefetch" href="/assets/js/163.a023dae5.js"><link rel="prefetch" href="/assets/js/164.2e52d724.js"><link rel="prefetch" href="/assets/js/165.27b92328.js"><link rel="prefetch" href="/assets/js/166.acf3cea2.js"><link rel="prefetch" href="/assets/js/167.6acd0ef9.js"><link rel="prefetch" href="/assets/js/168.20d9677c.js"><link rel="prefetch" href="/assets/js/169.80b6b349.js"><link rel="prefetch" href="/assets/js/17.96e831bf.js"><link rel="prefetch" href="/assets/js/170.e33890fe.js"><link rel="prefetch" href="/assets/js/171.861a04ec.js"><link rel="prefetch" href="/assets/js/172.784763d0.js"><link rel="prefetch" href="/assets/js/173.50533ee5.js"><link rel="prefetch" href="/assets/js/174.d0770dc7.js"><link rel="prefetch" href="/assets/js/175.fc05d46e.js"><link rel="prefetch" href="/assets/js/176.902f13a2.js"><link rel="prefetch" href="/assets/js/177.653af950.js"><link rel="prefetch" href="/assets/js/178.85f8bed6.js"><link rel="prefetch" href="/assets/js/179.3e773a1d.js"><link rel="prefetch" href="/assets/js/18.54bf1af7.js"><link rel="prefetch" href="/assets/js/180.f277ce4e.js"><link rel="prefetch" href="/assets/js/181.a9c46d06.js"><link rel="prefetch" href="/assets/js/182.af79e65a.js"><link rel="prefetch" href="/assets/js/183.a3a4df8c.js"><link rel="prefetch" href="/assets/js/184.addf0766.js"><link rel="prefetch" href="/assets/js/185.e94f6487.js"><link rel="prefetch" href="/assets/js/186.46fc70ca.js"><link rel="prefetch" href="/assets/js/187.0134b297.js"><link rel="prefetch" href="/assets/js/188.650d765f.js"><link rel="prefetch" href="/assets/js/189.c244a120.js"><link rel="prefetch" href="/assets/js/19.845a90d0.js"><link rel="prefetch" href="/assets/js/190.425bf900.js"><link rel="prefetch" href="/assets/js/191.9664ab35.js"><link rel="prefetch" href="/assets/js/192.8a0d5dfe.js"><link rel="prefetch" href="/assets/js/193.680a103c.js"><link rel="prefetch" href="/assets/js/194.17f1219c.js"><link rel="prefetch" href="/assets/js/195.612ff0a5.js"><link rel="prefetch" href="/assets/js/196.c430a9e7.js"><link rel="prefetch" href="/assets/js/197.83699de8.js"><link rel="prefetch" href="/assets/js/198.716ad6de.js"><link rel="prefetch" href="/assets/js/199.4ee95f8e.js"><link rel="prefetch" href="/assets/js/20.e6f271d0.js"><link rel="prefetch" href="/assets/js/200.35a14eb6.js"><link rel="prefetch" href="/assets/js/201.d6f645b9.js"><link rel="prefetch" href="/assets/js/202.64b8e2da.js"><link rel="prefetch" href="/assets/js/203.655d71e1.js"><link rel="prefetch" href="/assets/js/204.a86d810c.js"><link rel="prefetch" href="/assets/js/205.2b3a07a2.js"><link rel="prefetch" href="/assets/js/206.b743206a.js"><link rel="prefetch" href="/assets/js/207.72a09a97.js"><link rel="prefetch" href="/assets/js/208.db2be4e9.js"><link rel="prefetch" href="/assets/js/209.fd28f705.js"><link rel="prefetch" href="/assets/js/21.e28fbf36.js"><link rel="prefetch" href="/assets/js/210.4e71b1e0.js"><link rel="prefetch" href="/assets/js/211.4703739e.js"><link rel="prefetch" href="/assets/js/212.63f30471.js"><link rel="prefetch" href="/assets/js/213.e680e41e.js"><link rel="prefetch" href="/assets/js/214.c8dd48dd.js"><link rel="prefetch" href="/assets/js/215.72abe369.js"><link rel="prefetch" href="/assets/js/216.aeaef106.js"><link rel="prefetch" href="/assets/js/217.c3772796.js"><link rel="prefetch" href="/assets/js/218.64bc986a.js"><link rel="prefetch" href="/assets/js/219.73d1fa0a.js"><link rel="prefetch" href="/assets/js/22.a71ec398.js"><link rel="prefetch" href="/assets/js/220.de26e052.js"><link rel="prefetch" href="/assets/js/221.36e8f0df.js"><link rel="prefetch" href="/assets/js/222.1d9ce0c9.js"><link rel="prefetch" href="/assets/js/223.a016c4db.js"><link rel="prefetch" href="/assets/js/224.9c839575.js"><link rel="prefetch" href="/assets/js/225.13c46704.js"><link rel="prefetch" href="/assets/js/226.364d7c7c.js"><link rel="prefetch" href="/assets/js/227.5750953e.js"><link rel="prefetch" href="/assets/js/228.610a2478.js"><link rel="prefetch" href="/assets/js/229.cbf88eea.js"><link rel="prefetch" href="/assets/js/23.bf21723b.js"><link rel="prefetch" href="/assets/js/230.f8b9328a.js"><link rel="prefetch" href="/assets/js/231.f9a0a90b.js"><link rel="prefetch" href="/assets/js/232.5d4a7a84.js"><link rel="prefetch" href="/assets/js/233.0b5b86ed.js"><link rel="prefetch" href="/assets/js/24.5d406214.js"><link rel="prefetch" href="/assets/js/25.3c559c4e.js"><link rel="prefetch" href="/assets/js/26.b35f305d.js"><link rel="prefetch" href="/assets/js/27.8399f3ef.js"><link rel="prefetch" href="/assets/js/28.069ac287.js"><link rel="prefetch" href="/assets/js/29.99abb653.js"><link rel="prefetch" href="/assets/js/30.b094c8c1.js"><link rel="prefetch" href="/assets/js/31.93e67089.js"><link rel="prefetch" href="/assets/js/32.885ca6e5.js"><link rel="prefetch" href="/assets/js/33.1b026b3a.js"><link rel="prefetch" href="/assets/js/34.7d9e0518.js"><link rel="prefetch" href="/assets/js/35.cb718883.js"><link rel="prefetch" href="/assets/js/36.e4051d3a.js"><link rel="prefetch" href="/assets/js/37.f10df9f2.js"><link rel="prefetch" href="/assets/js/38.0f0acf9b.js"><link rel="prefetch" href="/assets/js/39.e19534b5.js"><link rel="prefetch" href="/assets/js/4.803c74cf.js"><link rel="prefetch" href="/assets/js/40.35d881d7.js"><link rel="prefetch" href="/assets/js/41.8e88815e.js"><link rel="prefetch" href="/assets/js/42.a1ba4092.js"><link rel="prefetch" href="/assets/js/43.8b11027e.js"><link rel="prefetch" href="/assets/js/44.0d2a7d49.js"><link rel="prefetch" href="/assets/js/45.86926814.js"><link rel="prefetch" href="/assets/js/46.0feb6277.js"><link rel="prefetch" href="/assets/js/47.94acb5e5.js"><link rel="prefetch" href="/assets/js/48.a8d929ea.js"><link rel="prefetch" href="/assets/js/49.d3567452.js"><link rel="prefetch" href="/assets/js/5.444b0f34.js"><link rel="prefetch" href="/assets/js/50.0d9c0fa6.js"><link rel="prefetch" href="/assets/js/51.f4888c39.js"><link rel="prefetch" href="/assets/js/52.b87755b9.js"><link rel="prefetch" href="/assets/js/53.e93e59f1.js"><link rel="prefetch" href="/assets/js/54.1060153d.js"><link rel="prefetch" href="/assets/js/55.ac0c726e.js"><link rel="prefetch" href="/assets/js/56.45467df6.js"><link rel="prefetch" href="/assets/js/57.b8d15375.js"><link rel="prefetch" href="/assets/js/58.f244929d.js"><link rel="prefetch" href="/assets/js/59.895379e0.js"><link rel="prefetch" href="/assets/js/6.b313ca13.js"><link rel="prefetch" href="/assets/js/60.0419815a.js"><link rel="prefetch" href="/assets/js/61.21c51cb2.js"><link rel="prefetch" href="/assets/js/62.1b8f37f7.js"><link rel="prefetch" href="/assets/js/63.ad8de636.js"><link rel="prefetch" href="/assets/js/64.0093f639.js"><link rel="prefetch" href="/assets/js/65.0e01a6bf.js"><link rel="prefetch" href="/assets/js/66.e97159d3.js"><link rel="prefetch" href="/assets/js/67.e8061766.js"><link rel="prefetch" href="/assets/js/68.f34d46d4.js"><link rel="prefetch" href="/assets/js/69.3ca0a953.js"><link rel="prefetch" href="/assets/js/7.c1e45b9f.js"><link rel="prefetch" href="/assets/js/70.d605c150.js"><link rel="prefetch" href="/assets/js/71.abc1fcc3.js"><link rel="prefetch" href="/assets/js/72.9bffdb55.js"><link rel="prefetch" href="/assets/js/73.fa607e57.js"><link rel="prefetch" href="/assets/js/74.9c0e3cfb.js"><link rel="prefetch" href="/assets/js/75.1ab3065b.js"><link rel="prefetch" href="/assets/js/76.87cd9888.js"><link rel="prefetch" href="/assets/js/77.8abaef86.js"><link rel="prefetch" href="/assets/js/78.e39b9d0b.js"><link rel="prefetch" href="/assets/js/79.d9083241.js"><link rel="prefetch" href="/assets/js/8.a6eb682b.js"><link rel="prefetch" href="/assets/js/80.9cc05ca8.js"><link rel="prefetch" href="/assets/js/81.156a6fd5.js"><link rel="prefetch" href="/assets/js/82.d811b43f.js"><link rel="prefetch" href="/assets/js/83.72f16ac6.js"><link rel="prefetch" href="/assets/js/84.f035b7d4.js"><link rel="prefetch" href="/assets/js/85.280c2d8e.js"><link rel="prefetch" href="/assets/js/86.a16d925d.js"><link rel="prefetch" href="/assets/js/87.8b963edd.js"><link rel="prefetch" href="/assets/js/88.8c95f47d.js"><link rel="prefetch" href="/assets/js/89.5c41fbd7.js"><link rel="prefetch" href="/assets/js/9.d5d709ef.js"><link rel="prefetch" href="/assets/js/90.cc50607b.js"><link rel="prefetch" href="/assets/js/91.4e6d5419.js"><link rel="prefetch" href="/assets/js/92.9c20933c.js"><link rel="prefetch" href="/assets/js/93.fecfdfef.js"><link rel="prefetch" href="/assets/js/94.1a370bd8.js"><link rel="prefetch" href="/assets/js/95.73c068b2.js"><link rel="prefetch" href="/assets/js/96.e367a495.js"><link rel="prefetch" href="/assets/js/97.2add5811.js"><link rel="prefetch" href="/assets/js/98.6e14bcc0.js"><link rel="prefetch" href="/assets/js/99.e1dd0173.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56546b06.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">小武子知识库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/js/" class="nav-link router-link-active">javascript</a></div><div class="nav-item"><a href="/css/" class="nav-link">css</a></div><div class="nav-item"><a href="/html5/" class="nav-link">HTML5</a></div><div class="nav-item"><a href="/tool/" class="nav-link">工具</a></div><div class="nav-item"><a href="/project/" class="nav-link">软件工程</a></div><div class="nav-item"><a href="/cs/" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/materials/" class="nav-link">资料收集</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于作者</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/js/" class="nav-link router-link-active">javascript</a></div><div class="nav-item"><a href="/css/" class="nav-link">css</a></div><div class="nav-item"><a href="/html5/" class="nav-link">HTML5</a></div><div class="nav-item"><a href="/tool/" class="nav-link">工具</a></div><div class="nav-item"><a href="/project/" class="nav-link">软件工程</a></div><div class="nav-item"><a href="/cs/" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/materials/" class="nav-link">资料收集</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于作者</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>javascript基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/es5-expression.html" class="sidebar-link">表达式与运算符</a></li><li><a href="/js/es5-type.html" class="sidebar-link">数据类型与数据类型转换</a></li><li><a href="/js/es5-prototype.html" class="sidebar-link">原型与原型链</a></li><li><a href="/js/es5-this.html" class="sidebar-link">this 解析</a></li><li><a href="/js/es5-closure.html" class="sidebar-link">闭包</a></li><li><a href="/js/es5-apply-call-bind.html" class="sidebar-link">apply&amp;bind&amp;call</a></li><li><a href="/js/es5-dom.html" class="sidebar-link">DOM与BOM</a></li><li><a href="/js/es5-event.html" class="sidebar-link">事件</a></li><li><a href="/js/es5-execution-context.html" class="sidebar-link">执行上下文与执行上下文栈</a></li><li><a href="/js/es5-extends.html" class="sidebar-link">继承</a></li><li><a href="/js/es5-fn.html" class="sidebar-link">函数</a></li><li><a href="/js/es5-news.html" class="sidebar-link">new 理解</a></li><li><a href="/js/es5-array.html" class="sidebar-link">数组</a></li><li><a href="/js/es5-object.html" class="sidebar-link">对象</a></li><li><a href="/js/es5-reg.html" class="sidebar-link">正则表达式学习</a></li><li><a href="/js/es5-scope.html" class="sidebar-link">作用域</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>javascript进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/js-curry.html" class="sidebar-link">函数柯理化</a></li><li><a href="/js/js-debounce.html" class="sidebar-link">节流与防抖动</a></li><li><a href="/js/js-precision.html" class="sidebar-link">js 精度丢失问题</a></li><li><a href="/js/js-memory.html" class="sidebar-link">js 内存管理</a></li><li><a href="/js/js-async.html" class="sidebar-link">事件循环和异步编程的崛起</a></li><li><a href="/js/js-bit.html" class="sidebar-link">js 位运算</a></li><li><a href="/js/js-eventloop.html" class="active sidebar-link">理解 EventLoop</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/js-eventloop.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/js/js-eventloop.html#内容" class="sidebar-link">内容</a></li><li class="sidebar-sub-header"><a href="/js/js-eventloop.html#联系作者" class="sidebar-link">联系作者</a></li></ul></li><li><a href="/js/js-module.html" class="sidebar-link">js 模块化</a></li><li><a href="/js/js-run.html" class="sidebar-link">javascript 执行过程</a></li><li><a href="/js/js-ast.html" class="sidebar-link">解析、抽象语法树（AST）+ 提升编译速度 5 个技巧</a></li><li><a href="/js/js-v8.html" class="sidebar-link">V8 简介</a></li><li><a href="/js/js-principle.html" class="sidebar-link">JS 编译器，解释引擎</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>es6</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/es6-array.html" class="sidebar-link">数组扩展</a></li><li><a href="/js/es6-fn.html" class="sidebar-link">函数扩展</a></li><li><a href="/js/es6-class-1.html" class="sidebar-link">Class 基本用法</a></li><li><a href="/js/es6-class-2.html" class="sidebar-link">Class继承</a></li><li><a href="/js/es6-async.html" class="sidebar-link">async 函数</a></li><li><a href="/js/es6-generator-1.html" class="sidebar-link">Generator 函数的语法</a></li><li><a href="/js/es6-generator-2.html" class="sidebar-link">Generator 函数的异步应用</a></li><li><a href="/js/es6-iterator.html" class="sidebar-link">Iterator 和 for...of 循环</a></li><li><a href="/js/es6-let-const.html" class="sidebar-link">let 与 const</a></li><li><a href="/js/es6-module.html" class="sidebar-link">Module 对象</a></li><li><a href="/js/es6-number.html" class="sidebar-link">数值扩展</a></li><li><a href="/js/es6-object.html" class="sidebar-link">对象扩展</a></li><li><a href="/js/es6-promise.html" class="sidebar-link">Promise 对象</a></li><li><a href="/js/es6-proxy-reflect.html" class="sidebar-link">Proxy 和 Reflect</a></li><li><a href="/js/es6-set-map.html" class="sidebar-link">Set和Map数据结构</a></li><li><a href="/js/es6-string.html" class="sidebar-link">字符串扩展</a></li><li><a href="/js/es6-symbol.html" class="sidebar-link">Symbol</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/ts-introduct.html" class="sidebar-link">ts 学习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>nodejs</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/node-introdect.html" class="sidebar-link">node 介绍</a></li><li><a href="/js/node-buffer.html" class="sidebar-link">buffer 模块</a></li><li><a href="/js/node-cheerio.html" class="sidebar-link">cheerio 模块</a></li><li><a href="/js/node-cluster.html" class="sidebar-link">cluster 集群</a></li><li><a href="/js/node-egg.html" class="sidebar-link">egg 基础应用</a></li><li><a href="/js/node-events.html" class="sidebar-link">events 模块</a></li><li><a href="/js/node-express.html" class="sidebar-link">express 基础应用</a></li><li><a href="/js/node-fs.html" class="sidebar-link">fs 模块</a></li><li><a href="/js/node-http.html" class="sidebar-link">http 模块</a></li><li><a href="/js/node-koa.html" class="sidebar-link">koa 基础应用</a></li><li><a href="/js/node-koa-code.html" class="sidebar-link">koa 源码分析</a></li><li><a href="/js/node-net.html" class="sidebar-link">net 模块</a></li><li><a href="/js/node-process.html" class="sidebar-link">process 进程</a></li><li><a href="/js/node-querystring.html" class="sidebar-link">querystring 模块</a></li><li><a href="/js/node-stream.html" class="sidebar-link">stream 模块</a></li><li><a href="/js/node-url.html" class="sidebar-link">url 模块</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>vue框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/mvvm.html" class="sidebar-link">mvvm 框架介绍</a></li><li><a href="/js/jquery-code.html" class="sidebar-link">jquery 源码分析</a></li><li><a href="/js/undescore.html" class="sidebar-link">undescore 源码分析</a></li><li><a href="/js/vue-lifecycle.html" class="sidebar-link">Vue生命周期</a></li><li><a href="/js/vue-bind.html" class="sidebar-link">vue 双向数据绑定原理</a></li><li><a href="/js/vue-nexttick.html" class="sidebar-link">Vue.netTick理解与分析</a></li><li><a href="/js/vue-watch.html" class="sidebar-link">Vue中的computed,watch,methods理解与分析</a></li><li><a href="/js/vue-code.html" class="sidebar-link">vue 源码分析</a></li><li><a href="/js/vue-diff.html" class="sidebar-link">diff 算法</a></li><li><a href="/js/vue-router-code.html" class="sidebar-link">vue-router 源码分析</a></li><li><a href="/js/vue-communication.html" class="sidebar-link">vue 组件通信</a></li><li><a href="/js/vue-router.html" class="sidebar-link">vue-router 学习及原理</a></li><li><a href="/js/vue-vuex.html" class="sidebar-link">vuex 学习及原理</a></li><li><a href="/js/vue-vuex-code.html" class="sidebar-link">vue-vuex 源码分析</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="理解-eventloop"><a href="#理解-eventloop" aria-hidden="true" class="header-anchor">#</a> 理解 EventLoop</h1> <h2 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h2> <p><code>Event Loop</code>即事件循环，是指浏览器或<code>Node</code>的一种解决<code>javaScript</code>单线程运行时不会阻塞的一种机制，也就是我们经常使用<strong>异步</strong>的原理。</p> <h2 id="内容"><a href="#内容" aria-hidden="true" class="header-anchor">#</a> 内容</h2> <ul><li><a href="#%E4%B8%80%E3%80%81%E5%A0%86%E6%A0%88%E9%98%9F%E5%88%97">堆，栈、队列</a></li> <li><a href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B">线程与进程</a></li> <li><a href="#%E4%B8%89%E3%80%81event-loop">Event Loop</a></li> <li><a href="#%E5%9B%9B%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84event-loop">浏览器中的 Event Loop</a></li> <li><a href="#%E4%BA%94%E3%80%81%E4%BE%8B%E5%AD%90">例子</a></li> <li><a href="#%E5%85%AD%E3%80%81nodejs%E7%9A%84event-loop">NodeJS 的 Event Loop</a></li></ul> <h3 id="一、堆，栈、队列"><a href="#一、堆，栈、队列" aria-hidden="true" class="header-anchor">#</a> 一、堆，栈、队列</h3> <p><img src="eventloop.png" alt=""></p> <ul><li><a href="#11-%E5%A0%86">堆</a></li> <li><a href="#12-%E6%A0%88">栈</a></li> <li><a href="#13-%E9%98%9F%E5%88%97">队列</a></li></ul> <h4 id="_1-1-堆"><a href="#_1-1-堆" aria-hidden="true" class="header-anchor">#</a> 1.1 堆</h4> <p><strong>堆</strong>是一种数据结构，是利用完全二叉树维护的一组数据，堆分为两种，一种为最大<strong>堆</strong>，一种为最小<strong>堆</strong>，将根节点<strong>最大</strong>的<strong>堆</strong>叫做<strong>最大堆</strong>或<strong>大根堆</strong>，根节点<strong>最小</strong>的<strong>堆</strong>叫做<strong>最小堆</strong>或<strong>小根堆</strong>。</p> <p><strong>堆</strong>是<strong>线性数据结构</strong>，相当于<strong>一维数组</strong>，有唯一后继。</p> <p>如最大堆</p> <p><img src="eventloop01.png" alt=""></p> <h4 id="_1-2-栈"><a href="#_1-2-栈" aria-hidden="true" class="header-anchor">#</a> 1.2 栈</h4> <p><strong>栈</strong>在计算机科学中是限定仅在<strong>表尾</strong>进行<strong>插入</strong>或<strong>删除</strong>操作的线性表。<strong>栈</strong>是一种数据结构，它按照<strong>后进先出</strong>的原则存储数据，<strong>先进入</strong>的数据被压入<strong>栈底</strong>，<strong>最后的数据在栈顶</strong>，需要读数据的时候从<strong>栈顶</strong>开始<strong>弹出数据</strong>。</p> <p><strong>栈</strong>是只能在<strong>某一端插入</strong>和<strong>删除</strong>的<strong>特殊线性表</strong>。</p> <p><img src="eventloop02.png" alt=""></p> <h4 id="_1-3-队列"><a href="#_1-3-队列" aria-hidden="true" class="header-anchor">#</a> 1.3 队列</h4> <p>特殊之处在于它只允许在表的前端进行<strong>删除</strong>操作，而在表的后端进行<strong>插入</strong>操作，和<strong>栈</strong>一样，<strong>队列</strong>是一种操作受限制的线性表。</p> <p>进行<strong>插入</strong>操作的端称为<strong>队尾</strong>，进行<strong>删除</strong>操作的称为<strong>队头</strong>。队列中没有元素时，称为<strong>空队列</strong>。</p> <p><strong>队列</strong>的数据元素又称为<strong>队列元素</strong>。在队列中插入一个队列元素称为<strong>入队</strong>，从<strong>队列</strong>中一个队列歹毒称为<strong>出队</strong>。因为队列<strong>只允许</strong>在一端<strong>插入</strong>，在另一端<strong>删除</strong>，所以只有<strong>最早</strong>进入<strong>队列</strong>的元素<strong>才能最先从队列中</strong>删除，故队列又称为<strong>先进先出</strong>。</p> <h3 id="二、线程与进程"><a href="#二、线程与进程" aria-hidden="true" class="header-anchor">#</a> 二、线程与进程</h3> <p>官方的说法是：进程是 CPU 资源分配的最小单位；线程是 CPU 调度的最小单位。</p> <p>这两句话并不好理解，我们先来看张图：</p> <p><img src="eventloop03.png" alt=""></p> <ul><li>进程好比图中的工厂，有单独的专属自己的工厂资源。</li> <li>线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n 的关系。也就是说<strong>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</strong>；</li> <li>工厂空间是工厂共享的，这象征一个进程的内在空间是共享的，每个线程都可用这些共享内存。</li> <li>多个工厂之间独立存在。</li></ul> <h3 id="三、event-loop"><a href="#三、event-loop" aria-hidden="true" class="header-anchor">#</a> 三、Event Loop</h3> <p>在<code>JavaScript</code>中，任务被分为两种，一种宏任务（<code>MacroTask</code>）也叫<code>Task</code>，一种叫微任务（<code>MicroTask</code>）。</p> <ul><li><a href="#31-macrotask%E5%AE%8F%E4%BB%BB%E5%8A%A1">MacroTask（宏任务）</a></li> <li><a href="#32-microtask%E5%BE%AE%E4%BB%BB%E5%8A%A1">MicroTask（微任务）</a></li></ul> <h4 id="_3-1-macrotask（宏任务）"><a href="#_3-1-macrotask（宏任务）" aria-hidden="true" class="header-anchor">#</a> 3.1 MacroTask（宏任务）</h4> <ul><li><code>script</code>全部代码、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（浏览器暂时不支持，只有 IE10 支持，具体可见 MDN）、<code>I/O</code>、<code>UI Rendering</code>。</li></ul> <h4 id="_3-2-microtask（微任务）"><a href="#_3-2-microtask（微任务）" aria-hidden="true" class="header-anchor">#</a> 3.2 MicroTask（微任务）</h4> <ul><li><code>Process.nextTick(node独有)</code>、<code>Promise</code>、<code>Object.observe(废弃)</code>、<code>MutationObserver</code>（具体使用方式查看[这里](http://javascript.ruanyifeng.com/dom/mutationobserver.html）</li></ul> <h3 id="四、浏览器中的-event-loop"><a href="#四、浏览器中的-event-loop" aria-hidden="true" class="header-anchor">#</a> 四、浏览器中的 Event Loop</h3> <p><code>Javascript</code>有一个<code>main thread</code>主线程和<code>call-stack</code>调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p> <ul><li><a href="#41-js%E8%B0%83%E7%94%A8%E6%A0%88">JS 调用栈</a></li> <li><a href="#42-%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1">同步任务和异步任务</a></li> <li><a href="#43-event-loop-%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90">Event Loop 过程解析</a></li></ul> <h4 id="_4-1-js-调用栈"><a href="#_4-1-js-调用栈" aria-hidden="true" class="header-anchor">#</a> 4.1 JS 调用栈</h4> <p>JS 调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行完后，就会从栈顶移出，直到栈内被清空。</p> <h4 id="_4-2-同步任务和异步任务"><a href="#_4-2-同步任务和异步任务" aria-hidden="true" class="header-anchor">#</a> 4.2 同步任务和异步任务</h4> <p><code>JavaScript</code>单线程任务被分为<strong>同步任务</strong>和<strong>异步任务</strong>，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。</p> <p><img src="eventloop05.jpg" alt=""></p> <p>任务队列<code>Task Queue</code>，即队列，是一种先进先出的一种数据结构。</p> <h4 id="_4-3-event-loop-过程解析"><a href="#_4-3-event-loop-过程解析" aria-hidden="true" class="header-anchor">#</a> 4.3 Event Loop 过程解析</h4> <p><img src="eventloop04.png" alt=""></p> <ul><li>一开始执行栈空我们可以把**执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。**micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li> <li>全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里，同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</li> <li>上一步我们出队的是一个 macro-task,这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是<strong>一个一个</strong>执行的；而 micro-task 出队时，任务是<strong>一队一队</strong>执行的。因此我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</li> <li><strong>执行渲染操作，更新界面</strong></li> <li>检查是否存在 Web worker 任务，如果有，则对其进行处理</li> <li>上述过程循环往复，直到两个队列都清空</li></ul> <p>我们总结一下，每一次循环都是一个这样的过程：</p> <p><img src="eventloop07.png" alt=""></p> <p><strong>当某个宏任务执行完后，会查看是否有微任务队列，如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再依次读取微任务队列里的任务，依次类推。</strong></p> <p><strong>mactotask &amp; microtask 的执行顺序</strong></p> <p><img src="eventloop06.png" alt=""></p> <h3 id="五、例子"><a href="#五、例子" aria-hidden="true" class="header-anchor">#</a> 五、例子</h3> <ul><li><a href="#5.1-%E4%BE%8B%E4%B8%80">例一</a></li> <li><a href="#5.2-%E4%BE%8B%E4%BA%8C">例二</a></li></ul> <h4 id="_5-1-例一"><a href="#_5-1-例一" aria-hidden="true" class="header-anchor">#</a> 5.1 例一</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>    console.log('start');

    setTimeout(function(){
        console.log('setTimeout')
    },0)

    Promise.resolve().then(function(){
        console.log('promise1')
    }).then(function(){
        console.log('promise2')
    })

    console.log('end')

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>打印台输出的 log 顺序是什么？结合上述的步骤分析。</p> <p><img src="browser-deom1-excute-animate.gif" alt=""></p> <ul><li>首先，全局代码（main()）压入调用栈执行，打印<code>start</code>;</li> <li>接下来<code>setTimeout</code>压入<code>macrotask</code>队列，<code>promise.then</code>回调放入<code>microtask</code>队列，最后执行<code>console.log('end')</code>，打印出<code>end</code>;</li> <li>至此，调用栈中的代码被执行完成，回顾<code>macrotask</code>的定义，我们知道全局代码属于<code>macrotask</code>，<code>macrotask</code>执行完，那接下来就是执行<code>microtask</code>队列的任务了，执行<code>promise</code>回调打印<code>promise1</code>;</li> <li><code>promise</code>回调函数默认返回<code>undefined</code>，promise 状态变为<code>fullfill</code>触发接下来的<code>then</code>架设，继续压入<code>microtask</code>队列，<strong>event loop 会把当前的 microtask 队列一直执行完</strong>，此时执行第二个<code>promise.then</code>回调打印出<code>promise2</code>;</li> <li>这时<code>microtask</code>队列已经为空，从上面的流程图可以知道，接下来主线程会去做一些 UI 渲染工作，然后开始下一轮<code>event loop</code>,执行<code>setTimeout</code>的回调，打印出<code>setTimeout</code>;</li></ul> <h4 id="_5-2-例二"><a href="#_5-2-例二" aria-hidden="true" class="header-anchor">#</a> 5.2 例二</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>Promise.resolve().then(()=&gt;{
    console.log('Promise1')
    setTimeout(()=&gt;{
        console.log('setTimeout2');
    },0)
});
setTimeout(()=&gt;{
    console.log('setTimeout1');
    Promise.resolve().then(()=&gt;{
        console.log('Promise2')
    })
},0)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>最后输出结果是 Promise1，setTimeout1，Promise2，setTimeout2</p> <ul><li>一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在（有且只有一个），然后执行微任务队列中的所有任务输出<code>Promise1</code>，同时会生成一个宏任务<code>setTimeout2</code></li> <li>然后去查看宏任务队列，宏任务<code>setTimeout1</code>在<code>setTimeout2</code>之前，先执行宏任务<code>setTimeout1</code>，输出<code>setTimeout1</code></li> <li>在执行宏任务<code>setTimeout1</code>时会生成微任务<code>Promise2</code>，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出<code>Promise2</code></li> <li>清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是<code>setTimeout2</code></li></ul> <h3 id="六、nodejs-的-event-loop"><a href="#六、nodejs-的-event-loop" aria-hidden="true" class="header-anchor">#</a> 六、NodeJS 的 Event Loop</h3> <ul><li><a href="#61-node%E7%AE%80%E4%BB%8B">Node 简介</a></li> <li><a href="#62-%E5%85%AD%E4%B8%AA%E9%98%B6%E6%AE%B5">六个阶段</a></li> <li><a href="#63-micro-task-%E4%B8%8E-macro-task">Micro-Task 与 Macro-Task</a></li> <li><a href="#64-%E6%B3%A8%E6%84%8F%E7%82%B9">注意点</a></li></ul> <h4 id="_6-1-node-简介"><a href="#_6-1-node-简介" aria-hidden="true" class="header-anchor">#</a> 6.1 Node 简介</h4> <p>Node 中 Event Loop 和浏览器中的是完全不相同的东西。Nodejs 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对处提供统一的 API，事件循环机制也是它里面的实现。</p> <p><img src="eventloop08.png" alt=""></p> <p>Node.js 的运行机制如下：</p> <ul><li>V8 引擎解析 JavaScript 脚本。</li> <li>解析后的代码，调用 Node API。</li> <li>libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop(事件循环)，以异步的方式将任务的执行结果返回给 V8 引擎。</li> <li>V8 引擎再将结果返回给用户。</li></ul> <h4 id="_6-2-六个阶段"><a href="#_6-2-六个阶段" aria-hidden="true" class="header-anchor">#</a> 6.2 六个阶段</h4> <p>其中 libuv 引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的架设队列中取出函数去执行。当队列为空或者执行的回调函数数量达到系统设定的阈值，就会进入下一阶段。</p> <p><img src="eventloop09.png" alt=""></p> <p>从上图中，大致看出 node 中的事件循环的顺序：</p> <p>外部输入数据——&gt;轮询阶段(poll)——&gt;检查阶段(check)——&gt;关闭事件回调阶段(close callback)——&gt;定时器检测阶段(timer)——&gt;I/O 事件回调阶段(I/O callbacks)——&gt;闲置阶段(idle,prepare)——&gt;轮询阶段(按照该顺序反复运行)</p> <ul><li>timers 阶段：这个阶段执行 timer(setTimeout、setInterval)的回调</li> <li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li> <li>idle,prepare 阶段：仅 node 内部使用</li> <li>poll 阶段：获取新的 I/O 事件，适当的条件下 node 将阻塞在这里</li> <li>check 阶段：执行 setImmediate()的回调</li> <li>close callbacks 阶段：执行 socket 的 close 事件回调</li></ul> <p>注意：<strong>上面六个阶段都不包括</strong>process.nextTick()</p> <p>接下去我们详细介绍<code>timers</code>、<code>poll</code>、<code>check</code>这 3 个阶段，因为日常开发中的绝大部分异步任务都是在这 3 个阶段处理的。</p> <p><strong>(1) timer</strong></p> <p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。同样，<strong>在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行</strong>。</p> <p><strong>(2) poll</strong></p> <p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p> <ol><li>回到 timer 阶段执行回调</li> <li>执行 I/O 回调</li></ol> <p>并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情</p> <ul><li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li> <li>如果 poll 队列为空时，会有两件事发生
<ul><li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li> <li>如果没有 setImmediate 回调需要执行，会先行回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止设置防止一直先行下去</li></ul></li></ul> <p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p> <p><strong>(3) check 阶段</strong></p> <p>setImmediate()的回调会被加入 check 队列中，从 event loop 的阶段图可以知道，check 阶段的执行顺序在 poll 阶段之后。</p> <p>我们先来看个例子：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>console.log('start')
setTimeout(()=&gt;{

},0);
setTimeout(()=&gt;{
    console.log('timer2')
    Promise.resolve().then(function(){
        console.log('promise2')
    },0)
})
Promise.resolve().then(function(){
    console.log('promise3')
})
console.log('end');
// start=&gt;end=&gt;promise3=&gt;timer1=&gt;timer2=&gt;promise1=&gt;promise2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li>一开始执行栈的同步任务(这属于宏任务)执行完毕后(依次打印出 start end,并将 2 个 timer 依次放入 timer 队列)，会先去执行微任务(<strong>这点跟浏览器端的一样</strong>)，所以打印出 promise3</li> <li>然后进入 timer 阶段，执行 timer1 的回调函数，打印 timer1，并将 promise.then 回调放入 microtask 队列，同样的步骤执行 timer2，打印 timer2；这点跟浏览器端相差比较大，<strong>timer 阶段有几个 setTimeout/setInterval 都会依次执行</strong>，并不像浏览器端，每执行一个宏任务后就支执行一个微任务。</li></ul> <h4 id="_6-3-micro-task-与-macro-task"><a href="#_6-3-micro-task-与-macro-task" aria-hidden="true" class="header-anchor">#</a> 6.3 Micro-Task 与 Macro-Task</h4> <p>Node 端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。</p> <ul><li>常见的 macro-task 比如：setTimeout、setInterval、setImmediate、script(整体代码)、I/O 操作等。</li> <li>常见的 micro-task 比如：process.nextTick、new Promise().then(回调)等。</li></ul> <h4 id="_6-4-注意点"><a href="#_6-4-注意点" aria-hidden="true" class="header-anchor">#</a> 6.4 注意点</h4> <p><strong>(1) setTimeout 和 setImmediate</strong></p> <p>二者非常相似，区别主要在于调用时间时机不同。</p> <ul><li>setImmediate 设计在 poll 阶段完成时执行，即 check 阶段。</li> <li>setTimeout 设计在 poll 阶段为空闲时，且设定到达后执行，但它的 timer 阶段执行</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>setTimeout(function timeout(){
    console.log('timeout');
},0);
setImmediate(function immediate(){
 console.log('immediate');
})

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。</li> <li>首先 setTimeout(fn,0)===setTimeout(fn,1)这是由源码决定的进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调</li> <li>如果准备时间花费小于 1ms，那么就 setImmediate 回调先执行了</li></ul> <p>但当二者在异步 i/o callback 内部调用时，总是先执行 setImmediate，再执行 setTimeout</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const fs = require('fs');

fs.readFile(__filename,()=&gt;{
    setTimeout(()=&gt;{
        console.log('timeout')
    },0)
    setImmediate(()=&gt;{
        console.log('immedidate')
    })
})

// immediate
// timeout

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。</p> <p><strong>(2) process.nextTick</strong></p> <p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>setTimeout(()=&gt;{
    console.log('timer1')
    Promise.resolve().then(function(){
        console.log('promise1')
    })
},0)
process.nextTick(()=&gt;{
    console.log('nextTick')
    process.nextTick(()=&gt;{
        console.log('nextTick');
        process.nextTick(()=&gt;[
            console.log('nextTick')
            process.nextTick(()=&gt;[
                console.log('nextTick')
            ])
        ])
    })
})

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="七、node-与浏览器的-event-loop-差异"><a href="#七、node-与浏览器的-event-loop-差异" aria-hidden="true" class="header-anchor">#</a> 七、Node 与浏览器的 Event Loop 差异</h3> <p><strong>浏览器环境下，microtask 的任务队列是每个 macrotask 执行完之后执行。而在 Node.js 中，microtask 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtask 队列的任务。</strong></p> <p><img src="eventloop10.png" alt=""></p> <p>接下我们通过一个例子来说明两者区别：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>setTimeout(()=&gt;{
    console.log('timer1')
    Promise.resolve().then(function(){
        console.log('promise1')
    })
},0)

setTimeout(()=&gt;{
    console.log('timer2')
    Promise.resolve().then(function(){
        console.log('promise2')
    })
},0)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>浏览器端运行结果：<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></p> <p>浏览器的处理过程如下:</p> <p><img src="browser-deom2-excute-animate.gif" alt=""></p> <p>Node 端运行结果分两种情况：</p> <ul><li>如果 node11 版本一量执行一个阶段里的一个宏任务(setTimeout.setInterval 和 setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li> <li>如果是 node10 及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中。
<ul><li>如果是第二个定时器还未在完成队列中，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li> <li>如果是第二个定时器已经完成队列中，则最后的结果为<code>timer1=&gt;timer2=&gt;promise1=&gt;promise2</code></li></ul></li></ul> <ol><li>全局脚本(main())执行，将 2 个 timer 依次放入 timer 队列，main()执行完毕，调用栈空闲，任务队列开始执行；</li> <li>首先进入 timer 阶段，执行 timer1 的回调函数，打印 timer1，并将 promise1.then 回调放入 microtas 队列，同样的步骤执行 timer2,打印 timer2;</li> <li>至此，timer 阶段执行结束，event loop 进入下一个阶段之前，执行 microtask 队列的所有任务，依次打印 promise1、promise2</li></ol> <p>Node 端的处理过程如下：</p> <p><img src="nodejs-deom-excute-animate.gif" alt=""></p> <h3 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h3> <p>浏览器和 Node 环境下，microtask 任务队列的执行时机不同</p> <ul><li>Node 端，microtask 在事件循环的各个阶段之间执行</li> <li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li></ul> <h3 id="参考资料"><a href="#参考资料" aria-hidden="true" class="header-anchor">#</a> 参考资料</h3> <ul><li><a href="https://juejin.im/post/5c3d8956e51d4511dc72c200" target="_blank" rel="noopener noreferrer">一次弄懂 Event Loop（彻底解决此类面试问题）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5be04a8e6fb9a04a072fd2cd" target="_blank" rel="noopener noreferrer">Event Loop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5a6547d0f265da3e283a1df7" target="_blank" rel="noopener noreferrer">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/ljianshu/Blog/issues/54" target="_blank" rel="noopener noreferrer">浏览器与 Node 的事件循环(Event Loop)有何区别?<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener noreferrer">这一次，彻底弄懂 JavaScript 执行机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://segmentfault.com/a/1190000013861128" target="_blank" rel="noopener noreferrer">一篇文章教会你 Event loop——浏览器和 Node<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://zhuanlan.zhihu.com/p/33058983" target="_blank" rel="noopener noreferrer">详解 JavaScript 中的 Event Loop（事件循环）机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5be04a8e6fb9a04a072fd2cd" target="_blank" rel="noopener noreferrer">Event Loop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s/8xyccve0e9uA2mnk07CAWw" target="_blank" rel="noopener noreferrer">面试问到 Event Loop，这样回答最完美<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s/RNYYNR7A01V-Y2aC1wNsGw" target="_blank" rel="noopener noreferrer">分享 10 道 Nodejs EventLoop 和事件相关面试题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s/DLunwkzknoQ0tczLHuqpHg" target="_blank" rel="noopener noreferrer">「前端进阶」从多线程角度来看 Event Loop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s/nQgsEQorv00fr4XqU764bA" target="_blank" rel="noopener noreferrer">【THE LAST TIME】彻底吃透 JavaScript 执行机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s/kG4FHXlqbKFWYQCtPhLtxA" target="_blank" rel="noopener noreferrer">《一文看懂浏览器事件循环》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="联系作者"><a href="#联系作者" aria-hidden="true" class="header-anchor">#</a> 联系作者</h2> <div align="center"><p>
        平凡世界，贵在坚持。
    </p> <img src="/about/contact.png"></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新于:</span> <span class="time">2019-12-12 09:11:40</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/js/js-bit.html" class="prev">js 位运算</a></span> <span class="next"><a href="/js/js-module.html">js 模块化</a>→
    </span></p></div> </main></div><div class="global-ui"><!----><!----><div></div></div></div>
    <script src="/assets/js/app.9f912bc1.js" defer></script><script src="/assets/js/2.67134772.js" defer></script><script src="/assets/js/141.282ec3ff.js" defer></script><script src="/assets/js/3.65dbdf4c.js" defer></script>
  </body>
</html>
