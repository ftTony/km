<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue 源码分析 | 小武子知识库</title>
    <meta name="description" content="用心，谈技术。大前端">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/hero.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.23dd1510.css" as="style"><link rel="preload" href="/assets/js/app.8e84e2a6.js" as="script"><link rel="preload" href="/assets/js/2.c7f5c1a5.js" as="script"><link rel="preload" href="/assets/js/208.d29fd0df.js" as="script"><link rel="preload" href="/assets/js/3.fb5a4386.js" as="script"><link rel="prefetch" href="/assets/js/10.1bd37a44.js"><link rel="prefetch" href="/assets/js/100.3c6bb441.js"><link rel="prefetch" href="/assets/js/101.b970bbfd.js"><link rel="prefetch" href="/assets/js/102.b94ccfb4.js"><link rel="prefetch" href="/assets/js/103.fd760c7d.js"><link rel="prefetch" href="/assets/js/104.c22b1692.js"><link rel="prefetch" href="/assets/js/105.08ecb208.js"><link rel="prefetch" href="/assets/js/106.cea9cae3.js"><link rel="prefetch" href="/assets/js/107.b728f32f.js"><link rel="prefetch" href="/assets/js/108.7f903918.js"><link rel="prefetch" href="/assets/js/109.e9c1e6de.js"><link rel="prefetch" href="/assets/js/11.61939ed3.js"><link rel="prefetch" href="/assets/js/110.69baf038.js"><link rel="prefetch" href="/assets/js/111.f4a4ddb2.js"><link rel="prefetch" href="/assets/js/112.826e14a0.js"><link rel="prefetch" href="/assets/js/113.94d8147e.js"><link rel="prefetch" href="/assets/js/114.670eac13.js"><link rel="prefetch" href="/assets/js/115.eff29a9a.js"><link rel="prefetch" href="/assets/js/116.1d71ae36.js"><link rel="prefetch" href="/assets/js/117.111a1770.js"><link rel="prefetch" href="/assets/js/118.2504308c.js"><link rel="prefetch" href="/assets/js/119.04c17310.js"><link rel="prefetch" href="/assets/js/12.23af66e8.js"><link rel="prefetch" href="/assets/js/120.68ddcb69.js"><link rel="prefetch" href="/assets/js/121.fdcc81f6.js"><link rel="prefetch" href="/assets/js/122.ae33a331.js"><link rel="prefetch" href="/assets/js/123.a9bd9f52.js"><link rel="prefetch" href="/assets/js/124.78f87940.js"><link rel="prefetch" href="/assets/js/125.d0471739.js"><link rel="prefetch" href="/assets/js/126.8c2dfe44.js"><link rel="prefetch" href="/assets/js/127.83125c07.js"><link rel="prefetch" href="/assets/js/128.a8f0e48e.js"><link rel="prefetch" href="/assets/js/129.7b5b9196.js"><link rel="prefetch" href="/assets/js/13.73c0cfc3.js"><link rel="prefetch" href="/assets/js/130.123af649.js"><link rel="prefetch" href="/assets/js/131.41eadabb.js"><link rel="prefetch" href="/assets/js/132.796f7659.js"><link rel="prefetch" href="/assets/js/133.034f6046.js"><link rel="prefetch" href="/assets/js/134.9b3fdf59.js"><link rel="prefetch" href="/assets/js/135.3d0dc0de.js"><link rel="prefetch" href="/assets/js/136.ac1fe088.js"><link rel="prefetch" href="/assets/js/137.841fced8.js"><link rel="prefetch" href="/assets/js/138.2cafc925.js"><link rel="prefetch" href="/assets/js/139.157715d1.js"><link rel="prefetch" href="/assets/js/14.b1ea70cc.js"><link rel="prefetch" href="/assets/js/140.97637155.js"><link rel="prefetch" href="/assets/js/141.c799e59b.js"><link rel="prefetch" href="/assets/js/142.f2e42687.js"><link rel="prefetch" href="/assets/js/143.6bfc4565.js"><link rel="prefetch" href="/assets/js/144.fdbc779a.js"><link rel="prefetch" href="/assets/js/145.50280836.js"><link rel="prefetch" href="/assets/js/146.fc7fcd51.js"><link rel="prefetch" href="/assets/js/147.4b41329d.js"><link rel="prefetch" href="/assets/js/148.4cc7e38b.js"><link rel="prefetch" href="/assets/js/149.fc78a036.js"><link rel="prefetch" href="/assets/js/15.56696330.js"><link rel="prefetch" href="/assets/js/150.9222b0a8.js"><link rel="prefetch" href="/assets/js/151.f2e8b8ad.js"><link rel="prefetch" href="/assets/js/152.eb95f828.js"><link rel="prefetch" href="/assets/js/153.18c8c80a.js"><link rel="prefetch" href="/assets/js/154.6f570152.js"><link rel="prefetch" href="/assets/js/155.f2c6932f.js"><link rel="prefetch" href="/assets/js/156.7289ee7d.js"><link rel="prefetch" href="/assets/js/157.b20fb3b2.js"><link rel="prefetch" href="/assets/js/158.9142b326.js"><link rel="prefetch" href="/assets/js/159.c2556d56.js"><link rel="prefetch" href="/assets/js/16.e41b6458.js"><link rel="prefetch" href="/assets/js/160.3cbb2abe.js"><link rel="prefetch" href="/assets/js/161.644479cf.js"><link rel="prefetch" href="/assets/js/162.f7f5b86b.js"><link rel="prefetch" href="/assets/js/163.50b2d163.js"><link rel="prefetch" href="/assets/js/164.3ddae080.js"><link rel="prefetch" href="/assets/js/165.858cc7ab.js"><link rel="prefetch" href="/assets/js/166.c309aa14.js"><link rel="prefetch" href="/assets/js/167.c5fb1da2.js"><link rel="prefetch" href="/assets/js/168.ee57e5a7.js"><link rel="prefetch" href="/assets/js/169.68ca8fa4.js"><link rel="prefetch" href="/assets/js/17.71047dc5.js"><link rel="prefetch" href="/assets/js/170.3792fa19.js"><link rel="prefetch" href="/assets/js/171.bbc53d66.js"><link rel="prefetch" href="/assets/js/172.59213a0e.js"><link rel="prefetch" href="/assets/js/173.3293c44b.js"><link rel="prefetch" href="/assets/js/174.46a07dd4.js"><link rel="prefetch" href="/assets/js/175.c207cb4e.js"><link rel="prefetch" href="/assets/js/176.1cec087b.js"><link rel="prefetch" href="/assets/js/177.809086db.js"><link rel="prefetch" href="/assets/js/178.2fbd1a03.js"><link rel="prefetch" href="/assets/js/179.852c342f.js"><link rel="prefetch" href="/assets/js/18.ceeba1e8.js"><link rel="prefetch" href="/assets/js/180.ab36a298.js"><link rel="prefetch" href="/assets/js/181.ac1de743.js"><link rel="prefetch" href="/assets/js/182.81046a91.js"><link rel="prefetch" href="/assets/js/183.9b950e44.js"><link rel="prefetch" href="/assets/js/184.33f9700a.js"><link rel="prefetch" href="/assets/js/185.e95b69e1.js"><link rel="prefetch" href="/assets/js/186.4f7fa32c.js"><link rel="prefetch" href="/assets/js/187.bca0b033.js"><link rel="prefetch" href="/assets/js/188.12c9e5a0.js"><link rel="prefetch" href="/assets/js/189.82387bcd.js"><link rel="prefetch" href="/assets/js/19.c3a0caea.js"><link rel="prefetch" href="/assets/js/190.4356c96a.js"><link rel="prefetch" href="/assets/js/191.4280de01.js"><link rel="prefetch" href="/assets/js/192.87423512.js"><link rel="prefetch" href="/assets/js/193.5d266d3b.js"><link rel="prefetch" href="/assets/js/194.b5e70d28.js"><link rel="prefetch" href="/assets/js/195.2cb299e9.js"><link rel="prefetch" href="/assets/js/196.8f281b36.js"><link rel="prefetch" href="/assets/js/197.ce1bbede.js"><link rel="prefetch" href="/assets/js/198.e3eb12e0.js"><link rel="prefetch" href="/assets/js/199.ca09b6fd.js"><link rel="prefetch" href="/assets/js/20.b5f5c5d6.js"><link rel="prefetch" href="/assets/js/200.329a7708.js"><link rel="prefetch" href="/assets/js/201.7f0f8d8e.js"><link rel="prefetch" href="/assets/js/202.4d0f3b31.js"><link rel="prefetch" href="/assets/js/203.e669a888.js"><link rel="prefetch" href="/assets/js/204.5c9c4ca1.js"><link rel="prefetch" href="/assets/js/205.01fd1a41.js"><link rel="prefetch" href="/assets/js/206.8fca0275.js"><link rel="prefetch" href="/assets/js/207.c3914079.js"><link rel="prefetch" href="/assets/js/209.1b23525d.js"><link rel="prefetch" href="/assets/js/21.995379f8.js"><link rel="prefetch" href="/assets/js/210.c4e9cf1f.js"><link rel="prefetch" href="/assets/js/211.d158aea9.js"><link rel="prefetch" href="/assets/js/212.011620f2.js"><link rel="prefetch" href="/assets/js/213.14e7f34e.js"><link rel="prefetch" href="/assets/js/214.daf9c2e3.js"><link rel="prefetch" href="/assets/js/215.604a3098.js"><link rel="prefetch" href="/assets/js/216.40142fd4.js"><link rel="prefetch" href="/assets/js/217.e368b0f3.js"><link rel="prefetch" href="/assets/js/218.729410be.js"><link rel="prefetch" href="/assets/js/219.2c0da493.js"><link rel="prefetch" href="/assets/js/22.83f3fa56.js"><link rel="prefetch" href="/assets/js/220.0aa73c31.js"><link rel="prefetch" href="/assets/js/221.7636d856.js"><link rel="prefetch" href="/assets/js/222.11f59229.js"><link rel="prefetch" href="/assets/js/223.f09f1163.js"><link rel="prefetch" href="/assets/js/224.359c3f9c.js"><link rel="prefetch" href="/assets/js/225.87bd5d17.js"><link rel="prefetch" href="/assets/js/226.94249b84.js"><link rel="prefetch" href="/assets/js/227.efcdbe7b.js"><link rel="prefetch" href="/assets/js/228.3a1064e3.js"><link rel="prefetch" href="/assets/js/229.29b7c020.js"><link rel="prefetch" href="/assets/js/23.b8d98557.js"><link rel="prefetch" href="/assets/js/230.2e582baa.js"><link rel="prefetch" href="/assets/js/231.5c0b4022.js"><link rel="prefetch" href="/assets/js/232.cb2be314.js"><link rel="prefetch" href="/assets/js/233.9407bcd3.js"><link rel="prefetch" href="/assets/js/234.13bc015b.js"><link rel="prefetch" href="/assets/js/235.1993108d.js"><link rel="prefetch" href="/assets/js/236.48b64840.js"><link rel="prefetch" href="/assets/js/237.9db732a0.js"><link rel="prefetch" href="/assets/js/238.c8ec468a.js"><link rel="prefetch" href="/assets/js/239.ea8f1024.js"><link rel="prefetch" href="/assets/js/24.c9557baf.js"><link rel="prefetch" href="/assets/js/240.21023b0a.js"><link rel="prefetch" href="/assets/js/241.eaf72f7a.js"><link rel="prefetch" href="/assets/js/242.fe9052ef.js"><link rel="prefetch" href="/assets/js/243.15c63421.js"><link rel="prefetch" href="/assets/js/244.75640d1d.js"><link rel="prefetch" href="/assets/js/245.085056db.js"><link rel="prefetch" href="/assets/js/246.24e3ea22.js"><link rel="prefetch" href="/assets/js/247.1a0da568.js"><link rel="prefetch" href="/assets/js/248.7827a986.js"><link rel="prefetch" href="/assets/js/249.ecf3746f.js"><link rel="prefetch" href="/assets/js/25.6c36e58b.js"><link rel="prefetch" href="/assets/js/250.5c543ccb.js"><link rel="prefetch" href="/assets/js/251.39428e72.js"><link rel="prefetch" href="/assets/js/252.99dcad55.js"><link rel="prefetch" href="/assets/js/253.e2776208.js"><link rel="prefetch" href="/assets/js/254.4f9db5ea.js"><link rel="prefetch" href="/assets/js/255.7d6600aa.js"><link rel="prefetch" href="/assets/js/256.7eff20ad.js"><link rel="prefetch" href="/assets/js/257.a9741b57.js"><link rel="prefetch" href="/assets/js/258.0bcb6a3c.js"><link rel="prefetch" href="/assets/js/259.d3e2adc1.js"><link rel="prefetch" href="/assets/js/26.75049490.js"><link rel="prefetch" href="/assets/js/260.632d38a8.js"><link rel="prefetch" href="/assets/js/261.7a58a942.js"><link rel="prefetch" href="/assets/js/262.e77b9232.js"><link rel="prefetch" href="/assets/js/263.8ceb0da7.js"><link rel="prefetch" href="/assets/js/264.60a941e6.js"><link rel="prefetch" href="/assets/js/265.05d61e5c.js"><link rel="prefetch" href="/assets/js/266.4945fd71.js"><link rel="prefetch" href="/assets/js/267.055519d0.js"><link rel="prefetch" href="/assets/js/268.ed79f890.js"><link rel="prefetch" href="/assets/js/269.4419b8bc.js"><link rel="prefetch" href="/assets/js/27.c0d6145e.js"><link rel="prefetch" href="/assets/js/270.3acb8737.js"><link rel="prefetch" href="/assets/js/271.56f0c4e4.js"><link rel="prefetch" href="/assets/js/272.19503924.js"><link rel="prefetch" href="/assets/js/273.611f6acc.js"><link rel="prefetch" href="/assets/js/274.e244abc3.js"><link rel="prefetch" href="/assets/js/275.27090757.js"><link rel="prefetch" href="/assets/js/276.e9b04d00.js"><link rel="prefetch" href="/assets/js/277.d49f9220.js"><link rel="prefetch" href="/assets/js/278.f7ef90ba.js"><link rel="prefetch" href="/assets/js/279.caf19bc8.js"><link rel="prefetch" href="/assets/js/28.b85852d1.js"><link rel="prefetch" href="/assets/js/280.d2fcde8a.js"><link rel="prefetch" href="/assets/js/281.410677ab.js"><link rel="prefetch" href="/assets/js/282.4a505a82.js"><link rel="prefetch" href="/assets/js/283.dbc6276e.js"><link rel="prefetch" href="/assets/js/284.dfa76c9a.js"><link rel="prefetch" href="/assets/js/285.62dbdc53.js"><link rel="prefetch" href="/assets/js/286.715bd366.js"><link rel="prefetch" href="/assets/js/287.e0937fb0.js"><link rel="prefetch" href="/assets/js/288.6d29aa07.js"><link rel="prefetch" href="/assets/js/289.468e827c.js"><link rel="prefetch" href="/assets/js/29.957ccaaf.js"><link rel="prefetch" href="/assets/js/30.1018cb9a.js"><link rel="prefetch" href="/assets/js/31.2302d1fc.js"><link rel="prefetch" href="/assets/js/32.b4175245.js"><link rel="prefetch" href="/assets/js/33.69e03757.js"><link rel="prefetch" href="/assets/js/34.73e56aa6.js"><link rel="prefetch" href="/assets/js/35.fb5f8a10.js"><link rel="prefetch" href="/assets/js/36.6040feee.js"><link rel="prefetch" href="/assets/js/37.3b1055c2.js"><link rel="prefetch" href="/assets/js/38.ad152872.js"><link rel="prefetch" href="/assets/js/39.250a000e.js"><link rel="prefetch" href="/assets/js/4.1c073091.js"><link rel="prefetch" href="/assets/js/40.182e5cf3.js"><link rel="prefetch" href="/assets/js/41.6cbb6fe4.js"><link rel="prefetch" href="/assets/js/42.3a02833e.js"><link rel="prefetch" href="/assets/js/43.2989f248.js"><link rel="prefetch" href="/assets/js/44.540aa1a7.js"><link rel="prefetch" href="/assets/js/45.4bd7aa29.js"><link rel="prefetch" href="/assets/js/46.8c9c27a6.js"><link rel="prefetch" href="/assets/js/47.906fc9ef.js"><link rel="prefetch" href="/assets/js/48.0c403c1a.js"><link rel="prefetch" href="/assets/js/49.7f042c16.js"><link rel="prefetch" href="/assets/js/5.162e5946.js"><link rel="prefetch" href="/assets/js/50.1510b5df.js"><link rel="prefetch" href="/assets/js/51.4c7fcce4.js"><link rel="prefetch" href="/assets/js/52.1ac6baba.js"><link rel="prefetch" href="/assets/js/53.f3ddc671.js"><link rel="prefetch" href="/assets/js/54.ad695959.js"><link rel="prefetch" href="/assets/js/55.3d2a5aa1.js"><link rel="prefetch" href="/assets/js/56.d8280282.js"><link rel="prefetch" href="/assets/js/57.23e3abce.js"><link rel="prefetch" href="/assets/js/58.5e61b5a2.js"><link rel="prefetch" href="/assets/js/59.37195f35.js"><link rel="prefetch" href="/assets/js/6.5c747ca5.js"><link rel="prefetch" href="/assets/js/60.15fa1333.js"><link rel="prefetch" href="/assets/js/61.06acfdab.js"><link rel="prefetch" href="/assets/js/62.db92d627.js"><link rel="prefetch" href="/assets/js/63.6673e5af.js"><link rel="prefetch" href="/assets/js/64.f5a45dc9.js"><link rel="prefetch" href="/assets/js/65.6a2e2e19.js"><link rel="prefetch" href="/assets/js/66.5246c16e.js"><link rel="prefetch" href="/assets/js/67.860ef245.js"><link rel="prefetch" href="/assets/js/68.84a0fdc5.js"><link rel="prefetch" href="/assets/js/69.8eedcfa4.js"><link rel="prefetch" href="/assets/js/7.66fedf66.js"><link rel="prefetch" href="/assets/js/70.9393ee09.js"><link rel="prefetch" href="/assets/js/71.062b6767.js"><link rel="prefetch" href="/assets/js/72.3dd00747.js"><link rel="prefetch" href="/assets/js/73.471092af.js"><link rel="prefetch" href="/assets/js/74.58c90c0f.js"><link rel="prefetch" href="/assets/js/75.f098ada7.js"><link rel="prefetch" href="/assets/js/76.2673621c.js"><link rel="prefetch" href="/assets/js/77.16047bbf.js"><link rel="prefetch" href="/assets/js/78.3cc656ae.js"><link rel="prefetch" href="/assets/js/79.31b85b41.js"><link rel="prefetch" href="/assets/js/8.9eeaea9f.js"><link rel="prefetch" href="/assets/js/80.0ceaab33.js"><link rel="prefetch" href="/assets/js/81.e78ca45b.js"><link rel="prefetch" href="/assets/js/82.543c1951.js"><link rel="prefetch" href="/assets/js/83.096ca953.js"><link rel="prefetch" href="/assets/js/84.b5fd2be3.js"><link rel="prefetch" href="/assets/js/85.f115a83b.js"><link rel="prefetch" href="/assets/js/86.0b3bbb1b.js"><link rel="prefetch" href="/assets/js/87.56c7069a.js"><link rel="prefetch" href="/assets/js/88.a04c1b66.js"><link rel="prefetch" href="/assets/js/89.e9f54a72.js"><link rel="prefetch" href="/assets/js/9.52d49724.js"><link rel="prefetch" href="/assets/js/90.b48791b4.js"><link rel="prefetch" href="/assets/js/91.0433039a.js"><link rel="prefetch" href="/assets/js/92.d0963eac.js"><link rel="prefetch" href="/assets/js/93.08534bac.js"><link rel="prefetch" href="/assets/js/94.241c0409.js"><link rel="prefetch" href="/assets/js/95.5f755a2b.js"><link rel="prefetch" href="/assets/js/96.c09abd5e.js"><link rel="prefetch" href="/assets/js/97.d95c5508.js"><link rel="prefetch" href="/assets/js/98.1c9b4232.js"><link rel="prefetch" href="/assets/js/99.3ccebc91.js">
    <link rel="stylesheet" href="/assets/css/0.styles.23dd1510.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">小武子知识库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/js/" class="nav-link router-link-active">
  javascript
</a></div><div class="nav-item"><a href="/css/" class="nav-link">
  css
</a></div><div class="nav-item"><a href="/html5/" class="nav-link">
  HTML5
</a></div><div class="nav-item"><a href="/tool/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  软件工程
</a></div><div class="nav-item"><a href="/cs/" class="nav-link">
  计算机基础
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/materials/" class="nav-link">
  资料收集
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于作者
</a></div><div class="nav-item"><a href="https://www.github.com/fttony" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/js/" class="nav-link router-link-active">
  javascript
</a></div><div class="nav-item"><a href="/css/" class="nav-link">
  css
</a></div><div class="nav-item"><a href="/html5/" class="nav-link">
  HTML5
</a></div><div class="nav-item"><a href="/tool/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  软件工程
</a></div><div class="nav-item"><a href="/cs/" class="nav-link">
  计算机基础
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/materials/" class="nav-link">
  资料收集
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于作者
</a></div><div class="nav-item"><a href="https://www.github.com/fttony" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>javascript基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/es5-expression.html" class="sidebar-link">表达式与运算符</a></li><li><a href="/js/es5-type.html" class="sidebar-link">JS 数据类型与数据类型转换</a></li><li><a href="/js/es5-prototype.html" class="sidebar-link">原型与原型链</a></li><li><a href="/js/es5-this.html" class="sidebar-link">this 解析</a></li><li><a href="/js/es5-closure.html" class="sidebar-link">闭包</a></li><li><a href="/js/es5-apply-call-bind.html" class="sidebar-link">apply&amp;bind&amp;call</a></li><li><a href="/js/es5-dom.html" class="sidebar-link">DOM与BOM</a></li><li><a href="/js/es5-event.html" class="sidebar-link">JS事件</a></li><li><a href="/js/es5-execution-context.html" class="sidebar-link">执行上下文与执行上下文栈</a></li><li><a href="/js/es5-extends.html" class="sidebar-link">继承</a></li><li><a href="/js/es5-fn.html" class="sidebar-link">函数</a></li><li><a href="/js/es5-news.html" class="sidebar-link">new 理解</a></li><li><a href="/js/es5-array.html" class="sidebar-link">数组</a></li><li><a href="/js/es5-object.html" class="sidebar-link">对象</a></li><li><a href="/js/es5-reg.html" class="sidebar-link">正则表达式学习</a></li><li><a href="/js/es5-scope.html" class="sidebar-link">作用域</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>javascript进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/js-clone.html" class="sidebar-link">JS的浅拷贝与深拷贝</a></li><li><a href="/js/js-curry.html" class="sidebar-link">函数柯理化</a></li><li><a href="/js/js-debounce.html" class="sidebar-link">节流与防抖动</a></li><li><a href="/js/js-precision.html" class="sidebar-link">js 精度丢失问题</a></li><li><a href="/js/js-memory.html" class="sidebar-link">js 内存管理</a></li><li><a href="/js/js-memory-1.html" class="sidebar-link">JS 内存泄漏、监控和分析</a></li><li><a href="/js/js-async.html" class="sidebar-link">事件循环和异步编程的崛起</a></li><li><a href="/js/js-bit.html" class="sidebar-link">js 位运算</a></li><li><a href="/js/js-eventloop.html" class="sidebar-link">理解 EventLoop</a></li><li><a href="/js/js-module.html" class="sidebar-link">js 模块化</a></li><li><a href="/js/js-run.html" class="sidebar-link">javascript 执行过程</a></li><li><a href="/js/js-ast.html" class="sidebar-link">解析、抽象语法树（AST）+ 提升编译速度 5 个技巧</a></li><li><a href="/js/js-v8.html" class="sidebar-link">V8 简介</a></li><li><a href="/js/js-principle.html" class="sidebar-link">JS 编译器，解释引擎</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>es6</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/es6-array.html" class="sidebar-link">数组扩展</a></li><li><a href="/js/es6-fn.html" class="sidebar-link">函数扩展</a></li><li><a href="/js/es6-class-1.html" class="sidebar-link">Class 基本用法</a></li><li><a href="/js/es6-class-2.html" class="sidebar-link">Class 继承</a></li><li><a href="/js/es6-async.html" class="sidebar-link">async 函数</a></li><li><a href="/js/es6-generator-1.html" class="sidebar-link">Generator 函数的语法</a></li><li><a href="/js/es6-generator-2.html" class="sidebar-link">Generator 函数的异步应用</a></li><li><a href="/js/es6-iterator.html" class="sidebar-link">Iterator 和 for...of 循环</a></li><li><a href="/js/es6-let-const.html" class="sidebar-link">let 与 const</a></li><li><a href="/js/es6-module.html" class="sidebar-link">Module 对象</a></li><li><a href="/js/es6-number.html" class="sidebar-link">数值扩展</a></li><li><a href="/js/es6-object.html" class="sidebar-link">对象扩展</a></li><li><a href="/js/es6-promise.html" class="sidebar-link">Promise 对象</a></li><li><a href="/js/es6-proxy-reflect.html" class="sidebar-link">Proxy 和 Reflect</a></li><li><a href="/js/es6-set-map.html" class="sidebar-link">Set和Map数据结构</a></li><li><a href="/js/es6-string.html" class="sidebar-link">字符串扩展</a></li><li><a href="/js/es6-symbol.html" class="sidebar-link">Symbol</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/ts-introduct.html" class="sidebar-link">ts 学习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>nodejs</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/node-introdect.html" class="sidebar-link">node 介绍</a></li><li><a href="/js/node-eventloop.html" class="sidebar-link">Node 的事件循环机制</a></li><li><a href="/js/node-buffer.html" class="sidebar-link">buffer 模块</a></li><li><a href="/js/node-cheerio.html" class="sidebar-link">cheerio 模块</a></li><li><a href="/js/node-cluster.html" class="sidebar-link">cluster 集群</a></li><li><a href="/js/node-egg.html" class="sidebar-link">egg 基础应用</a></li><li><a href="/js/node-events.html" class="sidebar-link">events 模块</a></li><li><a href="/js/node-express.html" class="sidebar-link">express 基础应用</a></li><li><a href="/js/node-fs.html" class="sidebar-link">fs 模块</a></li><li><a href="/js/node-http.html" class="sidebar-link">http 模块</a></li><li><a href="/js/node-rpc.html" class="sidebar-link">RPC 调用</a></li><li><a href="/js/node-koa.html" class="sidebar-link">koa 基础应用</a></li><li><a href="/js/node-koa-code.html" class="sidebar-link">koa 源码分析</a></li><li><a href="/js/node-net.html" class="sidebar-link">net 模块</a></li><li><a href="/js/node-process.html" class="sidebar-link">process 进程</a></li><li><a href="/js/node-querystring.html" class="sidebar-link">querystring 模块</a></li><li><a href="/js/node-stream.html" class="sidebar-link">stream 模块</a></li><li><a href="/js/node-queue.html" class="sidebar-link">node.js 中的消息队列</a></li><li><a href="/js/node-url.html" class="sidebar-link">url 模块</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>vue框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/mvvm.html" class="sidebar-link">mvvm 框架介绍</a></li><li><a href="/js/jquery-code.html" class="sidebar-link">jquery 源码分析</a></li><li><a href="/js/undescore.html" class="sidebar-link">undescore 源码分析</a></li><li><a href="/js/vue-jsx.html" class="sidebar-link">Vue 中使用 JSX</a></li><li><a href="/js/vue-lifecycle.html" class="sidebar-link">Vue 生命周期</a></li><li><a href="/js/vue-dom.html" class="sidebar-link">虚拟 DOM 解析</a></li><li><a href="/js/vue-communication.html" class="sidebar-link">vue 组件通信</a></li><li><a href="/js/vue-bind.html" class="sidebar-link">vue 双向数据绑定原理</a></li><li><a href="/js/vue-nexttick.html" class="sidebar-link">Vue.netTick 理解与分析</a></li><li><a href="/js/vue-watch.html" class="sidebar-link">Vue 中的 computed,watch,methods 理解与分析</a></li><li><a href="/js/vue-router.html" class="sidebar-link">vue-router 学习及原理</a></li><li><a href="/js/vue-router-code.html" class="sidebar-link">vue-router 源码分析</a></li><li><a href="/js/vue-vuex.html" class="sidebar-link">vuex 学习及原理</a></li><li><a href="/js/vue-vuex-code.html" class="sidebar-link">vue-vuex 源码分析</a></li><li><a href="/js/vue-code.html" class="active sidebar-link">vue 源码分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/vue-code.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/js/vue-code.html#内容" class="sidebar-link">内容</a></li><li class="sidebar-sub-header"><a href="/js/vue-code.html#联系作者" class="sidebar-link">联系作者</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-源码分析"><a href="#vue-源码分析" class="header-anchor">#</a> vue 源码分析</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>本人平时学习及收集内容，欢迎参入一起讨论。</p> <h2 id="内容"><a href="#内容" class="header-anchor">#</a> 内容</h2> <ul><li><a href="#%E4%B8%80%E3%80%81%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1">源码目录设计</a></li> <li><a href="#%E4%BA%8C%E3%80%81%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%AF%87">变化侦测篇</a></li> <li><a href="#%E4%B8%89%E3%80%81%E8%99%9A%E6%8B%9F-dom-%E7%AF%87">虚拟 DOM 篇</a></li> <li><a href="#%E5%9B%9B%E3%80%81%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E7%AF%87">模板编译篇</a></li> <li><a href="#%E4%BA%94%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AF%87">生命周期篇</a></li> <li><a href="#%E5%85%AD%E3%80%81%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">实例方法</a></li> <li><a href="#%E4%B8%83%E3%80%81%E5%85%A8%E5%B1%80-api-%E7%AF%87">全局 API 篇</a></li> <li><a href="#%E5%85%AB%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AF%87">过滤器篇</a></li> <li><a href="#%E4%B9%9D%E3%80%81%E6%8C%87%E4%BB%A4%E7%AF%87">指令篇</a></li></ul> <h3 id="一、源码目录设计"><a href="#一、源码目录设计" class="header-anchor">#</a> 一、源码目录设计</h3> <p>Vue.js 的源码都在 src 目录下，其目录结构如下。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>├─dist                   # 项目构建后的文件
├─scripts                # 与项目构建相关的脚本和配置文件
├─flow                   # flow的类型声明文件
├─src                    # 项目源代码
│    ├─complier          # 与模板编译相关的代码
│    ├─core              # 通用的、与运行平台无关的运行时代码
│    │  ├─observe        # 实现变化侦测的代码
│    │  ├─vdom           # 实现virtual dom的代码
│    │  ├─instance       # Vue.js实例的构造函数和原型方法
│    │  ├─global-api     # 全局api的代码
│    │  └─components     # 内置组件的代码
│    ├─server            # 与服务端渲染相关的代码
│    ├─platforms         # 特定运行平台的代码，如weex
│    ├─sfc               # 单文件组件的解析代码
│    └─shared            # 项目公用的工具代码
└─test                   # 项目测试代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>compiler</li> <li>core</li> <li>platform</li> <li>server</li> <li>sfc</li> <li>shared</li></ul> <h4 id="_1-1-compiler"><a href="#_1-1-compiler" class="header-anchor">#</a> 1.1 compiler</h4> <p><code>compiler</code>目录包含<code>Vue.js</code>所有编译相关的代码。它包括把模板解析成 ast 语法树、ast 语法树优化，代码生成等功能。</p> <p>编译的工作可以在构建时做（借助<code>webpack</code>、<code>vue-loader</code>等辅助插件）；也可以在运行时做，使用包含构建功能的<code>vue.js</code>。显然，编译是一项耗性能的工作，所以更推荐前者——离线编译。</p> <h4 id="_1-2-core"><a href="#_1-2-core" class="header-anchor">#</a> 1.2 core</h4> <p><code>core</code>目录包含了<code>Vue.js</code>的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。</p> <p>这里的代码可谓是 Vue.js 的灵魂，也是我们之后需要重点分析的地方</p> <h4 id="_1-3-platform"><a href="#_1-3-platform" class="header-anchor">#</a> 1.3 platform</h4> <p><code>Vue.js</code>是一个跨平台的<code>MVVM</code>框架，它可以跑在<code>web</code>上，也可以配合<code>weex</code>跑在<code>native</code>客户端上。<code>platform</code>是 <code>Vue.js</code>的入口，2 个目录代表 2 个主要入口，分别打包成运行在<code>web</code>上和<code>weex</code>上的<code>Vue.js</code>。</p> <p>我们会重点分析<code>web</code>入口打包后的<code>Vue.js</code>，对于<code>weex</code>入口打包的<code>Vue.js</code>，感兴趣的同学可以自行研究。</p> <h4 id="_1-4-server"><a href="#_1-4-server" class="header-anchor">#</a> 1.4 server</h4> <p><code>Vue.js 2.0</code>支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。注意：这部分代码是跑在服务端的<code>Node.js</code>，不要和跑在浏览器端的<code>Vue.js</code>混为一谈。</p> <p>服务端渲染主要的工作是把组件渲染为服务器端的<code>HTML</code>字符串，将它们直接发送到浏览器，最后将静态标记&quot;混合&quot;为客户端上完全交互的应用程序。</p> <h4 id="_1-5-sfc"><a href="#_1-5-sfc" class="header-anchor">#</a> 1.5 sfc</h4> <p>通常我们开发<code>Vue.js</code>都会借助<code>webpack</code>构建， 然后通过<code>.vue</code>单文件来编写组件。</p> <p>这个目录下的代码逻辑会把<code>.vue</code>文件内容解析成一个<code>JavaScript</code>的对象。</p> <h4 id="_1-6-shared"><a href="#_1-6-shared" class="header-anchor">#</a> 1.6 shared</h4> <p><code>Vue.js</code>会定义一些工具方法，这里定义的工具方法都是会被浏览器端的<code>Vue.js</code>和服务端的<code>Vue.js</code>所共享的。</p> <h3 id="二、变化侦测篇"><a href="#二、变化侦测篇" class="header-anchor">#</a> 二、变化侦测篇</h3> <ul><li>Object 的变化侦测</li> <li>Array 的变化侦测</li> <li>变化侦测的 API 实现</li></ul> <h4 id="_2-1-object-的变化侦测"><a href="#_2-1-object-的变化侦测" class="header-anchor">#</a> 2.1 Object 的变化侦测</h4> <p><strong>使用 Object 数据变得“可观测”</strong></p> <p>数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的“可观测”。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 源码位置：src/core/observer/index.js

/**
 *  Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象
 */
export class Observer {
  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    // 给value新增一个__ob__属性，值为该value的Observer实例
    //
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i &lt; keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }
}


/**
 * 使一个对象转化成可观测对象
 * @param { Object } obj 对象
 * @param { String } key 对象的key
 * @param { Any } val 对象的某个key的值
 */
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property &amp;&amp; property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property &amp;&amp; property.get
  const setter = property &amp;&amp; property.set
  if ((!getter || setter) &amp;&amp; arguments.length === 2) {
    val = obj[key]
  }

    // 递归调用，判断属性值是否是对象
  let childOb = !shallow &amp;&amp; observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter &amp;&amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow &amp;&amp; observe(newVal)
      dep.notify()
    }
  })
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br></div></div><p><strong>什么是依赖收集</strong></p> <p>视图里谁用到了这个数据就更新谁，我们换个优雅说法：我们把“谁用到了这个数据”称为“谁依赖了这个数据”，我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数据中，把每个依赖都通知一遍，告诉他们：“你们依赖的数据变啦，你们该更新啦！”。这个过程就是依赖收集。</p> <p><strong>何时收集依赖？何时通知依赖更新？</strong></p> <p>在 getter 中收集依赖，在 setter 中通知依赖更新。</p> <p><strong>把依赖收集到哪里</strong></p> <p>我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array&lt;Watcher&gt;;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

    // 订阅
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }
    // 通知更新
  notify () {
    // 转化成数组
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) {
      subs.sort((a, b) =&gt; a.id - b.id)
    }
    for (let i = 0, l = subs.length; i &lt; l; i++) {
      subs[i].update()
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>有了依赖管理器后，我们就可以在 getter 中收集依赖，在 setter 中通知依赖更新了，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function defineReactive (obj,key,val){
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property &amp;&amp; property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property &amp;&amp; property.get
  const setter = property &amp;&amp; property.set
  if ((!getter || setter) &amp;&amp; arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow &amp;&amp; observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter &amp;&amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow &amp;&amp; observe(newVal)
      dep.notify()
    }
  })
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><p>在上述代码中，我们在<code>getter</code>中调用了<code>dep.depend()</code>方法收集依赖，在<code>setter</code>中调用<code>dep.notify()</code>方法通知所有依赖更新。</p> <p><strong>依赖到底是谁</strong></p> <p>上面我们明白了什么是依赖？何时收集依赖？以及收集的依赖存放到何处？那么我们收集的依赖到底是谁？</p> <p>其实在<code>Vue</code>中还实现了一个叫做<code>Watcher</code>的类，而<code>Watcher</code>类的实例就是我们上面所说的那个“谁”。换句话说就是：谁用了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例。在之后数据变化时，我们不直接去通知依赖更新，而通知依赖对应的<code>Watch</code>实例，由<code>Watcher</code>实例去通知真正的视图。</p> <p><code>Watcher</code>类的具体实现如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default class Watcher {
  constructor (vm,expOrFn,cb) {
    this.vm = vm;
    this.cb = cb;
    this.getter = parsePath(expOrFn)
    this.value = this.get()
  }
  get () {
    window.target = this;
    const vm = this.vm
    let value = this.getter.call(vm, vm)
    window.target = undefined;
    return value
  }
  update () {
    const oldValue = this.value
    this.value = this.get()
    this.cb.call(this.vm, this.value, oldValue)
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><code>Watcher</code>类的代码实现逻辑：</p> <ol><li>当实例化<code>Watcher</code>类时，会先执行其构造函数；</li> <li>在构造函数中调用了<code>this.get()</code>实例方法；</li> <li>在<code>get()</code>方法中，首先通过<code>window.target = this</code>把实例自身赋给了全局的一个唯一对象<code>window.target</code>上，然后通过<code>let value = this.getter.call(vm,vm)</code>获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>，上文我们说过，在<code>getter</code>里会调用<code>dep.depend()</code>收集依赖，而在<code>dep.depend()</code>中取到挂载<code>window.target</code>上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</li> <li>而当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用了<code>dep.notify()</code>方法，在<code>dep.notify()</code>方法中，遍历所有依赖(即 watcher 实例)，执行依赖的<code>update()</code>方法，也就是<code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code>方法中调用数据变化的更新回调函数，从而更新视图</li></ol> <p>总结一下：<code>Watcher</code>先把自己设置到全局唯一的指定位置(<code>window.target</code>)，然后读取数据。因为读取了数据，所以会触发这个数据的<code>getter</code>。接着，在<code>getter</code>中就会从全局唯一的那个位置读取当前正在读取数据的<code>Watcher</code>，并把这个<code>wather</code>收集到<code>Dep</code>中去。收集好之后，当数据发生变化时，会向<code>Dep</code>中的每个<code>Wather</code>发送通知。通过这样的方式。<code>Wather</code>可以主动去订阅任意一个数据的变化。</p> <p><strong>不足之处</strong></p> <p>虽然我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，但是这个方法仅仅只能观测到<code>object</code>数据的取值及设置值，当我们向<code>object</code>数据里添加一对新的<code>key/value</code>或删除一对已有的<code>key/value</code>时，它是无法观测到的，导致当我们对<code>object</code>数据添加或删除时，无法通知依赖，无法驱动视力进行响应式更新。</p> <p><code>Vue</code>也注意到了这一点，为了解决这一问题，<code>Vue</code>增加了两个全局 API：<code>Vue.set</code>和<code>Vue.delete</code>。</p> <p><strong>总结</strong></p> <p>我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，并且封装了<code>Observer</code>类，让我们能够方便的把<code>object</code>数据中的所有属性（包括子属性）都转换成<code>getter/setter</code>的形式来侦测变化。</p> <p>其整个流程大致如下：</p> <ol><li><code>Data</code>通过<code>observer</code>转换成了<code>getter/setter</code>的形式来追踪变化。</li> <li>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将<code>Watcher</code>添加到依赖中。</li> <li>当数据发生了变化时，会触发<code>setter</code>，从而向<code>Dep</code>'中的依赖（vcb 即 Watcher）发送通知。</li> <li><code>Watcher</code>接收到通知后，会向外界发送能知，变化通知到外界后可能会触发视图更新，也有可能触发某个回调数等。</li></ol> <h4 id="_2-2-array-的变化侦测"><a href="#_2-2-array-的变化侦测" class="header-anchor">#</a> 2.2 Array 的变化侦测</h4> <p>上一节文章中我们介绍了<code>Object</code>数据的变化侦测方式，本节我们来看一下对<code>Array</code>型数据的变化<code>Vue</code>是如何进行侦测的。</p> <p>我们知道，<code>Object.defineProperty</code>监测<code>Object</code>型数据时是给<code>Object</code>型数据的每个<code>key/value</code>添加上了<code>getter</code>和<code>setter</code>，这样，对于<code>Object</code>型数据我们再通过<code>key</code>值取值或设置值时就可以被监测到。</p> <p>数组并不是只能由索引值来操作数组，更常用的操作数组的方法是使用数组原型上的一些方法如<code>push</code>，<code>shift</code>等来操作数组，当使用这些数据原型方法来数组时，<code>Object.defineProperty</code>就监测不到了，所以<code>Vue</code>对<code>Array</code>型数据单独设计了数据监测方式。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    ob.dep.notify()
    return result
  })
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p><strong>数组方法拦截器</strong></p> <p>在<code>Vue</code>中创建了一个数组方法拦截器，它拦截在数组实例与<code>Array.prototype</code>之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用<code>Array.prototype</code>上的原生方法。如下图所示：</p> <p><img src="vue12.png" alt="images"></p> <p>经过整理，<code>Array</code>原型中可以改变数组自身内容的方法有 7 个，分别是：<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>。源码中的拦截器代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 源码位置：/src/core/observer/array.js

const arrayProto = Array.prototype
// 创建一个对象作为拦截器
export const arrayMethods = Object.create(arrayProto)

// 改变数组自身内容的7个方法
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  const original = arrayProto[method]      // 缓存原生方法
  Object.defineProperty(arrayMethods, method, {
    enumerable: false,
    configurable: true,
    writable: true,
    value:function mutator(...args){
      const result = original.apply(this, args)
      return result
    }
  })
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>首先创建了继承自<code>Array</code>原型的空对象<code>arrayMethods</code>，接着在<code>arrayMethods</code>上使用<code>object.defineProperty</code>方法将那些可以改变数组自身的 7 个方法遍历逐个进行封装。最后，当我们使用<code>push</code>方法的时候，其实用的是<code>arrayMethods.push</code>，而<code>arrayMethods.push</code>就是封装的新函数<code>mutator</code>，也就是说，实际上执行的是函数<code>mutator</code>，而<code>mutator</code>函数的内部执行了<code>original</code>函数，这个<code>original</code>函数就是<code>Array.prototype</code>上对应的原生方法。那么，接下我们就可以在<code>mutator</code>函数中做一些其他的事，比如说发送变化通知。</p> <p><strong>使用拦截器</strong></p> <p>我们把撞拦截器做好还不够，还要把它挂载到数组实例与<code>Array.prototype</code>之间，这样拦截器才能够生效。</p> <p>其实挂载不难，我们只需数据的<code>__proto__</code> 属性设置为拦截器<code>arrayMethods</code>即可，源码实现如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 源码位置：/src/core/observer/index.js
export class Observer {
  constructor (value) {
    this.value = value
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }
}
// 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性
export const hasProto = '__proto__' in {}

const arrayKeys = Object.getOwnPropertyNames(arrayMethods)

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src: Object, keys: any) {
  target.__proto__ = src
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) {
  for (let i = 0, l = keys.length; i &lt; l; i++) {
    const key = keys[i]
    def(target, key, src[key])
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><p>上面代码中首先判断了浏览器是否支持<code>__proto__</code>，如果支持，则调用<code>protoAugment</code>函数把<code>value__proto__ = arrayMethods</code>；如果不支持，则调用<code>copyAugment</code>函数把拦截器中重写的 7 个方法循环加入到<code>value</code>上。</p> <p>拦截器生效以后，当数组数据再发生变化时，我们就可以在拦截器中通知变化了，也就是说现在我们就可以知道数组数据何时发生变化了。</p> <p><strong>数组新增元素的侦测</strong></p> <p>如果向数组里新增一个元素的话，我们可以也需要将新增的这个元素转化成可侦测的响应式数据。</p> <p>这个实现起来也很容易，我们只需要拿到新增的这个元素，然后调用<code>observe</code>函数将其转化即可。我们知道，可以向数组内新增元素的方法有 3 个，分别是：<code>push</code>、<code>unshift</code>、<code>splice</code>。我们需对这 3 中方法分别处理，拿到新增的元素，再将其转化即可。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args   // 如果是push或unshift方法，那么传入参数就是新增的元素
        break
      case 'splice':
        inserted = args.slice(2) // 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素
        break
    }
    if (inserted) ob.observeArray(inserted) // 调用observe函数将新增的元素转化成响应式
    // notify change
    ob.dep.notify()
    return result
  })
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>在上面拦截器定义代码中，如果是<code>push</code>或<code>unshift</code>方法，那么传入参数就是新增的元素；如果<code>splice</code>方法，那么传入参数列表中下标为 2 的就是新增的元素，拿到新增的元素后，就可以<code>observe</code>函数将新增的元素转化成响应的了。</p> <p><strong>深度侦测</strong></p> <p>在<code>Vue</code>中，不论是<code>Object</code>型数组据还是<code>Array</code>型数据所实现的数据变化侦测都是深度侦测，所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。举个例子：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let arr = [{
    name:'NLRX',
    age:'18'
}]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>数组中包含了一个对象，如果该对象的某个属性发生了变化也应该被侦测到，这就是深度侦测。</p> <p>对于<code>Array</code>型数据，调用了<code>observeArray()</code>方法，该方法内部会遍历数组中的每一个元素，然后通过调用<code>observe</code>函数将每一个元素都转化成可侦测的响应式数据。</p> <p><strong>不足之处</strong></p> <p>对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let arr = [1,2,3]
arr[0] = 5;       // 通过数组下标修改数组中的数据
arr.length = 0    // 通过修改数组长度清空数组
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>而使用上述鸽子中的操作方式来修改数组是无法侦测到的。同样，<code>Vue</code>也注意到了这个问题，为了解决这一问题，<code>Vue</code>增加了两个全局 API：<code>Vue.set</code>和<code>Vue.delete</code>。</p> <h4 id="_2-3-变化侦测的-api-实现"><a href="#_2-3-变化侦测的-api-实现" class="header-anchor">#</a> 2.3 变化侦测的 API 实现</h4> <ul><li><code>vm.$watch</code></li> <li><code>vm.$set</code></li> <li><code>vm.$delete</code></li></ul> <p><strong><code>vm.$watch</code></strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$watch(expOrFn, callback, [options]);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>参数：
<ul><li><code>{string | Function} expOrFn</code></li> <li><code>{Function | Object} callback</code></li> <li><code>{Object} [options]</code> <ul><li><code>{boolean} deep</code></li> <li><code>{boolean} immediate</code></li></ul></li></ul></li> <li>返回值：<code>{Function} unwatch</code></li> <li>用法：</li></ul> <p>观察<code>Vue</code>实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。</p> <p>注意：在变异（不是替换）对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。<code>Vue</code>不会保留变异之前值的副本。</p> <ul><li>示例：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>//  键路径
vm.$watch(&quot;a.b.c&quot;,function(newVal,oldVal){
    // 做点什么
})

// 函数
vm.$watch(
  function() {
    // 表达式 `this.a + this.b` 每次得出一个不同的结果时
    // 处理函数都会被调用。
    // 这就像监听一个未被定义的计算属性
    return this.a + this.b;
  },
  function(newVal, oldVal) {
    // 做点什么
  }
);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><code>vm.$watch</code>返回一个取消观察函数，用来停止触发回调</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var unwatch = vm.$watch(&quot;a&quot;, cb);
// 之后取消观察
unwatch();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>选项：deep</li></ul> <p>为了发现对象内部值的变化，可以在选项参数中指定<code>deep:true</code>。注意监听数组的变动不需要这么做。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$watch(&quot;someObject&quot;, callback, {
  deep: true
});
vm.someObject.nestedValue = 123;
// callback is fired
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>选项：immediate</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$watch(&quot;a&quot;, callback, {
  immediate: true
});
// 立即以 `a` 的当前值触发回调
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>内部原理</li></ul> <p><code>$watch</code>的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$watch = function (expOrFn,cb,options) {
    const vm: Component = this
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {}
    options.user = true
    const watcher = new Watcher(vm, expOrFn, cb, options)
    if (options.immediate) {
      try {
        cb.call(vm, watcher.value)
      } catch (error) {
        handleError(error, vm, `callback for immediate watcher &quot;${watcher.expression}&quot;`)
      }
    }
    return function unwatchFn () {
      watcher.teardown()
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>在函数内部，首先判断传入的回调函数是否为一个对象，如果传入的回调函数是个对象，那就表明用户是把第二个参数回调函数<code>cb</code>和第三个参数选项<code>options</code>合起来传入的，此时调用<code>createWatcher</code>函数，该函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function createWatcher (vm,expOrFn,handler,options) {
  if (isPlainObject(handler)) {
    options = handler
    handler = handler.handler
  }
  if (typeof handler === 'string') {
    handler = vm[handler]
  }
  return vm.$watch(expOrFn, handler, options)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>该函数内部其实就是从用户合起来传入的对象中把回调函数<code>cb</code>和参数<code>options</code>剥离出来，然后再以常规的方式调用<code>$watch</code>方法并将剥离出来的参数传进去。</p> <p>接着获取到用户传入的<code>options</code>，如果用户没有传入则将其赋值为一个默认空对象，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>options = options || {};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>$watch</code>方法内部会创建一个<code>watcher</code>实例，由于该实例是用户手动调用<code>$watch</code>方法创建而来的，所以给<code>options</code>添加<code>user</code>属性并赋值为<code>true</code>，用于区分用户创建的<code>watcher</code>实例和<code>Vue</code>内部创建的<code>watcher</code>实例，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>options.user = true;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着，传入参数创建一个 watcher 实例，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const watcher = new Watcher(vm, expOrFn, cb, options);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着判断如果用户在选项参数<code>options</code> 中指定的<code>immediate</code> 为<code>true</code>，则立即用被观察数据当前的值触发回调，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (options.immediate) {
  cb.call(vm, watcher.value);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>最后返回一个取消观察函数<code>unwatchFn</code>，用来停止触发回调。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>return function unwatchFn() {
  watcher.teardown();
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个取消观察<code>unwatchFn</code>内部其实是调用了<code>watcher</code>实例的<code>teardown</code>方法，那和我们来看一下这个<code>teardown</code>方法是如何实现的。其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default class Watcher {
  constructor(/* ... */) {
    // ...
    this.deps = [];
  }
  teardown() {
    let i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>创建<code>watcher</code>实例的时候会读取被观察的数据，读取了数据就表示依赖了数据，所以<code>watcher</code>实例就会存在于数据的依赖列表中，同时<code>watcher</code>实例也记录了自己依赖了哪些数据，另外我们还说过，每个数据都有一个自己的依赖管理器<code>dep</code>，<code>watcher</code>实例记录自己依赖了哪些数据其实就是把数据的依赖管理器<code>dep</code>存放在<code>watcher</code>实例的<code>this.deps=[]</code>属性中，当取消观察时即<code>watcher</code>实例不想依赖这些数据了，那么就遍历自己记录的这些数据的依赖管理器，告诉这些数据可以从你们依赖列表中把我删除了。</p> <p><code>traverse</code>函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const seenObjects = new Set();

export function traverse(val: any) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse(val: any, seen: SimpleSet) {
  let i, keys;
  const isA = Array.isArray(val);
  if (
    (!isA &amp;&amp; !isObject(val)) ||
    Object.isFrozen(val) ||
    val instanceof VNode
  ) {
    return;
  }
  if (val.__ob__) {
    const depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) _traverse(val[i], seen);
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) _traverse(val[keys[i]], seen);
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>该函数其实就是个递归遍历的过程，把被观察数据的内部值都递归遍历读取一遍。</p> <p>首先判断传入的<code>val</code>类型，如果它不是<code>Array</code>或<code>Object</code>，再或者已经被冻结，那么直接返回，退出程序。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const isA = Array.isArray(val);
if ((!isA &amp;&amp; !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
  return;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>然后拿到<code>val</code>的<code>dep.id</code>，存入创建好的集合<code>seen</code>中，因为集合相比数据而言它有天然的去重效果，以此来保证存入的<code>dep.id</code>没有重复，不会造成重复收集依赖，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (val.__ob__) {
  const depId = val.__ob__.dep.id;
  if (seen.has(depId)) {
    return;
  }
  seen.add(depId);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>接下来判断如果是数组，则循环数组，将数组中每一项递归调用<code>_traverse</code>；如果是对象，则取出对象所有的<code>key</code>，然后执行读取操作，再递归内部值，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (isA) {
  i = val.length;
  while (i--) _traverse(val[i], seen);
} else {
  keys = Object.keys(val);
  i = keys.length;
  while (i--) _traverse(val[keys[i]], seen);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong><code>vm.$set</code></strong></p> <p><code>vm.$set</code>是全局<code>Vue.set</code>的<strong>别名</strong>，其用法相同。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$set(target, propertyName / index, value);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p>参数：</p> <ul><li><code>{Object | Array} target</code></li></ul></li> <li><p>返回值：设置的值</p></li> <li><p>用法：</p></li> <li><p>内部原理</p></li></ul> <p><code>set</code>方法的定义位于源码的<code>src/core/observer/index.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  if (key in target &amp;&amp; !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob &amp;&amp; ob.vmCount)) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }
  if (!ob) {
    target[key] = val
    return val
  }
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p><strong><code>vm.$delete</code></strong></p> <p><code>vm.$delete</code>是全局<code>Vue.delete</code>的<strong>别名</strong>，其用法相同</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$delete(target, propertyName / index);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数</strong>：</p> <ul><li><code>{Object | Array} target</code></li> <li><code>{string | number} propertyName/index</code></li></ul></li> <li><p><strong>用法</strong>：</p></li> <li><p><strong>内部原理</strong>：</p></li></ul> <p><code>delete</code>方法是用来解决<code>Vue</code>不能检测到属性被删除的限制，该方法的定义位于源码的<code>src/core/observer/index.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function del (target: Array&lt;any&gt; | Object, key: any) {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot delete reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    target.splice(key, 1)
    return
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob &amp;&amp; ob.vmCount)) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    )
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key]
  if (!ob) {
    return
  }
  ob.dep.notify()
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h3 id="三、虚拟-dom-篇"><a href="#三、虚拟-dom-篇" class="header-anchor">#</a> 三、虚拟 DOM 篇</h3> <p>参考<a href="https://km.xiaowuzi.info/js/vue-dom.html" target="_blank" rel="noopener noreferrer">Vue 虚拟 DOM<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="四、模板编译篇"><a href="#四、模板编译篇" class="header-anchor">#</a> 四、模板编译篇</h3> <ul><li>整体运行流程</li> <li>HTML 解析器</li> <li>文本解析器</li> <li>优化阶段</li> <li>代码生成阶段</li></ul> <p>我们知道，在日常开发中，我们把写在<code>&lt;template&gt;&lt;/template&gt;</code>标签中的类似于原生<code>HTML</code>的内容称之为模板。这时你可能会问了，为什么说是“类似于原生<code>HTML</code>的内容”而不是“就是<code>HTML</code>的内容”？因为我们在开发中，在<code>&lt;template&gt;&lt;/template&gt;</code>标签中除了写一些原生<code>HTML</code>的标签，我们还会写一些亦是插值，如或者写一些<code>Vue</code>指令，如<code>v-on</code>、<code>v-if</code>等。而这些东西都是在原生<code>HTML</code>语法中不存在的，不被接受的。但事实上我们确实这么写了，也被正确识别了，页面也正常显示了，这又是为什么呢？</p> <p>这就归功于<code>Vue</code>的模板编译了，<code>Vue</code>会把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理生成渲染函数，也就是<code>render</code>函数，而<code>redner</code>函数会将模板内容生成对应的<code>VNode</code>，而<code>VNode</code>再经过<code>patch</code>过程从而得到将要渲染的视图中的<code>VNode</code>，最后根据<code>VNode</code>创建真实的<code>DOM</code>节点并插入到视图中，最终完成视图的渲染更新。</p> <p>而把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理成渲染函数，也就是<code>render</code>函数的这一段过程称之为模板编译过程。</p> <h4 id="_4-1-整体渲染流程"><a href="#_4-1-整体渲染流程" class="header-anchor">#</a> 4.1 整体渲染流程</h4> <p>所谓渲染流程，就是把用户写的类似原生<code>HTML</code>的模板经过一系列处理最终反应到视图中称之为整个渲染流程。这个流程在上文中其实已经说到了，下面我们以流程图的形式宏观的了解一下，流程图如下：</p> <p><img src="vue-code01.png" alt="images"></p> <p>从图中我们也可以看到，模板编译过程就是把用户写的模板经过一系列处理最终生成<code>render</code>函数的过程。</p> <p>将一堆字符串模板解析成抽象语法树<code>AST</code>后，我们就可以对其进行各种操作处理了，处理完后用处理后的<code>AST</code>来生成<code>render</code>函数。其具体流程可大致分为三个阶段：</p> <ol><li>模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树<code>AST</code>；</li> <li>优化阶段：遍历<code>AST</code>，找出其中的静态节点，并打上标记；</li> <li>代码生成阶段：将<code>AST</code>转换成渲染函数；</li></ol> <p>这三个阶段在源码中分别对应三个模块，下面给出三个模块的源代码在源码中的路径：</p> <ol><li>模板解析段——解析器——源码路径：<code>src/compiler/parser/index.js</code></li> <li>优化阶段——优化器——源码路径：<code>src/compiler/optimizer.js</code></li> <li>代码生成阶段——代码生成器——源码路径：<code>src/compiler/codegen/index.js</code></li></ol> <p>其对应的源码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 源码位置：/src/complier/index.js

export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>可以看到<code>baseCompile</code>的代码非常的简短主要核心代码。</p> <ul><li><strong>const ast = parse(template.trim(),options)</strong>：<code>parse</code>会用与此同时等方式解析<code>template</code>模板中的指令、<code>class</code>、<code>style</code>等数据，形成<code>AST</code>。</li> <li><strong>optimize(ast,options)</strong>：<code>optimize</code>的主要作用是标记静态节点，这是<code>Vue</code>在编译过程中的一处优化，档在进行<code>patch</code>的过程中，<code>DOM-Diff</code>算法会直接跳过静态节点，从而减少了比较的过程，优化了<code>patch</code>的性能。</li> <li><strong>const code = generate(ast,options)</strong>：将<code>AST</code>转化成<code>render</code>函数字符串的过程，得到结果是<code>render</code>函数的字符串以及<code>staticRenderFns</code>字符串。</li></ul> <p>最终<code>baseCompile</code>的返回值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    ast:ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>最终返回了抽象语法树(ast)，渲染函数(render)，静态渲染函数(staticRenderFns)，且<code>render</code>的值为<code>code.render</code>，<code>staticRendreFns</code>的值为<code>code.staticRenderFns</code>，也就是说通过<code>generate</code>处理<code>ast</code>之后得到的返回值<code>code</code>是一个对象。</p> <p>流程图如下：</p> <p><img src="vue13.png" alt="images"></p> <h4 id="_4-2-整体运行流程"><a href="#_4-2-整体运行流程" class="header-anchor">#</a> 4.2 整体运行流程</h4> <p>在模板解析阶段主要做的工作是把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签内写的模板使用正则等方式解析成抽象语法树（<code>AST</code>）。而这一阶段在源码中对应解析器（<code>parser</code>）模块。</p> <p>解析器，顾名思义，就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成<code>AST</code>。我们知道在<code>&lt;template&gt;&lt;/template&gt;</code>模板内，除了有常规的<code>HTML</code>标签外，用户还会一些文本信息以及在文本信息中包含过滤器。而这些不同的内容在解析起来肯定需要不同的解析规则，所以解析器不可能只有一个，它应该除了有解析常规<code>HTML</code>的 HTML 解析器，还应该有解析文本的文本解析器以及解析文本如果包含过滤器的过滤器解析器。</p> <p>文本信息和标签属性信息却又是存在于 HTML 标签之内的，所以在解析整个模板的时候它的流程应该是这样子的</p> <p><strong>回到源码</strong></p> <p>解析器的源码位于<code>/src/complier/parser</code>文件夹下，其主线代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 代码位置：/src/complier/parser/index.js


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>总结</strong></p> <p>模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为 HTML 解析器，文本解析器和过滤器解析器。而文本信息与过滤器信息又存在于 HTML 标签中，所以在解析器主线函数<code>parse</code>中先调用 HTML 解析器<code>parseHTML</code>函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析。</p> <h4 id="_4-3-html-解析器"><a href="#_4-3-html-解析器" class="header-anchor">#</a> 4.3 HTML 解析器</h4> <p><strong>HTML 解析器内部运行流程</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//  代码位置：/src/complier/parser/index.js

/**
 *  Convert HTML string to AST.
 *  将HTML模板字符串转化为AST
 */
export function parse(template,options){
    // ...
    parseHTML(template,{
        warn,
        expectHTML: options.expectHTML,
        isUnaryTag: options.isUnaryTag,
        canBeLeftOpenTag: options.canBeLeftOpenTag,
        shouldDecodeNewlines: options.shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
        shouldKeepComment: options.comments,
        // 当解析到开始标签时，调用该函数
        start(tag,attrs,unary){

        },
        // 当解析到结束标签时，调用该函数
        end(){

        },
        // 当解析到文本时，调用该函数
        chars(text){

        },
        // 当解析到注释时，调用该函数
        comment(text){

        }
    })
    return root
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>从代码中我们可以看到，调用<code>parseHTML</code>函数时为其传入的两个参数分别是：</p> <ul><li>template 待转换的模板字符串；</li> <li>options 转换时所需的选项；</li></ul> <p>第一个参数是待转换的模板字符串，无需多言；重点看第二个参数，第二个参数提供了</p> <ul><li>当解析到开始标签时调用<code>start</code>函数生成元素类型的<code>AST</code>节点，代码如下；</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 当解析到标签的开始位置时，触发start
start (tag, attrs, unary, start, end) {
    let element = crateASTElement(tag,atrrs,currentParent)
}

export function crateASTElement(tag,attrs,parent){
    return {
        type: 1,
        tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        rawAttrsMap: {},
        parent,
        children: []
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>从上面代码中我们可以看到，<code>start</code>函数接收五个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>、开始<code>start</code>、结束<code>end</code>。当调用该钩子函数时，内部会调用<code>createASTElement</code>函数来创建元素类型的<code>AST</code>节点</p> <ul><li>当解析到结束标签时调用<code>end</code>函数；</li> <li>当解析到文本调用<code>chars</code>函数生成文本类型的<code>AST</code>节点；</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>chars (text, start, end) {
      if (!currentParent) {
        if (process.env.NODE_ENV !== 'production') {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.',
              { start }
            )
          } else if ((text = text.trim())) {
            warnOnce(
              `text &quot;${text}&quot; outside root element will be ignored.`,
              { start }
            )
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &amp;&amp;
        currentParent.tag === 'textarea' &amp;&amp;
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      const children = currentParent.children
      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text)
      } else if (!children.length) {
        text = ''
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          text = lineBreakRE.test(text) ? '' : ' '
        } else {
          text = ' '
        }
      } else {
        text = preserveWhitespace ? ' ' : ''
      }
      if (text) {
        if (!inPre &amp;&amp; whitespaceOption === 'condense') {
          text = text.replace(whitespaceRE, ' ')
        }
        let res
        let child: ?ASTNode
        if (!inVPre &amp;&amp; text !== ' ' &amp;&amp; (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text
          }
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text
          }
        }
        if (child) {
          if (process.env.NODE_ENV !== 'production' &amp;&amp; options.outputSourceRange) {
            child.start = start
            child.end = end
          }
          children.push(child)
        }
      }
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br></div></div><p>当解析到标签的文本时，触发<code>charts</code>钩子函数，在该钩子函数内部，首先会判断文本是不是一个带变量的动态文本，如“hello”。如果是动态文本，则创建动态文本类型的<code>AST</code>节点；如果不是动态文本，则创建纯静态文本类型的<code>AST</code>节点。</p> <ul><li>当解析到注释时调用<code>comment</code>函数生成注释类型的<code>AST</code>节点；</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 当解析到标签的注释时，触发comment
comment (text: string) {
  let element = {
    type: 3,
    text,
    isComment: true
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>当解析到标签的注释时，触发<code>comment</code>钩子函数，该钩子函数会创建一个注释类型的<code>AST</code>节点。</p> <p>一边解析不同的内容一边调用对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>，这就是<code>HTML</code>解析器所要做的工作。</p> <p><strong>如何解析不同的内容</strong></p> <p>要从模板字符串中解析出不同的内容，那</p> <ul><li>文本，例如“难凉热血”</li> <li>HTML 注释，例如<code>&lt;!--我是注释--&gt;</code></li> <li>条件注释，例如<code>&lt;!--[if !IE] --&gt;我是注释&lt;![endif]--&gt;</code></li> <li>DOCTYPE，例如<code>&lt;!DOCTYPE html&gt;</code></li> <li>开始标签，例如<code>&lt;div&gt;</code></li> <li>结束标签，例如<code>&lt;/div&gt;</code></li></ul> <p>这几种内容都有其各自独有的特点，也就是说我们要根据不同内容所具有的不同的特点通过编写不同的表达式将这些内容从模板字符串中一一解析出来，然后再把不同的内容做不同的处理。</p> <p><strong>解析 HTML 注释</strong></p> <p>解析注释比较简单，我们知道<code>HTML</code>注释是以<code>&lt;!--</code>开头，以<code>--&gt;</code>结尾，这两者中间的内容，那么我们只需用正则判断</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const comment = /^&lt;!\--/
if(comment.test(html)){
    // 若为注释，则继续查找是否存在'--&gt;'
    const commentEnd = html.indexOf('--&gt;')

    if(commentEnd &gt;= 0){
        // 若存在 '--&gt;'，继续判断options中是否保留注释
        if(options.shouldKeepComment){
            // 若保留注释，则把注释截取出来给options.comment，创建溈类型的AST节点
            options.comment(html,substring(4,commentEnd) index, index + commentEnd + 3)
        }
        // 若不保留注释，则将游标移动到'--&gt;'之后，继续向后解析
        advance(commentEnd+3)
        continue
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在上面代码中，如果模板字符串<code>html</code>符合注释开始的正则，那么就继续向后查找是否存在<code>--&gt;</code>，若存在，则把<code>html</code>从第 4 位（<code>&quot;&lt;!--&quot;</code>长度为 4）开始截取，直到<code>--&gt;</code>处，截取得到的内容就是注释的真实内容，然后调用 4 个钩子函数中的<code>comment</code>函数，将真实的注释内容传进去，创建溈类型的<code>AST</code>节点。</p> <p>上面代码中有一处值得注意的地方，那就是我们平常在模板中可以在<code>&lt;template&gt;&lt;/template&gt;</code>标签上配置<code>comments</code></p> <p><code>advance</code>函数是用来移动解析游标的，解析完一部分就把游标向后移动一部分，确保不会重复解析，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function advance(n){
    index +=n       // index为解析游标
    html = html.substring(n)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>解析条件注释</strong></p> <p>解析条件注释也比较简单，其原理跟解析注释相同，都是先用与正则判断是否是以条件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 解析是否是条件注释
const conditionalComment = /^&lt;!\[/
if(conditionalComment.test(html)){
    // 若为条件注释，则继续查找是否存在']&gt;'
    const conditionalEnd = html.indexOf(']&gt;')

    if(conditionalEnd &gt;=0){
        // 若存在  ']&gt;',则从原本的html字符串中把条件注释裁掉
        // 把剩下的内容重新赋给html，继续向后匹配
        advance(conditionalEnd+2)
        continue
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>解析 DOCTYPE</strong></p> <p>解析<code>DOCTYPE</code>的原理同解析条件注释完全相同，此处不再赘述，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const doctype = /^&lt;!DOCTYPE [^&gt;]+&gt;/i
// 解析是否是DOCTYPE
const doctypeMatch  = html.match(doctype)
if (doctypeMatch) {
  advance(doctypeMatch[0].length)
  continue
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>解析开始标签</strong></p> <p>相较于前三种内容的解析，解析开始标签会稍微复杂一点，但是万变不离其宗，它的原理还是想通的，都是使用正则去匹配提取。</p> <p>首先使用开始标签的正则去匹配模板字符串，看模板字符串是否具有开始标签的特征，如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/**
 *  匹配开始标签的正则
 */
const ncname = '[a-zA-Z_][\\w\\-\\.]*';
const qnameCapture = ``;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>解析结束标签</strong></p> <p>结束标签的解析要比解析开始标签容易多了，因为它不需要解析什么属性</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const ncname = '[a-zA-Z_][\\w\\-\\.]*'
const qnameCapture = `((?:${ncname}\\:)?${ncname})`
const endTag = new RegExp(`^&lt;\\/${}&gt;`)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>解析文本</strong></p> <p>解析文本也比较容易，在解析模板字符串之前，我们先查找一下第一个<code>&lt;</code>出现在什么位置，如果第一个<code>&lt;</code>在第一个位置</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let textEnd = html.indexOf('&lt;')

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="_4-4-文本解析器"><a href="#_4-4-文本解析器" class="header-anchor">#</a> 4.4 文本解析器</h4> <h4 id="_4-5-优化阶段"><a href="#_4-5-优化阶段" class="header-anchor">#</a> 4.5 优化阶段</h4> <p>优化阶段其实干了两件事：</p> <ol><li>在<code>AST</code>中找出所有静态节点并打上标记；</li> <li>在<code>AST</code>中找出所有表态根节点并打上标记；</li></ol> <p>优化阶段的源码位于<code>src/compiler/optimizer.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function optimize (root: ?ASTElement, options: CompilerOptions) {
    if (!root) return
    isStaticKey = genStaticKeysCached(options.staticKeys || '')
    isPlatformReservedTag = options.isReservedTag || no
    // 标记静态节点
    markStatic(root)
    // 标记静态根节点
    markStaticRoots(root, false)
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>标记静态节点</strong></p> <p>从<code>AST</code>中找出所有静态节点并标记其实不难，我们只需从根节点开始，先标记点是否静态节点，然后看根节点如果是元素节点，那么就向下递归它的子节点，子节点如果还有子节点那就继续向下递归，直到票房完所有节点。代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function markStatic (node: ASTNode) {
node.static = isStatic(node)
if (node.type === 1) {
// do not make component slot content static. this avoids
// 1. components not able to mutate slot nodes
// 2. static slot content fails for hot-reloading
if (
!isPlatformReservedTag(node.tag) &amp;&amp;
node.tag !== 'slot' &amp;&amp;
node.attrsMap['inline-template'] == null
) {
return
}
for (let i = 0, l = node.children.length; i &lt; l; i++) {
const child = node.children[i]
markStatic(child)
if (!child.static) {
node.static = false
}
}
if (node.ifConditions) {
for (let i = 1, l = node.ifConditions.length; i &lt; l; i++) {
const block = node.ifConditions[i].block
markStatic(block)
if (!block.static) {
node.static = false
}
}
}
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>上面代码中，首先调用<code>isStatic</code>函数标记节点是否为静态节点，该函数若返回<code>true</code>表示该节点是静态节点，若返回<code>false</code>表示该节点不是静态节点，函数实现如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function isStatic (node: ASTNode): boolean {
if (node.type === 2) { // expression
return false
}
if (node.type === 3) { // text
return true
}
return !!(node.pre || (
!node.hasBindings &amp;&amp; // no dynamic bindings
!node.if &amp;&amp; !node.for &amp;&amp; // not v-if or v-for or v-else
!isBuiltInTag(node.tag) &amp;&amp; // not a built-in
isPlatformReservedTag(node.tag) &amp;&amp; // not a component
!isDirectChildOfTemplateFor(node) &amp;&amp;
Object.keys(node).every(isStaticKey)
))
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>该函数的实现过程其实也说明了如何判断一个节点是否为静态节点。</p> <table><thead><tr><th>type 取值</th> <th>对应的 AST 节点类型</th></tr></thead> <tbody><tr><td>1</td> <td>元素节点</td></tr> <tr><td>2</td> <td>包含变量的动态文本节点</td></tr> <tr><td>3</td> <td>不包含变量的纯文本节点</td></tr></tbody></table> <p>如果元素节点是静态节点，那就必须满足以下几点要求：</p> <ul><li>如果节点使用<code>v-pre</code>指令，那就断定它是静态节点；</li> <li>如果节点没有使用<code>v-pre</code>指令，那它要成为静态节点必须满足：
<ul><li>不能使用动态绑定语法，即标签上不能有<code>v-</code>、<code>@</code>、<code>:</code>开头的属性；</li> <li>不能使用<code>v-if</code>、<code>v-else</code>、<code>v-for</code> 指令；</li> <li>不能是内置组件，即标签名不能是<code>slot</code>和<code>component</code>;</li> <li>标签名必须是平台保留标签，即不能是组件；</li> <li>当前节点的父节点不能是带有<code>v-for</code>和<code>template</code>标签；</li> <li>节点的所有属性的<code>key</code>都必须是静态节点才有的<code>key</code>，注：静态节点的<code>key</code>是有限的，它只能是<code>type</code>、<code>tag</code>、<code>attrsList</code>、<code>attrsMap</code>、<code>plain</code>、<code>parent</code>、<code>children</code>、<code>attrs</code>之一；</li></ul></li></ul> <p><strong>标记静态根节点</strong></p> <p>寻找表态根节点找静态节点的逻辑类似，都是从<code>AST</code>根节点递归向上遍历寻找，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function markStaticRoots (node: ASTNode, isInFor: boolean) {
if (node.type === 1) {
if (node.static || node.once) {
node.staticInFor = isInFor
}
// For a node to qualify as a static root, it should have children that
// are not just static text. Otherwise the cost of hoisting out will
// outweigh the benefits and it's better off to just always render it fresh.
if (node.static &amp;&amp; node.children.length &amp;&amp; !(
node.children.length === 1 &amp;&amp;
node.children[0].type === 3
)) {
node.staticRoot = true
return
} else {
node.staticRoot = false
}
if (node.children) {
for (let i = 0, l = node.children.length; i &lt; l; i++) {
markStaticRoots(node.children[i], isInFor || !!node.for)
}
}
if (node.ifConditions) {
for (let i = 1, l = node.ifConditions.length; i &lt; l; i++) {
markStaticRoots(node.ifConditions[i].block, isInFor)
}
}
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><h4 id="_4-5-代码生成阶段"><a href="#_4-5-代码生成阶段" class="header-anchor">#</a> 4.5 代码生成阶段</h4> <h3 id="五、生命周期篇"><a href="#五、生命周期篇" class="header-anchor">#</a> 五、生命周期篇</h3> <ul><li>初始化阶段</li> <li>模板编译阶段</li> <li>挂载阶段</li> <li>销毁阶段</li></ul> <h4 id="_5-1-初始化阶段"><a href="#_5-1-初始化阶段" class="header-anchor">#</a> 5.1 初始化阶段</h4> <ul><li><code>new Vue</code></li> <li><code>initLifecycle</code></li> <li><code>initEvents</code></li> <li><code>initInjections</code></li> <li><code>initState</code></li></ul> <p><strong>new Vue 都干了什么</strong></p> <p>初始化阶段所做的第一件事就是<code>new Vue()</code>创建一个<code>Vue</code>实例，那么<code>new Vue()</code>的内部都干了什么呢？我们知道，<code>new</code>关键字在<code>JS</code>中表示从一个类中实例化出一个对象来，由此可见，<code>Vue</code>实际上是一个类。所以<code>new Vue()</code>实际上是执行了<code>Vue</code>类的构造函数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function Vue (options) {
if (process.env.NODE_ENV !== 'production' &amp;&amp;
!(this instanceof Vue)
) {
warn('Vue is a constructor and should be called with the `new` keyword')
}
this.\_init(options)
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>合并属性</strong></p> <p>在上文中，<code>_init</code>方法里首先会调用<code>mergeOptions</code>函数来进行属性合并，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
vm.\$options = mergeOptions(
resolveConstructorOptions(vm.constructor),
options || {},
vm
)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>它实际上就是把 <code>resolveConstructorOptions(vm.constructor)</code> 的返回值和 <code>options</code> 做合并，返回<code>vm.constructor.options</code>，相当于<code>Vue.options</code>，那么这个<code>Vue.options</code>又是什么呢，其实在<code>initGlobalAPI(Vue)</code>的时候定义了这个值，代码在<code>src/core/global-api/index.js</code>中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initGlobalAPI (Vue: GlobalAPI) {
// ...
Vue.options = Object.create(null)
ASSET_TYPES.forEach(type =&gt; {
Vue.options[type + 's'] = Object.create(null)
})

extend(Vue.options.components, builtInComponents)
// ...
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>首先通过<code>Vue.options = Object.create(null)</code>创建一个空对象，然后遍历<code>ASSET_TYPES</code>，<code>ASSET_TYPES</code>的定义在<code>src/shared/contstants.js</code>中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export const ASSET_TYPES = [
'component',
'directive',
'filter'
]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>上面遍历<code>ASSET_TYPES</code>后代码相当于：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
Vue.options.components = {}
Vue.options.directives = {}
Vue.options.filters = {}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>最后通过<code>extend(Vue.options.components,builtInCompontents)</code>把一些内置组件扩展到<code>Vue.options.components</code>上，<code>Vue</code>的内置组件目前有<code>&lt;keep-alive&gt;</code>、<code>&lt;transition&gt;</code>和<code>&lt;transition-group&gt;</code>组件，这也就是为什么我们在其它组件中使用这些组件不需要注册的原因。</p> <p><code>mergeOptions</code>这个函数，它的定义在<code>src/core/util/options.js</code>中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
/\*\*

- Merge two option objects into a new one.
- Core utility used in both instantiation and inheritance.
  \*/
  export function mergeOptions (
  parent: Object,
  child: Object,
  vm?: Component
  ): Object {
  if (process.env.NODE_ENV !== 'production') {
  checkComponents(child)
  }

if (typeof child === 'function') {
child = child.options
}

normalizeProps(child, vm)
normalizeInject(child, vm)
normalizeDirectives(child)

// Apply extends and mixins on the child options,
// but only if it is a raw options object that isn't
// the result of another mergeOptions call.
// Only merged options has the \_base property.
if (!child.\_base) {
if (child.extends) {
parent = mergeOptions(parent, child.extends, vm)
}
if (child.mixins) {
for (let i = 0, l = child.mixins.length; i &lt; l; i++) {
parent = mergeOptions(parent, child.mixins[i], vm)
}
}
}

const options = {}
let key
for (key in parent) {
mergeField(key)
}
for (key in child) {
if (!hasOwn(parent, key)) {
mergeField(key)
}
}
function mergeField (key) {
const strat = strats[key] || defaultStrat
options[key] = strat(parent[key], child[key], vm, key)
}
return options
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br></div></div><p>可以看出，<code>mergeOptions</code>函数的主要功能是把<code>parent</code>和<code>child</code>这两个对象根据一些合并策略，合并成一个新对象并返回。首先递归把<code>extends</code>和<code>mixins</code>合并到<code>parent</code>上</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>生命周期钩子函数的合并策略如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function mergeHook(parentVal,childVal){
return childVal? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal
}

LIFECYCLE_HOOKS.forEach(hook =&gt; {
strats[hook] = mergeHook
})

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这其中的<code>LIFECYCLE_HOOKS</code>的定义在<code>src/shared/constants.js</code>中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export const LIFECYCLE_HOOKS = [
'beforeCreate',
'created',
'beforeMount',
'mounted',
'beforeUpdate',
'updated',
'beforeDestroy',
'destroyed',
'activated',
'deactivated',
'errorCaptured'
]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>callHook 函数如何触发钩子函数</strong></p> <p>关于<code>callHook</code>函数如何触发钩子函数的问题，我们只需看一下该函数的实现源码即可，该函数的源码位于<code>src/core/instance/lifecycle.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function callHook(vm,hook){
const handlers = vm.\$options[hook]
if(handlers){
for(let i = 0,j = handlers.length;i&lt;j;i++){
try{
hanlders[i].call(vm)
}catch(e){
handleError(e,vm,`${hook} hook`)
}
}
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>可以看到，<code>callHook</code>函数逻辑非常简单。首先从实例的<code>$options</code>中获取到需要触发的钩子名称所对应的钩子函数数组<code>handlers</code>，我们说过，每个生命周期钩子名称都对应一个钩子函数数组。然后遍历该数组，将数组中的每个钩子函数都执行一遍。</p> <p><strong>initLifecycle 函数分析</strong></p> <p><code>initLifecycle</code>函数的定义的位于源码的<code>src/core/instance/lifecycle.js</code>中，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initLifecycle (vm: Component) {
const options = vm.$options

// locate first non-abstract parent
let parent = options.parent
if (parent &amp;&amp; !options.abstract) {
while (parent.$options.abstract &amp;&amp; parent.$parent) {
parent = parent.$parent
    }
    parent.$children.push(vm)
}

vm.$parent = parent
  vm.$root = parent ? parent.\$root : vm

vm.$children = []
  vm.$refs = {}

vm._watcher = null
vm._inactive = null
vm._directInactive = false
vm._isMounted = false
vm._isDestroyed = false
vm._isBeingDestroyed = false
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p><strong>解析事件</strong></p> <p>在<code>Vue</code>中，当我们在父组件中使用子组件时可以给子组件上注册一些事件，这些事件包括使用<code>v-on</code>或<code>@</code>注册的自定义事件，也包括注册的浏览器原生事件，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;child @select=&quot;selectHandler&quot; @click.native=&quot;clickHandler&quot;&gt;&lt;/child&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>上面代码，首先要从解析事件开始说起，当遇到开始标签的时候，除了会解析开始标签，还会调用<code>processAttrs</code>方法解析标签中的属性，<code>processAttrs</code>方法位于源码的<code>src/compiler/parser/index.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function processAttrs (el) {
const list = el.attrsList
let i, l, name, rawName, value, modifiers, syncGen, isDynamic
for (i = 0, l = list.length; i &lt; l; i++) {
name = rawName = list[i].name
value = list[i].value
if (dirRE.test(name)) {
// mark element as dynamic
el.hasBindings = true
// modifiers
modifiers = parseModifiers(name.replace(dirRE, ''))
// support .foo shorthand syntax for the .prop modifier
if (process.env.VBIND_PROP_SHORTHAND &amp;&amp; propBindRE.test(name)) {
(modifiers || (modifiers = {})).prop = true
name = `.` + name.slice(1).replace(modifierRE, '')
} else if (modifiers) {
name = name.replace(modifierRE, '')
}
if (bindRE.test(name)) { // v-bind
name = name.replace(bindRE, '')
value = parseFilters(value)
isDynamic = dynamicArgRE.test(name)
if (isDynamic) {
name = name.slice(1, -1)
}
if (
process.env.NODE_ENV !== 'production' &amp;&amp;
value.trim().length === 0
) {
warn(
`The value for a v-bind expression cannot be empty. Found in &quot;v-bind:${name}&quot;`
)
}
if (modifiers) {
if (modifiers.prop &amp;&amp; !isDynamic) {
name = camelize(name)
if (name === 'innerHtml') name = 'innerHTML'
}
if (modifiers.camel &amp;&amp; !isDynamic) {
name = camelize(name)
}
if (modifiers.sync) {
syncGen = genAssignmentCode(value, `$event`)
if (!isDynamic) {
addHandler(
el,
`update:${camelize(name)}`,
syncGen,
null,
false,
warn,
list[i]
)
if (hyphenate(name) !== camelize(name)) {
addHandler(
el,
`update:${hyphenate(name)}`,
syncGen,
null,
false,
warn,
list[i]
)
}
} else {
// handler w/ dynamic event name
addHandler(
el,
`&quot;update:&quot;+(${name})`,
syncGen,
null,
false,
warn,
list[i],
true // dynamic
)
}
}
}
if ((modifiers &amp;&amp; modifiers.prop) || (
!el.component &amp;&amp; platformMustUseProp(el.tag, el.attrsMap.type, name)
)) {
addProp(el, name, value, list[i], isDynamic)
} else {
addAttr(el, name, value, list[i], isDynamic)
}
} else if (onRE.test(name)) { // v-on
name = name.replace(onRE, '')
isDynamic = dynamicArgRE.test(name)
if (isDynamic) {
name = name.slice(1, -1)
}
addHandler(el, name, value, modifiers, false, warn, list[i], isDynamic)
} else { // normal directives
name = name.replace(dirRE, '')
// parse arg
const argMatch = name.match(argRE)
let arg = argMatch &amp;&amp; argMatch[1]
isDynamic = false
if (arg) {
name = name.slice(0, -(arg.length + 1))
if (dynamicArgRE.test(arg)) {
arg = arg.slice(1, -1)
isDynamic = true
}
}
addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i])
if (process.env.NODE_ENV !== 'production' &amp;&amp; name === 'model') {
checkForAliasModel(el, value)
}
}
} else {
// literal attribute
if (process.env.NODE_ENV !== 'production') {
const res = parseText(value, delimiters)
if (res) {
warn(
`${name}=&quot;${value}&quot;:` +
'Interpolation inside attributes has been removed. ' +
'Use v-bind or the colon shorthand instead. For example, ' +
'instead of &lt;div id=&quot;{{ val }}&quot;&gt;, use &lt;div :id=&quot;val&quot;&gt;.',
list[i]
)
}
}
addAttr(el, name, JSON.stringify(value), list[i])
if (!el.component &amp;&amp;
name === 'muted' &amp;&amp;
platformMustUseProp(el.tag, el.attrsMap.type, name)) {
addProp(el, name, 'true', list[i])
}
}
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br></div></div><p><strong>initEvents 函数分析</strong></p> <p>了解了以上过程之后，开始分析<code>initEvents</code>函数，该函数位于源码的<code>src/instance/events.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initEvents (vm: Component) {
    vm._events = Object.create(null)
    vm._hasHookEvent = false
    const listeners = vm.$options._parentListeners
    if (listeners) {
        updateComponentListeners(vm, listeners)
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这个<code>updateComponentListeners</code>函数是什么呢？该函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function updateComponentListeners (
vm: Component,
listeners: Object,
oldListeners: ?Object
) {
target = vm
updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler, vm)
target = undefined
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>initInjections 函数分析</strong></p> <p>从函数名字上来看，该函数是用来初始化实例中的<code>inject</code>选项的。说到<code>inject</code>选项，那必然离不开<code>provide</code>选项，这两个选项都是成对出现的，它们的作用是：鸡毛一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间始终生效。</p> <p><code>provide</code>选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES 2015 Symbols 作为 key，但是只在原生支持<code>Symbol</code>和<code>Reflect.ownKeys</code>的环境下可工作。</p> <p><code>inject</code>选项应该是：</p> <ul><li>一个字符串数组或</li> <li>一个对象，对象的 key 是本地的绑定名，value 是：
<ul><li>在可用的注入</li></ul></li></ul> <p><code>initInjections</code>函数的具体原理，该函数定义在位于源码的``中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initInjections (vm: Component) {
const result = resolveInject(vm.\$options.inject, vm)
if (result) {
toggleObserving(false)
Object.keys(result).forEach(key =&gt; {
/\* istanbul ignore else \*/
if (process.env.NODE_ENV !== 'production') {
defineReactive(vm, key, result[key], () =&gt; {
warn(
`Avoid mutating an injected value directly since the changes will be` +
`overwritten whenever the provided component re-renders.` +
`injection being mutated: &quot;${key}&quot;`,
vm
)
})
} else {
defineReactive(vm, key, result[key])
}
})
toggleObserving(true)
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p><strong>initState 函数分析</strong></p> <p>这个函数是用来初始化实例状态的，主要包括<code>props</code>、<code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code>，我们把这些选项称为实例的状态选项。也就是说，<code>initState</code>函数就是用来初始化这些状态的。</p> <p>首先我们先来分析<code>initState</code>函数，该函数的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initState (vm: Component) {
    vm._watchers = []
    const opts = vm.$options
    if (opts.props) initProps(vm, opts.props)
    if (opts.methods) initMethods(vm, opts.methods)
    if (opts.data) {
        initData(vm)
    } else {
        observe(vm._data = {}, true)
    }
    if (opts.computed) initComputed(vm, opts.computed)
    if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch)
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>首先，给实例上新增了一个属性<code>_watchers</code>，用来存储当前实例中所有的<code>watcher</code>实例，无论是使用<code>vm.$watch</code>注册的<code>watcher</code>实例还是使用<code>watch</code>选项注册的<code>watcher</code>实例，都会被保存到该属性中。</p> <p><code>initProps</code>函数的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function initProps (vm: Component, propsOptions: Object) {
const propsData = vm.$options.propsData || {}
  const props = vm._props = {}
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  const keys = vm.$options.\_propKeys = []
const isRoot = !vm.\$parent
// root instance props should be converted
if (!isRoot) {
toggleObserving(false)
}
for (const key in propsOptions) {
keys.push(key)
const value = validateProp(key, propsOptions, propsData, vm)
if (process.env.NODE_ENV !== 'production') {
const hyphenatedKey = hyphenate(key)
if (isReservedAttribute(hyphenatedKey) ||
config.isReservedAttr(hyphenatedKey)) {
warn(`&quot;${hyphenatedKey}&quot; is a reserved attribute and cannot be used as component prop.`,vm)
}
defineReactive(props, key, value, () =&gt; {
if (!isRoot &amp;&amp; !isUpdatingChildComponent) {
warn(
`Avoid mutating a prop directly since the value will be` +
`overwritten whenever the parent component re-renders.` +
`Instead, use a data or computed property based on the prop's` +
`value. Prop being mutated: &quot;${key}&quot;`,
vm
)
}
})
} else {
defineReactive(props, key, value)
}
    if (!(key in vm)) {
        proxy(vm, `_props`, key)
    }
}
    toggleObserving(true)
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>可以看到，该函数接收两个参数：当前<code>Vue</code>实例和当前实例规范化后的<code>props</code>选项。</p> <p>在函数内部首先定义了 4 个变量，分别是：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const propsData = vm.$options.propsData || {}
const props = vm._props = {}
const keys = vm.$options._propKeys = []
const isRoot = !vm.$parent

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>propsData：父组件传入的真实<code>props</code>数据。</li> <li>props：指向<code>vm._props</code>指针，所有设置到</li> <li>keys：指向<code>vm.$options._propKeys</code>的指针，缓存</li> <li>isRoot：当前组件是否为根组件。</li></ul> <p>初始化<code>methods</code>相较而言就比较简单了，它的初始函数定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function initMethods (vm: Component, methods: Object) {
    const props = vm.$options.props
    for (const key in methods) {
        if (process.env.NODE_ENV !== 'production') {
            if (typeof methods[key] !== 'function') {
                warn(
                    `Method &quot;${key}&quot; has type &quot;${typeof methods[key]}&quot; in the component definition.` +
                    `Did you reference the function correctly?`,vm
                )
            }
            if (props &amp;&amp; hasOwn(props, key)) {
                warn(
                `Method &quot;${key}&quot; has already been defined as a prop.`,
                vm
                )
            }
            if ((key in vm) &amp;&amp; isReserved(key)) {
                warn(
                `Method &quot;${key}&quot; conflicts with an existing Vue instance method.` +
                `Avoid defining component methods that start with _ or $.`
                )
            }
    }
        vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm)
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>初始化<code>data</code>也比较简单，它的初始化函数定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initState (vm: Component) {
    vm._watchers = []
    const opts = vm.$options
    if (opts.props) initProps(vm, opts.props)
    if (opts.methods) initMethods(vm, opts.methods)
    if (opts.data) {
        initData(vm)
    } else {
        observe(vm._data = {}, true)
    }
    if (opts.computed) initComputed(vm, opts.computed)
    if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>初始化<code>initComputed</code>的内部原理是怎样的。<code>initComputed</code>函数的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function initComputed (vm: Component, computed: Object) {
    const watchers = vm._computedWatchers = Object.create(null)
    const isSSR = isServerRendering()
    for (const key in computed) {
        const userDef = computed[key]
        const getter = typeof userDef === 'function' ? userDef : userDef.get
        if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) {
            warn(
            `Getter is missing for computed property &quot;${key}&quot;.`,
            vm
            )
        }

        if (!isSSR) {
            watchers[key] = new Watcher(
                vm,
                getter || noop,
                noop,
                computedWatcherOptions
            )
        }

        if (!(key in vm)) {
            defineComputed(vm, key, userDef)
        } else if (process.env.NODE_ENV !== 'production') {
            if (key in vm.$data) {
                warn(`The computed property &quot;${key}&quot; is already defined in data.`, vm)
            } else if (vm.$options.props &amp;&amp; key in vm.$options.props) {
                warn(`The computed property &quot;${key}&quot; is already defined as a prop.`, vm)
            }
        }
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>初始化<code>watch</code>选项，在日常开发中<code>watch</code>选项也经常会使用到，它可以用来侦听某个已有的数据，当该数据发生变化时执行对应的回调函数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function initWatch (vm: Component, watch: Object) {
    for (const key in watch) {
        const handler = watch[key]
        if (Array.isArray(handler)) {
            for (let i = 0; i &lt; handler.length; i++) {
                createWatcher(vm, key, handler[i])
            }
        } else {
            createWatcher(vm, key, handler)
        }
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="_5-2-模板编译阶段"><a href="#_5-2-模板编译阶段" class="header-anchor">#</a> 5.2 模板编译阶段</h4> <h4 id="_5-3-挂载阶段"><a href="#_5-3-挂载阶段" class="header-anchor">#</a> 5.3 挂载阶段</h4> <h4 id="_5-4-销毁阶段"><a href="#_5-4-销毁阶段" class="header-anchor">#</a> 5.4 销毁阶段</h4> <h3 id="六、实例方法"><a href="#六、实例方法" class="header-anchor">#</a> 六、实例方法</h3> <ul><li>数据相关的方法</li> <li>事件相关的方法</li> <li>生命周期相关的方法</li></ul> <h4 id="_6-1-数据相关的方法"><a href="#_6-1-数据相关的方法" class="header-anchor">#</a> 6.1 数据相关的方法</h4> <p>参考小节<a href="#2.3-%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%9A%84-API-%E5%AE%9E%E7%8E%B0">变化侦测的 API 实现</a></p> <h4 id="_6-2-事件相关的方法"><a href="#_6-2-事件相关的方法" class="header-anchor">#</a> 6.2 事件相关的方法</h4> <ul><li><code>vm.$on</code></li> <li><code>vm.$emit</code></li> <li><code>vm.$off</code></li> <li><code>vm.$once</code></li></ul> <p><strong><code>vm.$on</code></strong></p> <ul><li><p><strong>参数：</strong></p> <ul><li><code>{string | Array&lt;string&gt;} event</code>(数组只在 2.2.0+中支持)</li> <li><code>{Function} callback</code></li></ul></li> <li><p><strong>作用：</strong></p></li></ul> <p>内部原理：</p> <h4 id="_6-3-生命周期相关的方法"><a href="#_6-3-生命周期相关的方法" class="header-anchor">#</a> 6.3 生命周期相关的方法</h4> <ul><li><code>vm.$mount</code></li> <li><code>vm.$forceUpdate</code></li> <li><code>vm.$nextTick</code></li> <li><code>vm.$destory</code></li></ul> <h3 id="七、全局-api-篇"><a href="#七、全局-api-篇" class="header-anchor">#</a> 七、全局 API 篇</h3> <p>与实例方法不同，实例方法是将方法挂载到<code>Vue</code>的原型上，而全局 API 是直接在<code>Vue</code>上挂载方法。在<code>Vue</code>中，全局 API 一共有 12 个，分别是<code>Vue.extend</code>、<code>Vue.nextTick</code>、<code>Vue.set</code>、<code>Vue.delete</code>、<code>Vue.directive</code>、<code>Vue.filter</code>、<code>Vue.component</code>、<code>Vue.use</code>、<code>Vue.mixin</code>、<code>Vue.observable</code>、<code>Vue.version</code>。这 12 个 API 中有的是我们在日常业务开发中经常会用到的，有的是对 Vue 内部或外部插件提供的，我们在日常业务开发中几乎用不到。</p> <ol><li>Vue.extend</li> <li>Vue.nextTick</li> <li>Vue.set</li> <li>Vue.delete</li> <li>Vue.directive</li> <li>Vue.filter</li> <li>Vue.component</li> <li>directive、filter、component 小结</li> <li>Vue.use</li> <li>Vue.mixin</li> <li>Vue.compile</li> <li>Vue.observable</li> <li>Vue.version</li></ol> <h4 id="_7-1-vue-extend"><a href="#_7-1-vue-extend" class="header-anchor">#</a> 7.1 Vue.extend</h4> <p>既然是<code>Vue</code>类的子类，那么除了它本身独有的一些属性方法，还有一些是从<code>Vue</code>类中继承而来，所以创建子类的过程其实就是一边给子类上添加上独有的属性，一边将父类的公共属性到子类上。接下来，我们就来看看源码是如何实现这个过程的。</p> <p>该 API 的定义位于源码的<code>src/core/global-api/extend.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
Vue.extend = function (extendOptions: Object): Function {
extendOptions = extendOptions || {}
const Super = this
const SuperId = Super.cid
const cachedCtors = extendOptions.\_Ctor || (extendOptions.\_Ctor = {})
if (cachedCtors[SuperId]) {
return cachedCtors[SuperId]
}

    const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' &amp;&amp; name) {
        validateComponentName(name)
    }

    const Sub = function VueComponent (options) {
        this._init(options)
    }
    Sub.prototype = Object.create(Super.prototype)
    Sub.prototype.constructor = Sub
    Sub.cid = cid++
    Sub.options = mergeOptions(
        Super.options,
        extendOptions
    )
    Sub['super'] = Super

    if (Sub.options.props) {
        initProps(Sub)
    }
    if (Sub.options.computed) {
        initComputed(Sub)
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type]
    })
    // enable recursive self-lookup
    if (name) {
        Sub.options.components[name] = Sub
    }

    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    Sub.sealedOptions = extend({}, Sub.options)

    // cache constructor
    cachedCtors[SuperId] = Sub
    return Sub

}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br></div></div><h4 id="_7-9-vue-use"><a href="#_7-9-vue-use" class="header-anchor">#</a> 7.9 Vue.use</h4> <p>该 API 的定义位于源码的<code>src/core/global-api/use.js</code>中，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
Vue.use = function (plugin) {
const installedPlugins = (this.\_installedPlugins || (this.\_installedPlugins = []))
if (installedPlugins.indexOf(plugin) &gt; -1) {
return this
}

    // additional parameters
    const args = toArray(arguments, 1)
    args.unshift(this)
    if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args)
    } else if (typeof plugin === 'function') {
        plugin.apply(null, args)
    }
    installedPlugins.push(plugin)
    return this

}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h3 id="八、过滤器篇"><a href="#八、过滤器篇" class="header-anchor">#</a> 八、过滤器篇</h3> <h3 id="九、指令篇"><a href="#九、指令篇" class="header-anchor">#</a> 九、指令篇</h3> <h3 id="十、总结"><a href="#十、总结" class="header-anchor">#</a> 十、总结</h3> <p><img src="vue-code.png" alt="images"></p> <h3 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h3> <ul><li><a href="https://github.com/muwoo/blogs" target="_blank" rel="noopener noreferrer">vue 源码分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://hcysun.me/vue-design/art/" target="_blank" rel="noopener noreferrer">Vue 技术内幕<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener noreferrer">Vue.js 技术揭秘<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener noreferrer">Vue.js 源码解析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/dirkhe1051931999/hjBlog/tree/master/blog-vue-sourcecode-study" target="_blank" rel="noopener noreferrer">你想要的 vue 源码分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5ce5565d6fb9a07ed2244513" target="_blank" rel="noopener noreferrer">学习 Vue 源码的必要知识储备<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://nlrx-wjc.github.io/Learn-Vue-Source-Code/start/" target="_blank" rel="noopener noreferrer">逐行剖析 Vue.js 源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener noreferrer">渲染器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.cnblogs.com/tugenhua0707/category/1577630.html" target="_blank" rel="noopener noreferrer">深入 Vue 技术栈及源码系列<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://www.zhufengpeixun.cn/train/vue-info/source.html" target="_blank" rel="noopener noreferrer">Vue 原理剖析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/lihongxun945/myblog/issues/22" target="_blank" rel="noopener noreferrer">Vue2.x 源码解析系列一：我的源码阅读心得<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>《深入浅出 Vue.js》</li></ul> <h2 id="联系作者"><a href="#联系作者" class="header-anchor">#</a> 联系作者</h2> <div align="center"><p>
        平凡世界，贵在坚持。
    </p> <img src="/about/contact.png"></div>
```
</div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新于:</span> <span class="time">2014/2/8 下午8:41:53</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/js/vue-vuex-code.html" class="prev">
        vue-vuex 源码分析
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----><!----><div></div></div></div>
    <script src="/assets/js/app.8e84e2a6.js" defer></script><script src="/assets/js/2.c7f5c1a5.js" defer></script><script src="/assets/js/208.d29fd0df.js" defer></script><script src="/assets/js/3.fb5a4386.js" defer></script>
  </body>
</html>
