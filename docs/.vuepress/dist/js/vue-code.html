<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue 源码分析 | 小武子知识库</title>
    <meta name="description" content="用心，谈技术。大前端">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/hero.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.23dd1510.css" as="style"><link rel="preload" href="/assets/js/app.6429a744.js" as="script"><link rel="preload" href="/assets/js/2.c7f5c1a5.js" as="script"><link rel="preload" href="/assets/js/208.b97b4b55.js" as="script"><link rel="preload" href="/assets/js/3.fb5a4386.js" as="script"><link rel="prefetch" href="/assets/js/10.377a7b0c.js"><link rel="prefetch" href="/assets/js/100.07b34e28.js"><link rel="prefetch" href="/assets/js/101.85641750.js"><link rel="prefetch" href="/assets/js/102.573561ab.js"><link rel="prefetch" href="/assets/js/103.fd760c7d.js"><link rel="prefetch" href="/assets/js/104.4b741488.js"><link rel="prefetch" href="/assets/js/105.0702ce98.js"><link rel="prefetch" href="/assets/js/106.c03b2956.js"><link rel="prefetch" href="/assets/js/107.e828798d.js"><link rel="prefetch" href="/assets/js/108.fcb5eead.js"><link rel="prefetch" href="/assets/js/109.b2c329f2.js"><link rel="prefetch" href="/assets/js/11.0054ea10.js"><link rel="prefetch" href="/assets/js/110.09d7376d.js"><link rel="prefetch" href="/assets/js/111.d126e730.js"><link rel="prefetch" href="/assets/js/112.7ec2b130.js"><link rel="prefetch" href="/assets/js/113.c9ef2c8f.js"><link rel="prefetch" href="/assets/js/114.87da001d.js"><link rel="prefetch" href="/assets/js/115.f4c5fdb6.js"><link rel="prefetch" href="/assets/js/116.4a010888.js"><link rel="prefetch" href="/assets/js/117.d4d09324.js"><link rel="prefetch" href="/assets/js/118.ba519744.js"><link rel="prefetch" href="/assets/js/119.9a59fe06.js"><link rel="prefetch" href="/assets/js/12.4a9bcd22.js"><link rel="prefetch" href="/assets/js/120.c54d2ff5.js"><link rel="prefetch" href="/assets/js/121.8f2a2d86.js"><link rel="prefetch" href="/assets/js/122.ae48dbd2.js"><link rel="prefetch" href="/assets/js/123.754e06e5.js"><link rel="prefetch" href="/assets/js/124.086e72d6.js"><link rel="prefetch" href="/assets/js/125.d73657be.js"><link rel="prefetch" href="/assets/js/126.885cbc51.js"><link rel="prefetch" href="/assets/js/127.83125c07.js"><link rel="prefetch" href="/assets/js/128.a8f0e48e.js"><link rel="prefetch" href="/assets/js/129.7f948f74.js"><link rel="prefetch" href="/assets/js/13.eb8f366e.js"><link rel="prefetch" href="/assets/js/130.b8a5a7ef.js"><link rel="prefetch" href="/assets/js/131.41eadabb.js"><link rel="prefetch" href="/assets/js/132.597a501f.js"><link rel="prefetch" href="/assets/js/133.e24dcaa2.js"><link rel="prefetch" href="/assets/js/134.f8d99eef.js"><link rel="prefetch" href="/assets/js/135.cf5f1a0a.js"><link rel="prefetch" href="/assets/js/136.dec4c26f.js"><link rel="prefetch" href="/assets/js/137.841fced8.js"><link rel="prefetch" href="/assets/js/138.e87ec3ce.js"><link rel="prefetch" href="/assets/js/139.eab6b4d9.js"><link rel="prefetch" href="/assets/js/14.c4bfc1a3.js"><link rel="prefetch" href="/assets/js/140.97637155.js"><link rel="prefetch" href="/assets/js/141.eb07610a.js"><link rel="prefetch" href="/assets/js/142.5b5de43d.js"><link rel="prefetch" href="/assets/js/143.467ace6c.js"><link rel="prefetch" href="/assets/js/144.9a9e38f4.js"><link rel="prefetch" href="/assets/js/145.4d6a4f78.js"><link rel="prefetch" href="/assets/js/146.e3b11351.js"><link rel="prefetch" href="/assets/js/147.dfc7415e.js"><link rel="prefetch" href="/assets/js/148.2afec952.js"><link rel="prefetch" href="/assets/js/149.9eeecf69.js"><link rel="prefetch" href="/assets/js/15.7518cad9.js"><link rel="prefetch" href="/assets/js/150.7279debd.js"><link rel="prefetch" href="/assets/js/151.a049ed48.js"><link rel="prefetch" href="/assets/js/152.2f22a1c3.js"><link rel="prefetch" href="/assets/js/153.61b97b3f.js"><link rel="prefetch" href="/assets/js/154.d1795c75.js"><link rel="prefetch" href="/assets/js/155.64eaf6af.js"><link rel="prefetch" href="/assets/js/156.63b47be9.js"><link rel="prefetch" href="/assets/js/157.4cbc030c.js"><link rel="prefetch" href="/assets/js/158.368331b2.js"><link rel="prefetch" href="/assets/js/159.8d6bd148.js"><link rel="prefetch" href="/assets/js/16.6df5c4fc.js"><link rel="prefetch" href="/assets/js/160.e76b17f0.js"><link rel="prefetch" href="/assets/js/161.4a15f201.js"><link rel="prefetch" href="/assets/js/162.4a57d552.js"><link rel="prefetch" href="/assets/js/163.d7b83272.js"><link rel="prefetch" href="/assets/js/164.87a33af9.js"><link rel="prefetch" href="/assets/js/165.aff9893e.js"><link rel="prefetch" href="/assets/js/166.61f1a992.js"><link rel="prefetch" href="/assets/js/167.3fa1a7d1.js"><link rel="prefetch" href="/assets/js/168.24b00a3a.js"><link rel="prefetch" href="/assets/js/169.f20c45ea.js"><link rel="prefetch" href="/assets/js/17.aa3af4a6.js"><link rel="prefetch" href="/assets/js/170.62d11427.js"><link rel="prefetch" href="/assets/js/171.0765c3b9.js"><link rel="prefetch" href="/assets/js/172.472214a4.js"><link rel="prefetch" href="/assets/js/173.d15c78ea.js"><link rel="prefetch" href="/assets/js/174.c57dbdb2.js"><link rel="prefetch" href="/assets/js/175.eda0ff69.js"><link rel="prefetch" href="/assets/js/176.a81eeb16.js"><link rel="prefetch" href="/assets/js/177.8aedcffb.js"><link rel="prefetch" href="/assets/js/178.2140291a.js"><link rel="prefetch" href="/assets/js/179.0b50b8c1.js"><link rel="prefetch" href="/assets/js/18.25841ce0.js"><link rel="prefetch" href="/assets/js/180.526db5d2.js"><link rel="prefetch" href="/assets/js/181.ac1de743.js"><link rel="prefetch" href="/assets/js/182.5bfd19fa.js"><link rel="prefetch" href="/assets/js/183.f939eb11.js"><link rel="prefetch" href="/assets/js/184.c8a03bd6.js"><link rel="prefetch" href="/assets/js/185.2f0fa34e.js"><link rel="prefetch" href="/assets/js/186.768b6a7c.js"><link rel="prefetch" href="/assets/js/187.3c25a8d4.js"><link rel="prefetch" href="/assets/js/188.208b8269.js"><link rel="prefetch" href="/assets/js/189.078881b8.js"><link rel="prefetch" href="/assets/js/19.c3a0caea.js"><link rel="prefetch" href="/assets/js/190.4356c96a.js"><link rel="prefetch" href="/assets/js/191.4f1ee897.js"><link rel="prefetch" href="/assets/js/192.87423512.js"><link rel="prefetch" href="/assets/js/193.5d266d3b.js"><link rel="prefetch" href="/assets/js/194.cf23f7e9.js"><link rel="prefetch" href="/assets/js/195.a844ec2c.js"><link rel="prefetch" href="/assets/js/196.40aba23a.js"><link rel="prefetch" href="/assets/js/197.217855fe.js"><link rel="prefetch" href="/assets/js/198.dac0e5ae.js"><link rel="prefetch" href="/assets/js/199.a437ea1e.js"><link rel="prefetch" href="/assets/js/20.c75409b7.js"><link rel="prefetch" href="/assets/js/200.f05420b2.js"><link rel="prefetch" href="/assets/js/201.cd99636a.js"><link rel="prefetch" href="/assets/js/202.4d0f3b31.js"><link rel="prefetch" href="/assets/js/203.bf23fbe6.js"><link rel="prefetch" href="/assets/js/204.5c9c4ca1.js"><link rel="prefetch" href="/assets/js/205.01fd1a41.js"><link rel="prefetch" href="/assets/js/206.cab0ab0c.js"><link rel="prefetch" href="/assets/js/207.ff16bc5d.js"><link rel="prefetch" href="/assets/js/209.da3fddb5.js"><link rel="prefetch" href="/assets/js/21.995379f8.js"><link rel="prefetch" href="/assets/js/210.9d6896e3.js"><link rel="prefetch" href="/assets/js/211.d158aea9.js"><link rel="prefetch" href="/assets/js/212.151fe080.js"><link rel="prefetch" href="/assets/js/213.110990c8.js"><link rel="prefetch" href="/assets/js/214.c90dfb55.js"><link rel="prefetch" href="/assets/js/215.231f17fc.js"><link rel="prefetch" href="/assets/js/216.65bcfe22.js"><link rel="prefetch" href="/assets/js/217.473cd90d.js"><link rel="prefetch" href="/assets/js/218.50559f5e.js"><link rel="prefetch" href="/assets/js/219.a044c9bd.js"><link rel="prefetch" href="/assets/js/22.83f3fa56.js"><link rel="prefetch" href="/assets/js/220.3c86b13b.js"><link rel="prefetch" href="/assets/js/221.995b1720.js"><link rel="prefetch" href="/assets/js/222.9403aa39.js"><link rel="prefetch" href="/assets/js/223.b69a9478.js"><link rel="prefetch" href="/assets/js/224.b90be582.js"><link rel="prefetch" href="/assets/js/225.9cb4d224.js"><link rel="prefetch" href="/assets/js/226.0d579c97.js"><link rel="prefetch" href="/assets/js/227.cbda966f.js"><link rel="prefetch" href="/assets/js/228.50a8e4ae.js"><link rel="prefetch" href="/assets/js/229.ebb24f58.js"><link rel="prefetch" href="/assets/js/23.2b598491.js"><link rel="prefetch" href="/assets/js/230.5702c3ba.js"><link rel="prefetch" href="/assets/js/231.2104996a.js"><link rel="prefetch" href="/assets/js/232.1b3f8ee0.js"><link rel="prefetch" href="/assets/js/233.5a981b2a.js"><link rel="prefetch" href="/assets/js/234.8f1e96e5.js"><link rel="prefetch" href="/assets/js/235.36da36ce.js"><link rel="prefetch" href="/assets/js/236.c07890e9.js"><link rel="prefetch" href="/assets/js/237.267a4372.js"><link rel="prefetch" href="/assets/js/238.6ee6950f.js"><link rel="prefetch" href="/assets/js/239.84ad8b6a.js"><link rel="prefetch" href="/assets/js/24.108b175d.js"><link rel="prefetch" href="/assets/js/240.05818921.js"><link rel="prefetch" href="/assets/js/241.44dd6424.js"><link rel="prefetch" href="/assets/js/242.c6d4c02a.js"><link rel="prefetch" href="/assets/js/243.e315f901.js"><link rel="prefetch" href="/assets/js/244.e3e8fae0.js"><link rel="prefetch" href="/assets/js/245.52f54a0e.js"><link rel="prefetch" href="/assets/js/246.fe107a30.js"><link rel="prefetch" href="/assets/js/247.ae2693f1.js"><link rel="prefetch" href="/assets/js/248.95998df3.js"><link rel="prefetch" href="/assets/js/249.cc7678c4.js"><link rel="prefetch" href="/assets/js/25.6c36e58b.js"><link rel="prefetch" href="/assets/js/250.0fb841d7.js"><link rel="prefetch" href="/assets/js/251.4bf2168c.js"><link rel="prefetch" href="/assets/js/252.f0a109ec.js"><link rel="prefetch" href="/assets/js/253.cf2ac1ae.js"><link rel="prefetch" href="/assets/js/254.85be237d.js"><link rel="prefetch" href="/assets/js/255.d187844b.js"><link rel="prefetch" href="/assets/js/256.deb80f0d.js"><link rel="prefetch" href="/assets/js/257.809c8e55.js"><link rel="prefetch" href="/assets/js/258.f6df849b.js"><link rel="prefetch" href="/assets/js/259.cea87b90.js"><link rel="prefetch" href="/assets/js/26.60d7b558.js"><link rel="prefetch" href="/assets/js/260.6478ac01.js"><link rel="prefetch" href="/assets/js/261.8066aa1b.js"><link rel="prefetch" href="/assets/js/262.ec302b9a.js"><link rel="prefetch" href="/assets/js/263.da5ed079.js"><link rel="prefetch" href="/assets/js/264.e12002b3.js"><link rel="prefetch" href="/assets/js/265.35b8669c.js"><link rel="prefetch" href="/assets/js/266.41a6e9bd.js"><link rel="prefetch" href="/assets/js/267.3fc4c1c4.js"><link rel="prefetch" href="/assets/js/268.1f2fec85.js"><link rel="prefetch" href="/assets/js/269.126cd307.js"><link rel="prefetch" href="/assets/js/27.b63340ef.js"><link rel="prefetch" href="/assets/js/270.9756dc49.js"><link rel="prefetch" href="/assets/js/271.20b67908.js"><link rel="prefetch" href="/assets/js/272.771b6dea.js"><link rel="prefetch" href="/assets/js/273.269a2267.js"><link rel="prefetch" href="/assets/js/274.f5ce9dd2.js"><link rel="prefetch" href="/assets/js/275.396bf845.js"><link rel="prefetch" href="/assets/js/276.f23ca306.js"><link rel="prefetch" href="/assets/js/277.40d2c36b.js"><link rel="prefetch" href="/assets/js/278.b6c5c3f5.js"><link rel="prefetch" href="/assets/js/279.022f607e.js"><link rel="prefetch" href="/assets/js/28.1d258493.js"><link rel="prefetch" href="/assets/js/280.c536ec64.js"><link rel="prefetch" href="/assets/js/281.d6b828e2.js"><link rel="prefetch" href="/assets/js/282.fe53fe86.js"><link rel="prefetch" href="/assets/js/283.3ba62b1c.js"><link rel="prefetch" href="/assets/js/284.fc226461.js"><link rel="prefetch" href="/assets/js/285.a9a710e2.js"><link rel="prefetch" href="/assets/js/286.5bd0af2f.js"><link rel="prefetch" href="/assets/js/287.e22bbc8b.js"><link rel="prefetch" href="/assets/js/288.1073b0b0.js"><link rel="prefetch" href="/assets/js/289.209c7edc.js"><link rel="prefetch" href="/assets/js/29.9908c78c.js"><link rel="prefetch" href="/assets/js/290.8a6d893e.js"><link rel="prefetch" href="/assets/js/291.0ee83e23.js"><link rel="prefetch" href="/assets/js/30.ef8afa90.js"><link rel="prefetch" href="/assets/js/31.65acd4bc.js"><link rel="prefetch" href="/assets/js/32.d1465e6d.js"><link rel="prefetch" href="/assets/js/33.69e03757.js"><link rel="prefetch" href="/assets/js/34.73e56aa6.js"><link rel="prefetch" href="/assets/js/35.fb5f8a10.js"><link rel="prefetch" href="/assets/js/36.6040feee.js"><link rel="prefetch" href="/assets/js/37.3b1055c2.js"><link rel="prefetch" href="/assets/js/38.462e5a42.js"><link rel="prefetch" href="/assets/js/39.3087fb3d.js"><link rel="prefetch" href="/assets/js/4.281e0f5f.js"><link rel="prefetch" href="/assets/js/40.ed2d5743.js"><link rel="prefetch" href="/assets/js/41.5937a976.js"><link rel="prefetch" href="/assets/js/42.e0cfe361.js"><link rel="prefetch" href="/assets/js/43.ce259846.js"><link rel="prefetch" href="/assets/js/44.540aa1a7.js"><link rel="prefetch" href="/assets/js/45.d4d32957.js"><link rel="prefetch" href="/assets/js/46.e37bd7d2.js"><link rel="prefetch" href="/assets/js/47.b8c17fc7.js"><link rel="prefetch" href="/assets/js/48.ada7c3cb.js"><link rel="prefetch" href="/assets/js/49.25631c99.js"><link rel="prefetch" href="/assets/js/5.162e5946.js"><link rel="prefetch" href="/assets/js/50.e166c1b8.js"><link rel="prefetch" href="/assets/js/51.bb115efc.js"><link rel="prefetch" href="/assets/js/52.182e1f26.js"><link rel="prefetch" href="/assets/js/53.70ec05dc.js"><link rel="prefetch" href="/assets/js/54.0f8e557b.js"><link rel="prefetch" href="/assets/js/55.c725f32e.js"><link rel="prefetch" href="/assets/js/56.4febbc6d.js"><link rel="prefetch" href="/assets/js/57.23e3abce.js"><link rel="prefetch" href="/assets/js/58.b31dff48.js"><link rel="prefetch" href="/assets/js/59.edd958db.js"><link rel="prefetch" href="/assets/js/6.416a672f.js"><link rel="prefetch" href="/assets/js/60.966332d0.js"><link rel="prefetch" href="/assets/js/61.15ca30c1.js"><link rel="prefetch" href="/assets/js/62.db92d627.js"><link rel="prefetch" href="/assets/js/63.29aa412d.js"><link rel="prefetch" href="/assets/js/64.f5a45dc9.js"><link rel="prefetch" href="/assets/js/65.0b59c6c5.js"><link rel="prefetch" href="/assets/js/66.3eae74c5.js"><link rel="prefetch" href="/assets/js/67.c1b026c6.js"><link rel="prefetch" href="/assets/js/68.84a0fdc5.js"><link rel="prefetch" href="/assets/js/69.32ee86ac.js"><link rel="prefetch" href="/assets/js/7.d1943d20.js"><link rel="prefetch" href="/assets/js/70.cbeb0042.js"><link rel="prefetch" href="/assets/js/71.503559f2.js"><link rel="prefetch" href="/assets/js/72.90efd715.js"><link rel="prefetch" href="/assets/js/73.e393e4a1.js"><link rel="prefetch" href="/assets/js/74.06465415.js"><link rel="prefetch" href="/assets/js/75.32ea836b.js"><link rel="prefetch" href="/assets/js/76.9b447e16.js"><link rel="prefetch" href="/assets/js/77.0d9868f8.js"><link rel="prefetch" href="/assets/js/78.90039e35.js"><link rel="prefetch" href="/assets/js/79.4096e51a.js"><link rel="prefetch" href="/assets/js/8.87fe89ab.js"><link rel="prefetch" href="/assets/js/80.38b6b70c.js"><link rel="prefetch" href="/assets/js/81.de152d33.js"><link rel="prefetch" href="/assets/js/82.7baa3f9d.js"><link rel="prefetch" href="/assets/js/83.37ab45d2.js"><link rel="prefetch" href="/assets/js/84.b5fd2be3.js"><link rel="prefetch" href="/assets/js/85.0b9e84a5.js"><link rel="prefetch" href="/assets/js/86.0b3bbb1b.js"><link rel="prefetch" href="/assets/js/87.7bb4b9c0.js"><link rel="prefetch" href="/assets/js/88.4cf7cc43.js"><link rel="prefetch" href="/assets/js/89.dd3382f1.js"><link rel="prefetch" href="/assets/js/9.2fda250d.js"><link rel="prefetch" href="/assets/js/90.3d810f07.js"><link rel="prefetch" href="/assets/js/91.452b2082.js"><link rel="prefetch" href="/assets/js/92.9e60276e.js"><link rel="prefetch" href="/assets/js/93.78e855d6.js"><link rel="prefetch" href="/assets/js/94.88f4d0b5.js"><link rel="prefetch" href="/assets/js/95.e0e479d1.js"><link rel="prefetch" href="/assets/js/96.7bd8f650.js"><link rel="prefetch" href="/assets/js/97.965090ac.js"><link rel="prefetch" href="/assets/js/98.e4180bea.js"><link rel="prefetch" href="/assets/js/99.68085fb5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.23dd1510.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">小武子知识库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/js/" class="nav-link router-link-active">
  javascript
</a></div><div class="nav-item"><a href="/css/" class="nav-link">
  css
</a></div><div class="nav-item"><a href="/html5/" class="nav-link">
  HTML5
</a></div><div class="nav-item"><a href="/tool/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  软件工程
</a></div><div class="nav-item"><a href="/cs/" class="nav-link">
  计算机基础
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/materials/" class="nav-link">
  资料收集
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于作者
</a></div><div class="nav-item"><a href="https://www.github.com/fttony" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/js/" class="nav-link router-link-active">
  javascript
</a></div><div class="nav-item"><a href="/css/" class="nav-link">
  css
</a></div><div class="nav-item"><a href="/html5/" class="nav-link">
  HTML5
</a></div><div class="nav-item"><a href="/tool/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  软件工程
</a></div><div class="nav-item"><a href="/cs/" class="nav-link">
  计算机基础
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试题
</a></div><div class="nav-item"><a href="/materials/" class="nav-link">
  资料收集
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于作者
</a></div><div class="nav-item"><a href="https://www.github.com/fttony" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>javascript基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/es5-expression.html" class="sidebar-link">表达式与运算符</a></li><li><a href="/js/es5-type.html" class="sidebar-link">JS 数据类型与数据类型转换</a></li><li><a href="/js/es5-prototype.html" class="sidebar-link">原型与原型链</a></li><li><a href="/js/es5-this.html" class="sidebar-link">this 解析</a></li><li><a href="/js/es5-closure.html" class="sidebar-link">闭包</a></li><li><a href="/js/es5-apply-call-bind.html" class="sidebar-link">apply&amp;bind&amp;call</a></li><li><a href="/js/es5-dom.html" class="sidebar-link">DOM与BOM</a></li><li><a href="/js/es5-event.html" class="sidebar-link">JS事件</a></li><li><a href="/js/es5-execution-context.html" class="sidebar-link">执行上下文与执行上下文栈</a></li><li><a href="/js/es5-extends.html" class="sidebar-link">继承</a></li><li><a href="/js/es5-fn.html" class="sidebar-link">函数</a></li><li><a href="/js/es5-news.html" class="sidebar-link">new 理解</a></li><li><a href="/js/es5-array.html" class="sidebar-link">数组</a></li><li><a href="/js/es5-object.html" class="sidebar-link">对象</a></li><li><a href="/js/es5-reg.html" class="sidebar-link">正则表达式学习</a></li><li><a href="/js/es5-scope.html" class="sidebar-link">作用域</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>javascript进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/js-clone.html" class="sidebar-link">JS的浅拷贝与深拷贝</a></li><li><a href="/js/js-curry.html" class="sidebar-link">函数柯理化</a></li><li><a href="/js/js-debounce.html" class="sidebar-link">节流与防抖动</a></li><li><a href="/js/js-precision.html" class="sidebar-link">js 精度丢失问题</a></li><li><a href="/js/js-memory.html" class="sidebar-link">js 内存管理</a></li><li><a href="/js/js-memory-1.html" class="sidebar-link">JS 内存泄漏、监控和分析</a></li><li><a href="/js/js-async.html" class="sidebar-link">事件循环和异步编程的崛起</a></li><li><a href="/js/js-bit.html" class="sidebar-link">js 位运算</a></li><li><a href="/js/js-eventloop.html" class="sidebar-link">理解 EventLoop</a></li><li><a href="/js/js-module.html" class="sidebar-link">js 模块化</a></li><li><a href="/js/js-run.html" class="sidebar-link">javascript 执行过程</a></li><li><a href="/js/js-ast.html" class="sidebar-link">解析、抽象语法树（AST）+ 提升编译速度 5 个技巧</a></li><li><a href="/js/js-v8.html" class="sidebar-link">V8 简介</a></li><li><a href="/js/js-principle.html" class="sidebar-link">JS 编译器，解释引擎</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>es6</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/es6-array.html" class="sidebar-link">数组扩展</a></li><li><a href="/js/es6-fn.html" class="sidebar-link">函数扩展</a></li><li><a href="/js/es6-class-1.html" class="sidebar-link">Class 基本用法</a></li><li><a href="/js/es6-class-2.html" class="sidebar-link">Class 继承</a></li><li><a href="/js/es6-async.html" class="sidebar-link">async 函数</a></li><li><a href="/js/es6-generator-1.html" class="sidebar-link">Generator 函数的语法</a></li><li><a href="/js/es6-generator-2.html" class="sidebar-link">Generator 函数的异步应用</a></li><li><a href="/js/es6-iterator.html" class="sidebar-link">Iterator 和 for...of 循环</a></li><li><a href="/js/es6-let-const.html" class="sidebar-link">let 与 const</a></li><li><a href="/js/es6-module.html" class="sidebar-link">Module 对象</a></li><li><a href="/js/es6-number.html" class="sidebar-link">数值扩展</a></li><li><a href="/js/es6-object.html" class="sidebar-link">对象扩展</a></li><li><a href="/js/es6-promise.html" class="sidebar-link">Promise 对象</a></li><li><a href="/js/es6-proxy-reflect.html" class="sidebar-link">Proxy 和 Reflect</a></li><li><a href="/js/es6-set-map.html" class="sidebar-link">Set和Map数据结构</a></li><li><a href="/js/es6-string.html" class="sidebar-link">字符串扩展</a></li><li><a href="/js/es6-symbol.html" class="sidebar-link">Symbol</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/ts-introduct.html" class="sidebar-link">ts 学习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>nodejs</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/node-introdect.html" class="sidebar-link">node 介绍</a></li><li><a href="/js/node-eventloop.html" class="sidebar-link">Node 的事件循环机制</a></li><li><a href="/js/node-buffer.html" class="sidebar-link">buffer 模块</a></li><li><a href="/js/node-cheerio.html" class="sidebar-link">cheerio 模块</a></li><li><a href="/js/node-cluster.html" class="sidebar-link">cluster 集群</a></li><li><a href="/js/node-egg.html" class="sidebar-link">egg 基础应用</a></li><li><a href="/js/node-events.html" class="sidebar-link">events 模块</a></li><li><a href="/js/node-express.html" class="sidebar-link">express 基础应用</a></li><li><a href="/js/node-fs.html" class="sidebar-link">fs 模块</a></li><li><a href="/js/node-http.html" class="sidebar-link">http 模块</a></li><li><a href="/js/node-rpc.html" class="sidebar-link">RPC 调用</a></li><li><a href="/js/node-koa.html" class="sidebar-link">koa 基础应用</a></li><li><a href="/js/node-koa-code.html" class="sidebar-link">koa 源码分析</a></li><li><a href="/js/node-net.html" class="sidebar-link">net 模块</a></li><li><a href="/js/node-process.html" class="sidebar-link">process 进程</a></li><li><a href="/js/node-querystring.html" class="sidebar-link">querystring 模块</a></li><li><a href="/js/node-stream.html" class="sidebar-link">stream 模块</a></li><li><a href="/js/node-queue.html" class="sidebar-link">node.js 中的消息队列</a></li><li><a href="/js/node-url.html" class="sidebar-link">url 模块</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>vue框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/mvvm.html" class="sidebar-link">mvvm 框架介绍</a></li><li><a href="/js/jquery-code.html" class="sidebar-link">jquery 源码分析</a></li><li><a href="/js/undescore.html" class="sidebar-link">undescore 源码分析</a></li><li><a href="/js/vue-jsx.html" class="sidebar-link">Vue 中使用 JSX</a></li><li><a href="/js/vue-lifecycle.html" class="sidebar-link">Vue 生命周期</a></li><li><a href="/js/vue-keep.html" class="sidebar-link">keep-alive 学习</a></li><li><a href="/js/vue-dom.html" class="sidebar-link">虚拟 DOM 解析</a></li><li><a href="/js/vue-communication.html" class="sidebar-link">vue 组件通信</a></li><li><a href="/js/vue-bind.html" class="sidebar-link">vue 双向数据绑定原理</a></li><li><a href="/js/vue-nexttick.html" class="sidebar-link">Vue.netTick 理解与分析</a></li><li><a href="/js/vue-watch.html" class="sidebar-link">Vue 中的 computed,watch,methods 理解与分析</a></li><li><a href="/js/vue-router.html" class="sidebar-link">vue-router 学习及原理</a></li><li><a href="/js/vue-router-code.html" class="sidebar-link">vue-router 源码分析</a></li><li><a href="/js/vue-vuex.html" class="sidebar-link">vuex 学习及原理</a></li><li><a href="/js/vue-vuex-code.html" class="sidebar-link">vue-vuex 源码分析</a></li><li><a href="/js/vue-code.html" class="active sidebar-link">vue 源码分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/vue-code.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/js/vue-code.html#内容" class="sidebar-link">内容</a></li><li class="sidebar-sub-header"><a href="/js/vue-code.html#联系作者" class="sidebar-link">联系作者</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-源码分析"><a href="#vue-源码分析" class="header-anchor">#</a> vue 源码分析</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>本人平时学习及收集内容，欢迎参入一起讨论。</p> <h2 id="内容"><a href="#内容" class="header-anchor">#</a> 内容</h2> <ul><li><a href="#%E4%B8%80%E3%80%81%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1">源码目录设计</a></li> <li><a href="#%E4%BA%8C%E3%80%81%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%AF%87">变化侦测篇</a></li> <li><a href="#%E4%B8%89%E3%80%81%E8%99%9A%E6%8B%9F-dom-%E7%AF%87">虚拟 DOM 篇</a></li> <li><a href="#%E5%9B%9B%E3%80%81%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E7%AF%87">模板编译篇</a></li> <li><a href="#%E4%BA%94%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AF%87">生命周期篇</a></li> <li><a href="#%E5%85%AD%E3%80%81%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">实例方法</a></li> <li><a href="#%E4%B8%83%E3%80%81%E5%85%A8%E5%B1%80-api-%E7%AF%87">全局 API 篇</a></li> <li><a href="#%E5%85%AB%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AF%87">过滤器篇</a></li> <li><a href="#%E4%B9%9D%E3%80%81%E6%8C%87%E4%BB%A4%E7%AF%87">指令篇</a></li></ul> <h3 id="一、源码目录设计"><a href="#一、源码目录设计" class="header-anchor">#</a> 一、源码目录设计</h3> <p>Vue.js 的源码都在 src 目录下，其目录结构如下。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>├─dist                   # 项目构建后的文件
├─scripts                # 与项目构建相关的脚本和配置文件
├─flow                   # flow的类型声明文件
├─src                    # 项目源代码
│    ├─complier          # 与模板编译相关的代码
│    ├─core              # 通用的、与运行平台无关的运行时代码
│    │  ├─observe        # 实现变化侦测的代码
│    │  ├─vdom           # 实现virtual dom的代码
│    │  ├─instance       # Vue.js实例的构造函数和原型方法
│    │  ├─global-api     # 全局api的代码
│    │  └─components     # 内置组件的代码
│    ├─server            # 与服务端渲染相关的代码
│    ├─platforms         # 特定运行平台的代码，如weex
│    ├─sfc               # 单文件组件的解析代码
│    └─shared            # 项目公用的工具代码
└─test                   # 项目测试代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>compiler</li> <li>core</li> <li>platform</li> <li>server</li> <li>sfc</li> <li>shared</li></ul> <h4 id="_1-1-compiler"><a href="#_1-1-compiler" class="header-anchor">#</a> 1.1 compiler</h4> <p><code>compiler</code>目录包含<code>Vue.js</code>所有编译相关的代码。它包括把模板解析成 ast 语法树、ast 语法树优化，代码生成等功能。</p> <p>编译的工作可以在构建时做（借助<code>webpack</code>、<code>vue-loader</code>等辅助插件）；也可以在运行时做，使用包含构建功能的<code>vue.js</code>。显然，编译是一项耗性能的工作，所以更推荐前者——离线编译。</p> <h4 id="_1-2-core"><a href="#_1-2-core" class="header-anchor">#</a> 1.2 core</h4> <p><code>core</code>目录包含了<code>Vue.js</code>的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。</p> <p>这里的代码可谓是 Vue.js 的灵魂，也是我们之后需要重点分析的地方</p> <h4 id="_1-3-platform"><a href="#_1-3-platform" class="header-anchor">#</a> 1.3 platform</h4> <p><code>Vue.js</code>是一个跨平台的<code>MVVM</code>框架，它可以跑在<code>web</code>上，也可以配合<code>weex</code>跑在<code>native</code>客户端上。<code>platform</code>是 <code>Vue.js</code>的入口，2 个目录代表 2 个主要入口，分别打包成运行在<code>web</code>上和<code>weex</code>上的<code>Vue.js</code>。</p> <p>我们会重点分析<code>web</code>入口打包后的<code>Vue.js</code>，对于<code>weex</code>入口打包的<code>Vue.js</code>，感兴趣的同学可以自行研究。</p> <h4 id="_1-4-server"><a href="#_1-4-server" class="header-anchor">#</a> 1.4 server</h4> <p><code>Vue.js 2.0</code>支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。注意：这部分代码是跑在服务端的<code>Node.js</code>，不要和跑在浏览器端的<code>Vue.js</code>混为一谈。</p> <p>服务端渲染主要的工作是把组件渲染为服务器端的<code>HTML</code>字符串，将它们直接发送到浏览器，最后将静态标记&quot;混合&quot;为客户端上完全交互的应用程序。</p> <h4 id="_1-5-sfc"><a href="#_1-5-sfc" class="header-anchor">#</a> 1.5 sfc</h4> <p>通常我们开发<code>Vue.js</code>都会借助<code>webpack</code>构建， 然后通过<code>.vue</code>单文件来编写组件。</p> <p>这个目录下的代码逻辑会把<code>.vue</code>文件内容解析成一个<code>JavaScript</code>的对象。</p> <h4 id="_1-6-shared"><a href="#_1-6-shared" class="header-anchor">#</a> 1.6 shared</h4> <p><code>Vue.js</code>会定义一些工具方法，这里定义的工具方法都是会被浏览器端的<code>Vue.js</code>和服务端的<code>Vue.js</code>所共享的。</p> <h3 id="二、变化侦测篇"><a href="#二、变化侦测篇" class="header-anchor">#</a> 二、变化侦测篇</h3> <ul><li>Object 的变化侦测</li> <li>Array 的变化侦测</li> <li>变化侦测的 API 实现</li></ul> <h4 id="_2-1-object-的变化侦测"><a href="#_2-1-object-的变化侦测" class="header-anchor">#</a> 2.1 Object 的变化侦测</h4> <p><strong>使用 Object 数据变得“可观测”</strong></p> <p>数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的“可观测”。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 源码位置：src/core/observer/index.js

/**
 *  Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象
 */
export class Observer {
  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    // 给value新增一个__ob__属性，值为该value的Observer实例
    //
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i &lt; keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }
}


/**
 * 使一个对象转化成可观测对象
 * @param { Object } obj 对象
 * @param { String } key 对象的key
 * @param { Any } val 对象的某个key的值
 */
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property &amp;&amp; property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property &amp;&amp; property.get
  const setter = property &amp;&amp; property.set
  if ((!getter || setter) &amp;&amp; arguments.length === 2) {
    val = obj[key]
  }

    // 递归调用，判断属性值是否是对象
  let childOb = !shallow &amp;&amp; observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter &amp;&amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow &amp;&amp; observe(newVal)
      dep.notify()
    }
  })
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br></div></div><p><strong>什么是依赖收集</strong></p> <p>视图里谁用到了这个数据就更新谁，我们换个优雅说法：我们把“谁用到了这个数据”称为“谁依赖了这个数据”，我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数据中，把每个依赖都通知一遍，告诉他们：“你们依赖的数据变啦，你们该更新啦！”。这个过程就是依赖收集。</p> <p><strong>何时收集依赖？何时通知依赖更新？</strong></p> <p>在 getter 中收集依赖，在 setter 中通知依赖更新。</p> <p><strong>把依赖收集到哪里</strong></p> <p>我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array&lt;Watcher&gt;;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

    // 订阅
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }
    // 通知更新
  notify () {
    // 转化成数组
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) {
      subs.sort((a, b) =&gt; a.id - b.id)
    }
    for (let i = 0, l = subs.length; i &lt; l; i++) {
      subs[i].update()
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>有了依赖管理器后，我们就可以在 getter 中收集依赖，在 setter 中通知依赖更新了，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function defineReactive (obj,key,val){
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property &amp;&amp; property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property &amp;&amp; property.get
  const setter = property &amp;&amp; property.set
  if ((!getter || setter) &amp;&amp; arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow &amp;&amp; observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter &amp;&amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow &amp;&amp; observe(newVal)
      dep.notify()
    }
  })
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><p>在上述代码中，我们在<code>getter</code>中调用了<code>dep.depend()</code>方法收集依赖，在<code>setter</code>中调用<code>dep.notify()</code>方法通知所有依赖更新。</p> <p><strong>依赖到底是谁</strong></p> <p>上面我们明白了什么是依赖？何时收集依赖？以及收集的依赖存放到何处？那么我们收集的依赖到底是谁？</p> <p>其实在<code>Vue</code>中还实现了一个叫做<code>Watcher</code>的类，而<code>Watcher</code>类的实例就是我们上面所说的那个“谁”。换句话说就是：谁用了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例。在之后数据变化时，我们不直接去通知依赖更新，而通知依赖对应的<code>Watch</code>实例，由<code>Watcher</code>实例去通知真正的视图。</p> <p><code>Watcher</code>类的具体实现如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default class Watcher {
  constructor (vm,expOrFn,cb) {
    this.vm = vm;
    this.cb = cb;
    this.getter = parsePath(expOrFn)
    this.value = this.get()
  }
  get () {
    window.target = this;
    const vm = this.vm
    let value = this.getter.call(vm, vm)
    window.target = undefined;
    return value
  }
  update () {
    const oldValue = this.value
    this.value = this.get()
    this.cb.call(this.vm, this.value, oldValue)
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><code>Watcher</code>类的代码实现逻辑：</p> <ol><li>当实例化<code>Watcher</code>类时，会先执行其构造函数；</li> <li>在构造函数中调用了<code>this.get()</code>实例方法；</li> <li>在<code>get()</code>方法中，首先通过<code>window.target = this</code>把实例自身赋给了全局的一个唯一对象<code>window.target</code>上，然后通过<code>let value = this.getter.call(vm,vm)</code>获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>，上文我们说过，在<code>getter</code>里会调用<code>dep.depend()</code>收集依赖，而在<code>dep.depend()</code>中取到挂载<code>window.target</code>上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</li> <li>而当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用了<code>dep.notify()</code>方法，在<code>dep.notify()</code>方法中，遍历所有依赖(即 watcher 实例)，执行依赖的<code>update()</code>方法，也就是<code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code>方法中调用数据变化的更新回调函数，从而更新视图</li></ol> <p>总结一下：<code>Watcher</code>先把自己设置到全局唯一的指定位置(<code>window.target</code>)，然后读取数据。因为读取了数据，所以会触发这个数据的<code>getter</code>。接着，在<code>getter</code>中就会从全局唯一的那个位置读取当前正在读取数据的<code>Watcher</code>，并把这个<code>wather</code>收集到<code>Dep</code>中去。收集好之后，当数据发生变化时，会向<code>Dep</code>中的每个<code>Wather</code>发送通知。通过这样的方式。<code>Wather</code>可以主动去订阅任意一个数据的变化。</p> <p><strong>不足之处</strong></p> <p>虽然我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，但是这个方法仅仅只能观测到<code>object</code>数据的取值及设置值，当我们向<code>object</code>数据里添加一对新的<code>key/value</code>或删除一对已有的<code>key/value</code>时，它是无法观测到的，导致当我们对<code>object</code>数据添加或删除时，无法通知依赖，无法驱动视力进行响应式更新。</p> <p><code>Vue</code>也注意到了这一点，为了解决这一问题，<code>Vue</code>增加了两个全局 API：<code>Vue.set</code>和<code>Vue.delete</code>。</p> <p><strong>总结</strong></p> <p>我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，并且封装了<code>Observer</code>类，让我们能够方便的把<code>object</code>数据中的所有属性（包括子属性）都转换成<code>getter/setter</code>的形式来侦测变化。</p> <p>其整个流程大致如下：</p> <ol><li><code>Data</code>通过<code>observer</code>转换成了<code>getter/setter</code>的形式来追踪变化。</li> <li>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将<code>Watcher</code>添加到依赖中。</li> <li>当数据发生了变化时，会触发<code>setter</code>，从而向<code>Dep</code>'中的依赖（vcb 即 Watcher）发送通知。</li> <li><code>Watcher</code>接收到通知后，会向外界发送能知，变化通知到外界后可能会触发视图更新，也有可能触发某个回调数等。</li></ol> <h4 id="_2-2-array-的变化侦测"><a href="#_2-2-array-的变化侦测" class="header-anchor">#</a> 2.2 Array 的变化侦测</h4> <p>上一节文章中我们介绍了<code>Object</code>数据的变化侦测方式，本节我们来看一下对<code>Array</code>型数据的变化<code>Vue</code>是如何进行侦测的。</p> <p>我们知道，<code>Object.defineProperty</code>监测<code>Object</code>型数据时是给<code>Object</code>型数据的每个<code>key/value</code>添加上了<code>getter</code>和<code>setter</code>，这样，对于<code>Object</code>型数据我们再通过<code>key</code>值取值或设置值时就可以被监测到。</p> <p>数组并不是只能由索引值来操作数组，更常用的操作数组的方法是使用数组原型上的一些方法如<code>push</code>，<code>shift</code>等来操作数组，当使用这些数据原型方法来数组时，<code>Object.defineProperty</code>就监测不到了，所以<code>Vue</code>对<code>Array</code>型数据单独设计了数据监测方式。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    ob.dep.notify()
    return result
  })
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p><strong>数组方法拦截器</strong></p> <p>在<code>Vue</code>中创建了一个数组方法拦截器，它拦截在数组实例与<code>Array.prototype</code>之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用<code>Array.prototype</code>上的原生方法。如下图所示：</p> <p><img src="vue12.png" alt="images"></p> <p>经过整理，<code>Array</code>原型中可以改变数组自身内容的方法有 7 个，分别是：<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>。源码中的拦截器代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 源码位置：/src/core/observer/array.js

const arrayProto = Array.prototype
// 创建一个对象作为拦截器
export const arrayMethods = Object.create(arrayProto)

// 改变数组自身内容的7个方法
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  const original = arrayProto[method]      // 缓存原生方法
  Object.defineProperty(arrayMethods, method, {
    enumerable: false,
    configurable: true,
    writable: true,
    value:function mutator(...args){
      const result = original.apply(this, args)
      return result
    }
  })
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>首先创建了继承自<code>Array</code>原型的空对象<code>arrayMethods</code>，接着在<code>arrayMethods</code>上使用<code>object.defineProperty</code>方法将那些可以改变数组自身的 7 个方法遍历逐个进行封装。最后，当我们使用<code>push</code>方法的时候，其实用的是<code>arrayMethods.push</code>，而<code>arrayMethods.push</code>就是封装的新函数<code>mutator</code>，也就是说，实际上执行的是函数<code>mutator</code>，而<code>mutator</code>函数的内部执行了<code>original</code>函数，这个<code>original</code>函数就是<code>Array.prototype</code>上对应的原生方法。那么，接下我们就可以在<code>mutator</code>函数中做一些其他的事，比如说发送变化通知。</p> <p><strong>使用拦截器</strong></p> <p>我们把撞拦截器做好还不够，还要把它挂载到数组实例与<code>Array.prototype</code>之间，这样拦截器才能够生效。</p> <p>其实挂载不难，我们只需数据的<code>__proto__</code> 属性设置为拦截器<code>arrayMethods</code>即可，源码实现如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 源码位置：/src/core/observer/index.js
export class Observer {
  constructor (value) {
    this.value = value
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }
}
// 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性
export const hasProto = '__proto__' in {}

const arrayKeys = Object.getOwnPropertyNames(arrayMethods)

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src: Object, keys: any) {
  target.__proto__ = src
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) {
  for (let i = 0, l = keys.length; i &lt; l; i++) {
    const key = keys[i]
    def(target, key, src[key])
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><p>上面代码中首先判断了浏览器是否支持<code>__proto__</code>，如果支持，则调用<code>protoAugment</code>函数把<code>value__proto__ = arrayMethods</code>；如果不支持，则调用<code>copyAugment</code>函数把拦截器中重写的 7 个方法循环加入到<code>value</code>上。</p> <p>拦截器生效以后，当数组数据再发生变化时，我们就可以在拦截器中通知变化了，也就是说现在我们就可以知道数组数据何时发生变化了。</p> <p><strong>数组新增元素的侦测</strong></p> <p>如果向数组里新增一个元素的话，我们可以也需要将新增的这个元素转化成可侦测的响应式数据。</p> <p>这个实现起来也很容易，我们只需要拿到新增的这个元素，然后调用<code>observe</code>函数将其转化即可。我们知道，可以向数组内新增元素的方法有 3 个，分别是：<code>push</code>、<code>unshift</code>、<code>splice</code>。我们需对这 3 中方法分别处理，拿到新增的元素，再将其转化即可。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args   // 如果是push或unshift方法，那么传入参数就是新增的元素
        break
      case 'splice':
        inserted = args.slice(2) // 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素
        break
    }
    if (inserted) ob.observeArray(inserted) // 调用observe函数将新增的元素转化成响应式
    // notify change
    ob.dep.notify()
    return result
  })
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>在上面拦截器定义代码中，如果是<code>push</code>或<code>unshift</code>方法，那么传入参数就是新增的元素；如果<code>splice</code>方法，那么传入参数列表中下标为 2 的就是新增的元素，拿到新增的元素后，就可以<code>observe</code>函数将新增的元素转化成响应的了。</p> <p><strong>深度侦测</strong></p> <p>在<code>Vue</code>中，不论是<code>Object</code>型数组据还是<code>Array</code>型数据所实现的数据变化侦测都是深度侦测，所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。举个例子：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let arr = [{
    name:'NLRX',
    age:'18'
}]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>数组中包含了一个对象，如果该对象的某个属性发生了变化也应该被侦测到，这就是深度侦测。</p> <p>对于<code>Array</code>型数据，调用了<code>observeArray()</code>方法，该方法内部会遍历数组中的每一个元素，然后通过调用<code>observe</code>函数将每一个元素都转化成可侦测的响应式数据。</p> <p><strong>不足之处</strong></p> <p>对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let arr = [1,2,3]
arr[0] = 5;       // 通过数组下标修改数组中的数据
arr.length = 0    // 通过修改数组长度清空数组
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>而使用上述鸽子中的操作方式来修改数组是无法侦测到的。同样，<code>Vue</code>也注意到了这个问题，为了解决这一问题，<code>Vue</code>增加了两个全局 API：<code>Vue.set</code>和<code>Vue.delete</code>。</p> <h4 id="_2-3-变化侦测的-api-实现"><a href="#_2-3-变化侦测的-api-实现" class="header-anchor">#</a> 2.3 变化侦测的 API 实现</h4> <ul><li><code>vm.$watch</code></li> <li><code>vm.$set</code></li> <li><code>vm.$delete</code></li></ul> <p><strong><code>vm.$watch</code></strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$watch(expOrFn, callback, [options]);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>参数：
<ul><li><code>{string | Function} expOrFn</code></li> <li><code>{Function | Object} callback</code></li> <li><code>{Object} [options]</code> <ul><li><code>{boolean} deep</code></li> <li><code>{boolean} immediate</code></li></ul></li></ul></li> <li>返回值：<code>{Function} unwatch</code></li> <li>用法：</li></ul> <p>观察<code>Vue</code>实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。</p> <p>注意：在变异（不是替换）对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。<code>Vue</code>不会保留变异之前值的副本。</p> <ul><li>示例：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>//  键路径
vm.$watch(&quot;a.b.c&quot;,function(newVal,oldVal){
    // 做点什么
})

// 函数
vm.$watch(
  function() {
    // 表达式 `this.a + this.b` 每次得出一个不同的结果时
    // 处理函数都会被调用。
    // 这就像监听一个未被定义的计算属性
    return this.a + this.b;
  },
  function(newVal, oldVal) {
    // 做点什么
  }
);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><code>vm.$watch</code>返回一个取消观察函数，用来停止触发回调</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var unwatch = vm.$watch(&quot;a&quot;, cb);
// 之后取消观察
unwatch();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>选项：deep</li></ul> <p>为了发现对象内部值的变化，可以在选项参数中指定<code>deep:true</code>。注意监听数组的变动不需要这么做。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$watch(&quot;someObject&quot;, callback, {
  deep: true
});
vm.someObject.nestedValue = 123;
// callback is fired
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>选项：immediate</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$watch(&quot;a&quot;, callback, {
  immediate: true
});
// 立即以 `a` 的当前值触发回调
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>内部原理</li></ul> <p><code>$watch</code>的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$watch = function (expOrFn,cb,options) {
    const vm: Component = this
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {}
    options.user = true
    const watcher = new Watcher(vm, expOrFn, cb, options)
    if (options.immediate) {
      try {
        cb.call(vm, watcher.value)
      } catch (error) {
        handleError(error, vm, `callback for immediate watcher &quot;${watcher.expression}&quot;`)
      }
    }
    return function unwatchFn () {
      watcher.teardown()
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>在函数内部，首先判断传入的回调函数是否为一个对象，如果传入的回调函数是个对象，那就表明用户是把第二个参数回调函数<code>cb</code>和第三个参数选项<code>options</code>合起来传入的，此时调用<code>createWatcher</code>函数，该函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function createWatcher (vm,expOrFn,handler,options) {
  if (isPlainObject(handler)) {
    options = handler
    handler = handler.handler
  }
  if (typeof handler === 'string') {
    handler = vm[handler]
  }
  return vm.$watch(expOrFn, handler, options)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>该函数内部其实就是从用户合起来传入的对象中把回调函数<code>cb</code>和参数<code>options</code>剥离出来，然后再以常规的方式调用<code>$watch</code>方法并将剥离出来的参数传进去。</p> <p>接着获取到用户传入的<code>options</code>，如果用户没有传入则将其赋值为一个默认空对象，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>options = options || {};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>$watch</code>方法内部会创建一个<code>watcher</code>实例，由于该实例是用户手动调用<code>$watch</code>方法创建而来的，所以给<code>options</code>添加<code>user</code>属性并赋值为<code>true</code>，用于区分用户创建的<code>watcher</code>实例和<code>Vue</code>内部创建的<code>watcher</code>实例，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>options.user = true;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着，传入参数创建一个 watcher 实例，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const watcher = new Watcher(vm, expOrFn, cb, options);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着判断如果用户在选项参数<code>options</code> 中指定的<code>immediate</code> 为<code>true</code>，则立即用被观察数据当前的值触发回调，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (options.immediate) {
  cb.call(vm, watcher.value);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>最后返回一个取消观察函数<code>unwatchFn</code>，用来停止触发回调。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>return function unwatchFn() {
  watcher.teardown();
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个取消观察<code>unwatchFn</code>内部其实是调用了<code>watcher</code>实例的<code>teardown</code>方法，那和我们来看一下这个<code>teardown</code>方法是如何实现的。其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default class Watcher {
  constructor(/* ... */) {
    // ...
    this.deps = [];
  }
  teardown() {
    let i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>创建<code>watcher</code>实例的时候会读取被观察的数据，读取了数据就表示依赖了数据，所以<code>watcher</code>实例就会存在于数据的依赖列表中，同时<code>watcher</code>实例也记录了自己依赖了哪些数据，另外我们还说过，每个数据都有一个自己的依赖管理器<code>dep</code>，<code>watcher</code>实例记录自己依赖了哪些数据其实就是把数据的依赖管理器<code>dep</code>存放在<code>watcher</code>实例的<code>this.deps=[]</code>属性中，当取消观察时即<code>watcher</code>实例不想依赖这些数据了，那么就遍历自己记录的这些数据的依赖管理器，告诉这些数据可以从你们依赖列表中把我删除了。</p> <p>当选项参数<code>options</code>中的<code>deep</code>属性为<code>true</code>时，如何实现深度观察呢？</p> <p>要实现这个功能也不难，我们知道，要想让数据变化时通知我们，那我们只需成为这个数据的依赖即可，因为数据变化时会通知它所有的依赖，那么如何成为数据的依赖呢，很简单，读取一下数据即可。也就是说我们只需在创建<code>watcher</code>实例的时候把<code>obj</code>对象内部所有的值都递归的读一遍，那么这个<code>watcher</code>实例就会被加入到对象内所有值的依赖列表中，之后当对象内任意某个值发生变化时就能够得到通知了。</p> <p><code>traverse</code>函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const seenObjects = new Set();

export function traverse(val: any) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse(val: any, seen: SimpleSet) {
  let i, keys;
  const isA = Array.isArray(val);
  if (
    (!isA &amp;&amp; !isObject(val)) ||
    Object.isFrozen(val) ||
    val instanceof VNode
  ) {
    return;
  }
  if (val.__ob__) {
    const depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) _traverse(val[i], seen);
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) _traverse(val[keys[i]], seen);
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>该函数其实就是个递归遍历的过程，把被观察数据的内部值都递归遍历读取一遍。</p> <p>首先判断传入的<code>val</code>类型，如果它不是<code>Array</code>或<code>Object</code>，再或者已经被冻结，那么直接返回，退出程序。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const isA = Array.isArray(val);
if ((!isA &amp;&amp; !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
  return;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>然后拿到<code>val</code>的<code>dep.id</code>，存入创建好的集合<code>seen</code>中，因为集合相比数据而言它有天然的去重效果，以此来保证存入的<code>dep.id</code>没有重复，不会造成重复收集依赖，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (val.__ob__) {
  const depId = val.__ob__.dep.id;
  if (seen.has(depId)) {
    return;
  }
  seen.add(depId);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>接下来判断如果是数组，则循环数组，将数组中每一项递归调用<code>_traverse</code>；如果是对象，则取出对象所有的<code>key</code>，然后执行读取操作，再递归内部值，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (isA) {
  i = val.length;
  while (i--) _traverse(val[i], seen);
} else {
  keys = Object.keys(val);
  i = keys.length;
  while (i--) _traverse(val[keys[i]], seen);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这样，把被观察数据内部所有的值都递归的读取一遍后，那么这个<code>watcher</code>实例就会被加入到对象内所有值的依赖列表中，之后当对象内任意某个值发生变化时就能够得到通知了。</p> <p><strong><code>vm.$set</code></strong></p> <p><code>vm.$set</code>是全局<code>Vue.set</code>的<strong>别名</strong>，其用法相同。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$set(target, propertyName / index, value);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p>参数：</p> <ul><li><code>{Object | Array} target</code></li></ul></li> <li><p>返回值：设置的值</p></li> <li><p>用法：向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为<code>Vue</code>无法探测普通的新增属性。</p></li> <li><p>内部原理</p></li></ul> <p>对于<code>object</code>型数据，当我们向<code>object</code>数据里添加一对新的<code>key/value</code>或删除一对已有的<code>key/value</code>时，<code>vue</code>是无法观测到的；而对于<code>Array</code>弄数据，当我们通过数组下标个性数组中的数据时，<code>Vue</code>也是无法观测到的</p> <p>正是因为存在这个问题，所以<code>Vue</code>设计了<code>set</code>和<code>delete</code>这两个方法来解决这一问题；</p> <p><code>set</code>方法的定义位于源码的<code>src/core/observer/index.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  if (key in target &amp;&amp; !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob &amp;&amp; ob.vmCount)) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }
  if (!ob) {
    target[key] = val
    return val
  }
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>首先判断在非生产环境下如果传入的<code>target</code>是否为<code>undefined</code>、<code>null</code>或是原始类型，如果是原始类型，如果是，则抛出警告，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (process.env.NODE_ENV !== 'production' &amp;&amp;
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接着判断如果传入的<code>target</code>是数组并且传入的<code>key</code>是有效索引的话，那么就取当前数组长度与<code>key</code>这两者的最大值作为数组的新长度，然后使用数组的<code>splice</code>方法将传入的索引<code>key</code>对应的<code>val</code>值添加进数组。这里注意一点，为什么要用<code>splice</code>方法呢？数组的<code>splice</code>方法已经被我们创建的拦截器重写了，也就是说，当使用<code>splice</code>方法向数组内添加元素时，该元素会自动被变成响应式的。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果传入的<code>target</code>不是数组，那就当做对象来处理。</p> <p>首先判断传入的<code>key</code>是否已经存在于<code>target</code>中，如果存在，表明这次操作不是新增属性，而对已有的属性进行简单的修改值，那么就只修改属性值即可，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (key in target &amp;&amp; !(key in Object.prototype)) {
  target[key] = val;
  return val;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接下来获取到<code>target</code>的<code>__ob__</code>属性，我们说过，该属性是否为<code>true</code>标志着<code>target</code>是否为响应式对象，接着判断如果<code>target</code>是<code>Vue</code>实例，或者是<code>Vue</code>实例的根数据对象，则抛出警告并退出程序，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const ob = (target: any).__ob__;
if (target._isVue || (ob &amp;&amp; ob.vmCount)) {
  process.env.NODE_ENV !== &quot;production&quot; &amp;&amp;
    warn(
      &quot;Avoid adding reactive properties to a Vue instance or its root $data &quot; +
        &quot;at runtime - declare it upfront in the data option.&quot;
    );
  return val;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>接着判断如果<code>ob</code>属性为<code>false</code>，那么表明<code>target</code>不是一个响应式对象，那么我们只需简单给它添加上新的属性，不用将新属性转化成响应式，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!ob) {
  target[key] = val;
  return val;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>最后，如果<code>target</code>是对象，并且是响应式，那么就调用<code>defineReactive</code>方法将新属性添加到<code>target</code>上，<code>defineReactive</code>方法会将新属性添加完之后并将其转化成响应式，最后通知依赖更新，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>defineReactive(ob.value, key, val);
ob.dep.notify();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>以上，就是<code>set</code>方法的内部原理。其逻辑流程图如下：</p> <p><img src="vue14.jpg" alt="images"></p> <p><strong><code>vm.$delete</code></strong></p> <p><code>vm.$delete</code>是全局<code>Vue.delete</code>的<strong>别名</strong>，其用法相同</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$delete(target, propertyName / index);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数</strong>：</p> <ul><li><code>{Object | Array} target</code></li> <li><code>{string | number} propertyName/index</code></li></ul></li> <li><p><strong>用法</strong>：</p></li></ul> <p>删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开<code>Vue</code>不检测到属性被删除的限制，但是你应该很少会使用它。</p> <ul><li><strong>内部原理</strong>：</li></ul> <p><code>delete</code>方法是用来解决<code>Vue</code>不能检测到属性被删除的限制，该方法的定义位于源码的<code>src/core/observer/index.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function del (target: Array&lt;any&gt; | Object, key: any) {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot delete reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    target.splice(key, 1)
    return
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob &amp;&amp; ob.vmCount)) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    )
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key]
  if (!ob) {
    return
  }
  ob.dep.notify()
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>该方法的内部原理与<code>set</code>方法有几分相似。</p> <p>首先判断在非生产环境下如果传入的<code>target</code>不存在，或者<code>target</code>是原始值，则抛出警告，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> if (process.env.NODE_ENV !== 'production' &amp;&amp;
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot delete reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接着判断如果传入的<code>target</code>是数组并且传入的<code>key</code>是有效索引的话，就使用数组的<code>splice</code>方法将索引<code>key</code>对应的值删掉，数组的<code>splice</code>方法已经被我们创建的拦截器重写了，所以使用该方法会自动通知相关依赖。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    target.splice(key, 1)
    return
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果传入的<code>target</code>不是数组，那就当做对象来处理</p> <p>接下来获取到<code>target</code>的<code>__ob__</code>属性，该属性是否为<code>true</code>标志着<code>target</code>是否为响应式对象，接着判断如果<code>target</code>是<code>Vue</code>实例，或者是<code>Vue</code>实例的根数据对象，则抛出警告并退出程序，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const ob = (target: any).__ob__;
if (target._isVue || (ob &amp;&amp; ob.vmCount)) {
  process.env.NODE_ENV !== &quot;production&quot; &amp;&amp;
    warn(
      &quot;Avoid adding reactive properties to a Vue instance or its root $data &quot; +
        &quot;at runtime - declare it upfront in the data option.&quot;
    );
  return val;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>接着判断传入的<code>key</code>是否存在于<code>target</code>中，如果<code>key</code>本来就不存在于<code>target</code>中，那就不用删除，直接退出程序即可，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!hasOwn(target, key)) {
  return;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>最后，如果<code>target</code>是对象，并且传入的<code>key</code>也存在于<code>target</code>中，那么就从<code>target</code>中将该属性删除，同时判断当前的<code>target</code>是否为响应式对象，如果是响应式对象，则通知依赖更新；如果不是，删除完后直接返回不通知更新，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>delete target[key];
if (!ob) {
  return;
}
ob.dep.notify();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="三、虚拟-dom-篇"><a href="#三、虚拟-dom-篇" class="header-anchor">#</a> 三、虚拟 DOM 篇</h3> <p>参考<a href="https://km.xiaowuzi.info/js/vue-dom.html" target="_blank" rel="noopener noreferrer">Vue 虚拟 DOM<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="四、模板编译篇"><a href="#四、模板编译篇" class="header-anchor">#</a> 四、模板编译篇</h3> <ul><li>整体运行流程</li> <li>HTML 解析器</li> <li>文本解析器</li> <li>优化阶段</li> <li>代码生成阶段</li></ul> <p>我们知道，在日常开发中，我们把写在<code>&lt;template&gt;&lt;/template&gt;</code>标签中的类似于原生<code>HTML</code>的内容称之为模板。这时你可能会问了，为什么说是“类似于原生<code>HTML</code>的内容”而不是“就是<code>HTML</code>的内容”？因为我们在开发中，在<code>&lt;template&gt;&lt;/template&gt;</code>标签中除了写一些原生<code>HTML</code>的标签，我们还会写一些亦是插值，如或者写一些<code>Vue</code>指令，如<code>v-on</code>、<code>v-if</code>等。而这些东西都是在原生<code>HTML</code>语法中不存在的，不被接受的。但事实上我们确实这么写了，也被正确识别了，页面也正常显示了，这又是为什么呢？</p> <p>这就归功于<code>Vue</code>的模板编译了，<code>Vue</code>会把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理生成渲染函数，也就是<code>render</code>函数，而<code>redner</code>函数会将模板内容生成对应的<code>VNode</code>，而<code>VNode</code>再经过<code>patch</code>过程从而得到将要渲染的视图中的<code>VNode</code>，最后根据<code>VNode</code>创建真实的<code>DOM</code>节点并插入到视图中，最终完成视图的渲染更新。</p> <p>而把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理成渲染函数，也就是<code>render</code>函数的这一段过程称之为模板编译过程。</p> <h4 id="_4-1-整体渲染流程"><a href="#_4-1-整体渲染流程" class="header-anchor">#</a> 4.1 整体渲染流程</h4> <p>所谓渲染流程，就是把用户写的类似原生<code>HTML</code>的模板经过一系列处理最终反应到视图中称之为整个渲染流程。这个流程在上文中其实已经说到了，下面我们以流程图的形式宏观的了解一下，流程图如下：</p> <p><img src="vue-code01.png" alt="images"></p> <p>从图中我们也可以看到，模板编译过程就是把用户写的模板经过一系列处理最终生成<code>render</code>函数的过程。</p> <p>将一堆字符串模板解析成抽象语法树<code>AST</code>后，我们就可以对其进行各种操作处理了，处理完后用处理后的<code>AST</code>来生成<code>render</code>函数。其具体流程可大致分为三个阶段：</p> <ol><li>模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树<code>AST</code>；</li> <li>优化阶段：遍历<code>AST</code>，找出其中的静态节点，并打上标记；</li> <li>代码生成阶段：将<code>AST</code>转换成渲染函数；</li></ol> <p>这三个阶段在源码中分别对应三个模块，下面给出三个模块的源代码在源码中的路径：</p> <ol><li>模板解析段——解析器——源码路径：<code>src/compiler/parser/index.js</code></li> <li>优化阶段——优化器——源码路径：<code>src/compiler/optimizer.js</code></li> <li>代码生成阶段——代码生成器——源码路径：<code>src/compiler/codegen/index.js</code></li></ol> <p>其对应的源码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 源码位置：/src/complier/index.js

export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>可以看到<code>baseCompile</code>的代码非常的简短主要核心代码。</p> <ul><li><strong>const ast = parse(template.trim(),options)</strong>：<code>parse</code>会用与此同时等方式解析<code>template</code>模板中的指令、<code>class</code>、<code>style</code>等数据，形成<code>AST</code>。</li> <li><strong>optimize(ast,options)</strong>：<code>optimize</code>的主要作用是标记静态节点，这是<code>Vue</code>在编译过程中的一处优化，档在进行<code>patch</code>的过程中，<code>DOM-Diff</code>算法会直接跳过静态节点，从而减少了比较的过程，优化了<code>patch</code>的性能。</li> <li><strong>const code = generate(ast,options)</strong>：将<code>AST</code>转化成<code>render</code>函数字符串的过程，得到结果是<code>render</code>函数的字符串以及<code>staticRenderFns</code>字符串。</li></ul> <p>最终<code>baseCompile</code>的返回值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    ast:ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>最终返回了抽象语法树(ast)，渲染函数(render)，静态渲染函数(staticRenderFns)，且<code>render</code>的值为<code>code.render</code>，<code>staticRendreFns</code>的值为<code>code.staticRenderFns</code>，也就是说通过<code>generate</code>处理<code>ast</code>之后得到的返回值<code>code</code>是一个对象。</p> <p>流程图如下：</p> <p><img src="vue13.png" alt="images"></p> <h4 id="_4-2-整体运行流程"><a href="#_4-2-整体运行流程" class="header-anchor">#</a> 4.2 整体运行流程</h4> <p>在模板解析阶段主要做的工作是把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签内写的模板使用正则等方式解析成抽象语法树（<code>AST</code>）。而这一阶段在源码中对应解析器（<code>parser</code>）模块。</p> <p>解析器，顾名思义，就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成<code>AST</code>。我们知道在<code>&lt;template&gt;&lt;/template&gt;</code>模板内，除了有常规的<code>HTML</code>标签外，用户还会一些文本信息以及在文本信息中包含过滤器。而这些不同的内容在解析起来肯定需要不同的解析规则，所以解析器不可能只有一个，它应该除了有解析常规<code>HTML</code>的 HTML 解析器，还应该有解析文本的文本解析器以及解析文本如果包含过滤器的过滤器解析器。</p> <p>文本信息和标签属性信息却又是存在于 HTML 标签之内的，所以在解析整个模板的时候它的流程应该是这样子的</p> <p><strong>回到源码</strong></p> <p>解析器的源码位于<code>/src/complier/parser</code>文件夹下，其主线代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 代码位置：/src/complier/parser/index.js

export function parse(template, options) {
   // ...
  parseHTML(template, {
    warn,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    start (tag, attrs, unary) {

    },
    end () {

    },
    chars (text: string) {

    },
    comment (text: string) {

    }
  })
  return root
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p><code>parse</code>函数就是解析器的主函数，在<code>parse</code>函数内调用了<code>parseHTML</code>函数对象模板字符串进行解析，在<code>parseHTML</code>函数解析模板字符串的过程中，如果遇到广西信息，就会调用文本解析器<code>parseText</code>函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器<code>parseFilters</code>函数进行解析。</p> <p><strong>总结</strong></p> <p>模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为 HTML 解析器，文本解析器和过滤器解析器。而文本信息与过滤器信息又存在于 HTML 标签中，所以在解析器主线函数<code>parse</code>中先调用 HTML 解析器<code>parseHTML</code>函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析。</p> <h4 id="_4-3-html-解析器"><a href="#_4-3-html-解析器" class="header-anchor">#</a> 4.3 HTML 解析器</h4> <p><strong>HTML 解析器内部运行流程</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//  代码位置：/src/complier/parser/index.js

/**
 *  Convert HTML string to AST.
 *  将HTML模板字符串转化为AST
 */
export function parse(template,options){
    // ...
    parseHTML(template,{
        warn,
        expectHTML: options.expectHTML,
        isUnaryTag: options.isUnaryTag,
        canBeLeftOpenTag: options.canBeLeftOpenTag,
        shouldDecodeNewlines: options.shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
        shouldKeepComment: options.comments,
        // 当解析到开始标签时，调用该函数
        start(tag,attrs,unary){

        },
        // 当解析到结束标签时，调用该函数
        end(){

        },
        // 当解析到文本时，调用该函数
        chars(text){

        },
        // 当解析到注释时，调用该函数
        comment(text){

        }
    })
    return root
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>从代码中我们可以看到，调用<code>parseHTML</code>函数时为其传入的两个参数分别是：</p> <ul><li>template 待转换的模板字符串；</li> <li>options 转换时所需的选项；</li></ul> <p>第一个参数是待转换的模板字符串，无需多言；重点看第二个参数，第二个参数提供了一些解析<code>HTML</code>模板时的一些参数，同时还定义了 4 个钩子函数。我们说了模板编译阶段主线函数<code>parse</code>会将<code>HTML</code>模板字符串转化成<code>AST</code>，而<code>parseHTML</code>是用来解析模板字符串的，把模板字符串中不同的内容解释出来之后，然后使用这个 4 个钩子函数提取出来的内容生成对应的<code>AST</code>。</p> <p>把这 4 个钩子函数作为参数会给解析器<code>parseHTML</code>，当解析器解析出不同的内容时调用不同的钩子函数从而生成不同的<code>AST</code>。</p> <ul><li>当解析到开始标签时调用<code>start</code>函数生成元素类型的<code>AST</code>节点，代码如下；</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 当解析到标签的开始位置时，触发start
start (tag, attrs, unary, start, end) {
    let element = crateASTElement(tag,atrrs,currentParent)
}

export function crateASTElement(tag,attrs,parent){
    return {
        type: 1,
        tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        rawAttrsMap: {},
        parent,
        children: []
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>从上面代码中我们可以看到，<code>start</code>函数接收五个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>、开始<code>start</code>、结束<code>end</code>。当调用该钩子函数时，内部会调用<code>createASTElement</code>函数来创建元素类型的<code>AST</code>节点</p> <ul><li>当解析到结束标签时调用<code>end</code>函数；</li> <li>当解析到文本调用<code>chars</code>函数生成文本类型的<code>AST</code>节点；</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 当解析到标签的文本时，触发chars
chars (text, start, end) {
      if (!currentParent) {
        if (process.env.NODE_ENV !== 'production') {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.',
              { start }
            )
          } else if ((text = text.trim())) {
            warnOnce(
              `text &quot;${text}&quot; outside root element will be ignored.`,
              { start }
            )
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &amp;&amp;
        currentParent.tag === 'textarea' &amp;&amp;
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      const children = currentParent.children
      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text)
      } else if (!children.length) {
        text = ''
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          text = lineBreakRE.test(text) ? '' : ' '
        } else {
          text = ' '
        }
      } else {
        text = preserveWhitespace ? ' ' : ''
      }
      if (text) {
        if (!inPre &amp;&amp; whitespaceOption === 'condense') {
          text = text.replace(whitespaceRE, ' ')
        }
        let res
        let child: ?ASTNode
        if (!inVPre &amp;&amp; text !== ' ' &amp;&amp; (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text
          }
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text
          }
        }
        if (child) {
          if (process.env.NODE_ENV !== 'production' &amp;&amp; options.outputSourceRange) {
            child.start = start
            child.end = end
          }
          children.push(child)
        }
      }
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br></div></div><p>当解析到标签的文本时，触发<code>charts</code>钩子函数，在该钩子函数内部，首先会判断文本是不是一个带变量的动态文本，如“hello”。如果是动态文本，则创建动态文本类型的<code>AST</code>节点；如果不是动态文本，则创建纯静态文本类型的<code>AST</code>节点。</p> <ul><li>当解析到注释时调用<code>comment</code>函数生成注释类型的<code>AST</code>节点；</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 当解析到标签的注释时，触发comment
comment (text: string) {
  let element = {
    type: 3,
    text,
    isComment: true
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>当解析到标签的注释时，触发<code>comment</code>钩子函数，该钩子函数会创建一个注释类型的<code>AST</code>节点。</p> <p>一边解析不同的内容一边调用对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>，这就是<code>HTML</code>解析器所要做的工作。</p> <p><strong>如何解析不同的内容</strong></p> <p>要从模板字符串中解析出不同的内容，那</p> <ul><li>文本，例如“难凉热血”</li> <li>HTML 注释，例如<code>&lt;!--我是注释--&gt;</code></li> <li>条件注释，例如<code>&lt;!--[if !IE] --&gt;我是注释&lt;![endif]--&gt;</code></li> <li>DOCTYPE，例如<code>&lt;!DOCTYPE html&gt;</code></li> <li>开始标签，例如<code>&lt;div&gt;</code></li> <li>结束标签，例如<code>&lt;/div&gt;</code></li></ul> <p>这几种内容都有其各自独有的特点，也就是说我们要根据不同内容所具有的不同的特点通过编写不同的表达式将这些内容从模板字符串中一一解析出来，然后再把不同的内容做不同的处理。</p> <p><strong>解析 HTML 注释</strong></p> <p>解析注释比较简单，我们知道<code>HTML</code>注释是以<code>&lt;!--</code>开头，以<code>--&gt;</code>结尾，这两者中间的内容，那么我们只需用正则判断待解析的模板字符串<code>html</code>是否以<code>&lt;!--</code>开头，若是，那就继续向后寻找<code>--&gt;</code>，如果找到了，OK，溈就解析出来了。代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const comment = /^&lt;!\--/
if(comment.test(html)){
    // 若为注释，则继续查找是否存在'--&gt;'
    const commentEnd = html.indexOf('--&gt;')

    if(commentEnd &gt;= 0){
        // 若存在 '--&gt;'，继续判断options中是否保留注释
        if(options.shouldKeepComment){
            // 若保留注释，则把注释截取出来给options.comment，创建溈类型的AST节点
            options.comment(html,substring(4,commentEnd) index, index + commentEnd + 3)
        }
        // 若不保留注释，则将游标移动到'--&gt;'之后，继续向后解析
        advance(commentEnd+3)
        continue
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>如果模板字符串<code>html</code>符合注释开始的正则，那么就继续向后查找是否存在<code>--&gt;</code>，若存在，则把<code>html</code>从第 4 位（<code>&quot;&lt;!--&quot;</code>长度为 4）开始截取，直到<code>--&gt;</code>处，截取得到的内容就是注释的真实内容，然后调用 4 个钩子函数中的 comment 函数，将真实的注释内容传进去，创建注释类型的 AST 节点。</p> <p>在上面代码中，如果模板字符串<code>html</code>符合注释开始的正则，那么就继续向后查找是否存在<code>--&gt;</code>，若存在，则把<code>html</code>从第 4 位（<code>&quot;&lt;!--&quot;</code>长度为 4）开始截取，直到<code>--&gt;</code>处，截取得到的内容就是注释的真实内容，然后调用 4 个钩子函数中的<code>comment</code>函数，将真实的注释内容传进去，创建溈类型的<code>AST</code>节点。</p> <p>上面代码中有一处值得注意的地方，那就是我们平常在模板中可以在<code>&lt;template&gt;&lt;/template&gt;</code>标签上配置<code>comments</code></p> <p><code>advance</code>函数是用来移动解析游标的，解析完一部分就把游标向后移动一部分，确保不会重复解析，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function advance(n){
    index +=n       // index为解析游标
    html = html.substring(n)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>为了更加直观地说明<code>advance</code>的作用，请看下图：</p> <p><img src="vue15.png" alt="images"></p> <p>调用<code>advance</code>函数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>advance(3)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>得到结果：</p> <p><img src="vue16.png" alt="images"></p> <p>从图中可以看到，解析游标<code>index</code>最开始在模板字符串的位置 0 处，当调用了<code>advance(3)</code>之后，解析游标到了位置 3 处，每次解析完一段内容就将游标向后移动一段，接着再从解析游标往后解析，这样就保证了解析过的内容不会被重复解析。</p> <p><strong>解析条件注释</strong></p> <p>解析条件注释也比较简单，其原理跟解析注释相同，都是先用与正则判断是否是以条件注释特有的开头标识开始，然后寻找其特有的结束标识，若找到，则说明是条件注释，将其截取出来即可，由于条件注释不存在于真正的<code>DOM</code>树中，所以不需要调用钩子函数创建<code>AST</code>节点。代码如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 解析是否是条件注释
const conditionalComment = /^&lt;!\[/
if(conditionalComment.test(html)){
    // 若为条件注释，则继续查找是否存在']&gt;'
    const conditionalEnd = html.indexOf(']&gt;')

    if(conditionalEnd &gt;=0){
        // 若存在  ']&gt;',则从原本的html字符串中把条件注释裁掉
        // 把剩下的内容重新赋给html，继续向后匹配
        advance(conditionalEnd+2)
        continue
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>解析 DOCTYPE</strong></p> <p>解析<code>DOCTYPE</code>的原理同解析条件注释完全相同，此处不再赘述，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const doctype = /^&lt;!DOCTYPE [^&gt;]+&gt;/i
// 解析是否是DOCTYPE
const doctypeMatch  = html.match(doctype)
if (doctypeMatch) {
  advance(doctypeMatch[0].length)
  continue
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>解析开始标签</strong></p> <p>相较于前三种内容的解析，解析开始标签会稍微复杂一点，但是万变不离其宗，它的原理还是想通的，都是使用正则去匹配提取。</p> <p>首先使用开始标签的正则去匹配模板字符串，看模板字符串是否具有开始标签的特征，如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/**
 *  匹配开始标签的正则
 */
const ncname = '[a-zA-Z_][\\w\\-\\.]*';
const qnameCapture = `((?:${ncname}\\:)?${ncname})`
const startTagOpen = new RegExp(`^&lt;${qnameCapture}`)

const start = html.match(startTagOpen)
if(start){
    const match = {
    tagName: start[1],
    attrs: [],
    start: index
  }
}

// 以开始标签开始的模板：
'&lt;div&gt;&lt;/div&gt;'.match(startTagOpen)  =&gt; ['&lt;div','div',index:0,input:'&lt;div&gt;&lt;/div&gt;']
// 以结束标签开始的模板：
'&lt;/div&gt;&lt;div&gt;&lt;/div&gt;'.match(startTagOpen) =&gt; null
// 以文本开始的模板：
'我是文本&lt;/p&gt;'.match(startTagOpen) =&gt; null
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>当解析到开始标签时，会调用 4 个钩子函数中的<code>start</code>函数，而<code>start</code>函数需要传递 5 个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>、开始位置<code>start</code>、结束位置<code>end</code>。标签名通过与此同时的结果就可以拿到，即上面代码中的<code>start[1]</code>，而标签属性<code>attrs</code>以及标签是否自闭合<code>unary</code>需要进行一步解析。</p> <ol><li>解析标签属性</li></ol> <p>我们知道，标签属性一般是写在开始标签的标签名之后的，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>另外，我们在上面匹配是否开始标签正则中已经可以拿到开始标签的标签名，即上面代码中的<code>start[0]</code>，那么我们可以将这一部分先从模板字符串裁掉，则剩下的部分如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>我们只需用剩下的这部分去匹配标签属性的正则，就可以将标签属性提取出来了，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const attribute = /^\s*([^\s&quot;'&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|'([^']*)'+|([^\s&quot;'=&lt;&gt;`]+)))?/
let html = 'class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;'
let attr = html.match(attribute)
console.log(attr)
// [&quot;class=&quot;a&quot;&quot;, &quot;class&quot;, &quot;=&quot;, &quot;a&quot;, undefined, undefined, index: 0, input: &quot;class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;&quot;, groups: undefined]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可以看到，第一个标签属性<code>class=&quot;a&quot;</code>已经被拿到了。另外，标签属性有可能有多个也有可能没有，如果没有的话那好办，匹配标签属性的正则就会匹配失败，标签属性就为空数组；而如果标签属性有多个的话，那就需要循环匹配了，匹配出第一个标签属性后，就把该属性裁掉，用剩下的字符串继续匹配，走到不再满足正则为止，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const attribute = /^\s*([^\s&quot;'&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|'([^']*)'+|([^\s&quot;'=&lt;&gt;`]+)))?/
const startTagClose = /^\s*(\/?)&gt;/
const match = {
 tagName: start[1],
 attrs: [],
 start: index
}
 while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
 advance(attr[0].length)
 match.attrs.push(attr)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上面代码的<code>while</code>循环中，如果剩下的字符串不符合开始标签的结束特征（startTagClose）并且符合标签属性的特征的话，那就说明还有未提取出的标签属性，那就进入循环，继续提取，直到把所有标签属性都提取完毕。</p> <p>所谓不符合开始标签的结束特征是指当前剩下的字符串不是以开始标签结束符开头的，我们知道一个开始标签的结束符有可能是一个<code>&gt;</code>（非自闭合标签），也有可能是<code>/&gt;</code>（自闭合标签），如果剩下的字符串（如<code>&gt;&lt;/div&gt;</code>）以开始标签的结束符开头，那么就表示标签属性已经被提取完毕了。</p> <ol start="2"><li>解析标签是否是自闭合</li></ol> <p>在<code>HTML</code>中，有自闭合标签（如<code>&lt;img src=&quot;&quot; /&gt;</code>）也有非自闭合标签（如<code>&lt;div&gt;&lt;/div&gt;</code>），这两种类型的标签在创建<code>AST</code>节点是处理方式是有区别的，所以我们需要解析出当前标签是否自闭合标签。</p> <p>解析的方式很简单，我们知道，经过标签属性提取之后，那么剩下的字符串无非就两种，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!--非自闭合标签--&gt;
&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>或</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!--自闭合标签--&gt;
/&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>所以我们可以用剩下的字符串去切尔西开始标签结束符正则，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const startTagClose = /^\s*(\/?)&gt;/
let end = html.match(startTagClose)
'&gt;&lt;/div&gt;'.match(startTagClose) // [&quot;&gt;&quot;, &quot;&quot;, index: 0, input: &quot;&gt;&lt;/div&gt;&quot;, groups: undefined]
'/&gt;'.match(startTagClose) // [&quot;/&gt;&quot;, &quot;/&quot;, index: 0, input: &quot;/&gt;&lt;div&gt;&lt;/div&gt;&quot;, groups: undefined]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>可以看到，非自闭合标签匹配结果中的<code>end[1]</code>为<code>&quot;&quot;</code>，而自闭合标签匹配结果中的<code>end[1]</code>为<code>&quot;/&quot;</code>。所以根据匹配结果的<code>end[1]</code>是否是<code>&quot;&quot;</code>我们即可判断出当前标签是否为自闭合标签，源码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const startTagClose = /^\s*(\/?)&gt;/
let end = html.match(startTagClose)
if (end) {
 match.unarySlash = end[1]
 advance(end[0].length)
 match.end = index
 return match
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>解析完毕后，就可以用解析得到的结果去调用<code>start</code>钩子函数去创建元素型的<code>AST</code>节点了。</p> <p><code>Vue</code>并没有直接去调<code>start</code>钩子函数去创建<code>AST</code>节点，而是调用了<code>handleStartTag</code>函数，在该函数内部才去调用的<code>start</code>钩子函数，这是因为虽然经过<code>parseStartTag</code>函数已经把创建<code>AST</code>节点必要信息提出来了，但是提取出来的标签属性数组还是需要处理一下。<code>handleStartTag</code>函数源码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function handleStartTag (match) {
    const tagName = match.tagName
    const unarySlash = match.unarySlash

    if (expectHTML) {
      // ...
    }

    const unary = isUnaryTag(tagName) || !!unarySlash

    const l = match.attrs.length
    const attrs = new Array(l)
    for (let i = 0; i &lt; l; i++) {
      const args = match.attrs[i]
      const value = args[3] || args[4] || args[5] || ''
      const shouldDecodeNewlines = tagName === 'a' &amp;&amp; args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      }
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs })
      lastTag = tagName
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end)
    }
  }

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p><code>handleStartTag</code>函数用来对<code>parseStartTag</code>函数的解析结果进行进一步处理，它接收<code>parseStartTag</code>函数的返回值作为参数。</p> <p><code>handleStartTag</code>函数的开始定义几个常量：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const tagName = match.tagName       // 开始标签的标签名
const unarySlash = match.unarySlash  // 是否为自闭合标签的标志，自闭合为&quot;&quot;,非自闭合为&quot;/&quot;
const unary = isUnaryTag(tagName) || !!unarySlash  // 布尔值，标志是否为自闭合标签
const l = match.attrs.length    // match.attrs 数组的长度
const attrs = new Array(l)  // 一个与match.attrs数组长度相等的数组
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接下来是循环处理提取出来的标签属性数组<code>match.attrs</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (let i = 0; i &lt; l; i++) {
    const args = match.attrs[i]
    const value = args[3] || args[4] || args[5] || ''
    const shouldDecodeNewlines = tagName === 'a' &amp;&amp; args[1] === 'href'
    ? options.shouldDecodeNewlinesForHref
    : options.shouldDecodeNewlines
    attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>首先定义了 <code>args</code> 常量，它是解析出来的标签属性数组中的每一个属性对象，即 <code>match.attrs</code> 数组中每个元素对象。 它长这样：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const args = [&quot;class=&quot;a&quot;&quot;, &quot;class&quot;, &quot;=&quot;, &quot;a&quot;, undefined, undefined, index: 0, input: &quot;class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;&quot;, groups: undefined]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接下来是循环处理提取出来的标签属性数组<code>match.attrs</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (let i = 0; i &lt; l; i++) {
    const args = match.attrs[i]
    const value = args[3] || args[4] || args[5] || ''
    const shouldDecodeNewlines = tagName === 'a' &amp;&amp; args[1] === 'href'
    ? options.shouldDecodeNewlinesForHref
    : options.shouldDecodeNewlines
    attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>首先定义了<code>args</code>常量，它是解析出来的标签属性数组中的每一个属性对象，即<code>match.attrs</code>数组中每个元素对象。 它长这样：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const args = [&quot;class=&quot;a&quot;&quot;, &quot;class&quot;, &quot;=&quot;, &quot;a&quot;, undefined, undefined, index: 0, input: &quot;class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;&quot;, groups: undefined]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着定义了<code>value</code>，用于存储标签属性的属性值，我们可以看到，在代码中尝试取<code>args</code>的<code>args[3]</code>、<code>args[4]</code>、<code>args[5]</code>，如果都取不到，则给<code>value</code>复制为空</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const value = args[3] || args[4] || args[5] || ''
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着定义了<code>shouldDecodeNewlines</code>，这个常量主要是做一些兼容性处理， 如果 <code>shouldDecodeNewlines</code> 为 <code>true</code>，意味着 <code>Vue</code> 在编译模板的时候，要对属性值中的换行符或制表符做兼容处理。而<code>shouldDecodeNewlinesForHref</code> 为 <code>true</code> 意味着 <code>Vue</code>在编译模板的时候，要对 <code>a</code> 标签的 <code>href</code> 属性值中的换行符或制表符做兼容处理。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const shouldDecodeNewlines = tagName === 'a' &amp;&amp; args[1] === 'href'
    ? options.shouldDecodeNewlinesForHref
    : options.shouldDecodeNewlinesconst value = args[3] || args[4] || args[5] || ''
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>最后将处理好的结果存入之前定义好的与<code>match.attrs</code>数组长度相等的<code>attrs</code>数组中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>attrs[i] = {
    name: args[1],    // 标签属性的属性名，如class
    value: decodeAttr(value, shouldDecodeNewlines) // 标签属性的属性值，如class对应的a
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>最后，如果该标签是非自闭合标签，则将标签推入栈中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!unary) {
    stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs })
    lastTag = tagName
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果该标签是自闭标签，现在就可以调用<code>start</code>钩子函数并传入处理好的参数来创建<code>AST</code>节点了，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (options.start) {
    options.start(tagName, attrs, unary, match.start, match.end)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>解析结束标签</strong></p> <p>结束标签的解析要比解析开始标签容易多了，因为它不需要解析什么属性，只需要判断剩下的模板字符串是否符合结束标签的特征，如果是，就将结束标签名提取出来，再调用 4 个钩子函数中的<code>end</code>函数就好了。</p> <p>首先判断剩余的模板字符串是否符合结束标签的特征，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const ncname = '[a-zA-Z_][\\w\\-\\.]*'
const qnameCapture = `((?:${ncname}\\:)?${ncname})`
const endTag = new RegExp(`^&lt;\\/${qnameCapture}[^&gt;]*&gt;`)
const endTagMatch = html.match(endTag)

'&lt;/div&gt;'.match(endTag)  // [&quot;&lt;/div&gt;&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;/div&gt;&quot;, groups: undefined]
'&lt;div&gt;'.match(endTag)  // null
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果模板字符串结束标签的特征，则会获得匹配结果数组；如果不合符，则得到 null。</p> <p>接着再调用<code>end</code>钩子函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (endTagMatch) {
    const curIndex = index
    advance(endTagMatch[0].length)
    parseEndTag(endTagMatch[1], curIndex, index)
    continue
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>没有直接去调用 end 函数，而是调用了 parseEndTag 函数。</p> <p><strong>解析文本</strong></p> <p>在解析模板字符串之前，我们先查找一下第一个<code>&lt;</code>出现在什么位置，如果第一个<code>&lt;</code>在第一个位置，那么说明模板字符串是以其它 5 种类型开始的；如果第一个<code>&lt;</code>不在第一个位置而在模板字符串中某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了；如果在整个模板字符串里面没有找到<code>&lt;</code>，那说明整个模板字符串都是文本，源码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let textEnd = html.indexOf('&lt;')
// '&lt;' 在第一个位置，为其余5种类型
if (textEnd === 0) {
    // ...
}
// '&lt;' 不在第一个位置，文本开头
if (textEnd &gt;= 0) {
    // 如果html字符串不是以'&lt;'开头,说明'&lt;'前面的都是纯文本，无需处理
    // 那就把'&lt;'以后的内容拿出来赋给rest
    rest = html.slice(textEnd)
    while (
        !endTag.test(rest) &amp;&amp;
        !startTagOpen.test(rest) &amp;&amp;
        !comment.test(rest) &amp;&amp;
        !conditionalComment.test(rest)
    ) {
        // &lt; in plain text, be forgiving and treat it as text
        /**
           * 用'&lt;'以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment
           * 如果都匹配不上，表示'&lt;'是属于文本本身的内容
           */
        // 在'&lt;'之后查找是否还有'&lt;'
        next = rest.indexOf('&lt;', 1)
        // 如果没有了，表示'&lt;'后面也是文本
        if (next &lt; 0) break
        // 如果还有，表示'&lt;'是文本中的一个字符
        textEnd += next
        // 那就把next之后的内容截出来继续下一轮循环匹配
        rest = html.slice(textEnd)
    }
    // '&lt;'是结束标签的开始 ,说明从开始到'&lt;'都是文本，截取出来
    text = html.substring(0, textEnd)
    advance(textEnd)
}
// 整个模板字符串里没有找到`&lt;`,说明整个模板字符串都是文本
if (textEnd &lt; 0) {
    text = html
    html = ''
}
// 把截取出来的text转化成textAST
if (options.chars &amp;&amp; text) {
    options.chars(text)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><p>如果<code>&lt;</code> 不在第一个位置而在模板字符串间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了，接着我们还要从第一个<code>&lt;</code>的位置继续向后判断，因为还存在这样一种情况，那就是如果广西里面本来就包含一个<code>&lt;</code>，例如<code>1&lt;2&lt;/div&gt;</code>。为了处理这种情况，我们把从第一个<code>&lt;</code>的位置直到模板字符串结束都截取出来记作<code>rest</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let rest = html.slice(textEnd)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着用<code>rest</code>去匹配以上 5 种类型的正则，如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>while (
    !endTag.test(rest) &amp;&amp;
    !startTagOpen.test(rest) &amp;&amp;
    !comment.test(rest) &amp;&amp;
    !conditionalComment.test(rest)
) {

}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，接着以这个<code>&lt;</code>的位置继续向后查找，看是否还有<code>&lt;</code>，如果没有了，则表示后面的都是文本；如果后面还有下一个<code>&lt;</code>，那表明至少在这个<code>&lt;</code>到下一个<code>&lt;</code>中间的内容都是文本，至于下一个<code>&lt;</code>以后的内容是什么，则还需要重复以上的逻辑继续判断。代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>while (
    !endTag.test(rest) &amp;&amp;
    !startTagOpen.test(rest) &amp;&amp;
    !comment.test(rest) &amp;&amp;
    !conditionalComment.test(rest)
) {
    // &lt; in plain text, be forgiving and treat it as text
    /**
    * 用'&lt;'以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment
    * 如果都匹配不上，表示'&lt;'是属于文本本身的内容
    */
    // 在'&lt;'之后查找是否还有'&lt;'
    next = rest.indexOf('&lt;', 1)
    // 如果没有了，表示'&lt;'后面也是文本
    if (next &lt; 0) break
    // 如果还有，表示'&lt;'是文本中的一个字符
    textEnd += next
    // 那就把next之后的内容截出来继续下一轮循环匹配
    rest = html.slice(textEnd)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>最后截取文本内容 <code>text</code> 并调用 4 个钩子函数中的 <code>chars</code> 函数创建文本型的<code>AST</code> 节点。</p> <p><strong>如何保证 AST 节点层级关系</strong></p> <p><code>Vue</code>在<code>HTML</code>解析器的开头定义了一个栈<code>stack</code>，这个栈的作用就是用来维护<code>AST</code>节点层级的，<code>HTML</code>解析器在从前向后解析模板字符串时，每当遇到开始标签时就会调用<code>start</code>钩子函数，那么在<code>start</code>钩子函数内部我们可以将解析得到的开始标签推入栈中，而每当遇到结束标签时就会调用<code>end</code>钩子函数，那么我们也可以在<code>end</code>钩子函数内部将解析得到的结束标签所对应的开始标签从栈中弹出。</p> <p>解析器<code>parseHTML</code>函数，函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function parseHTML(html, options) {
	var stack = [];
	var expectHTML = options.expectHTML;
	var isUnaryTag$$1 = options.isUnaryTag || no;
	var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
	var index = 0;
	var last, lastTag;

	// 开启一个 while 循环，循环结束的条件是 html 为空，即 html 被 parse 完毕
	while (html) {
		last = html;
		// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)
		if (!lastTag || !isPlainTextElement(lastTag)) {
		   let textEnd = html.indexOf('&lt;')
              /**
               * 如果html字符串是以'&lt;'开头,则有以下几种可能
               * 开始标签:&lt;div&gt;
               * 结束标签:&lt;/div&gt;
               * 注释:&lt;!-- 我是注释 --&gt;
               * 条件注释:&lt;!-- [if !IE] --&gt; &lt;!-- [endif] --&gt;
               * DOCTYPE:&lt;!DOCTYPE html&gt;
               * 需要一一去匹配尝试
               */
            if (textEnd === 0) {
                // 解析是否是注释
        		if (comment.test(html)) {

                }
                // 解析是否是条件注释
                if (conditionalComment.test(html)) {

                }
                // 解析是否是DOCTYPE
                const doctypeMatch = html.match(doctype)
                if (doctypeMatch) {

                }
                // 解析是否是结束标签
                const endTagMatch = html.match(endTag)
                if (endTagMatch) {

                }
                // 匹配是否是开始标签
                const startTagMatch = parseStartTag()
                if (startTagMatch) {

                }
            }
            // 如果html字符串不是以'&lt;'开头,则解析文本类型
            let text, rest, next
            if (textEnd &gt;= 0) {

            }
            // 如果在html字符串中没有找到'&lt;'，表示这一段html字符串都是纯文本
            if (textEnd &lt; 0) {
                text = html
                html = ''
            }
            // 把截取出来的text转化成textAST
            if (options.chars &amp;&amp; text) {
                options.chars(text)
            }
		} else {
			// 父元素为script、style、textarea时，其内部的内容全部当做纯文本处理
		}

		//将整个字符串作为文本对待
		if (html === last) {
			options.chars &amp;&amp; options.chars(html);
			if (!stack.length &amp;&amp; options.warn) {
				options.warn((&quot;Mal-formatted tag at end of template: \&quot;&quot; + html + &quot;\&quot;&quot;));
			}
			break
		}
	}

	// Clean up any remaining tags
	parseEndTag();
	//parse 开始标签
	function parseStartTag() {

	}
	//处理 parseStartTag 的结果
	function handleStartTag(match) {

	}
	//parse 结束标签
	function parseEndTag(tagName, start, end) {

	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br></div></div><p>上述代码中大致分为三部分：</p> <ul><li>定义的一些常量和变量</li> <li>while 循环</li> <li>解析过程中用到的辅助函数</li></ul> <p>定义了几个常量，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const stack = []       // 维护AST节点层级的栈
const expectHTML = options.expectHTML
const isUnaryTag = options.isUnaryTag || no
const canBeLeftOpenTag = options.canBeLeftOpenTag || no   //用来检测一个标签是否是可以省略闭合标签的非自闭合标签
let index = 0   //解析游标，标识当前从何处开始解析模板字符串
let last,   // 存储剩余还未解析的模板字符串
    lastTag  // 存储着位于 stack 栈顶的元素
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>接着开启 while 循环，循环的终止条件是 模板字符串 html 为空，即模板字符串被全部编译完毕。在每次 while 循环中， 先把 html 的值赋给变量 last，如<code>last = html</code></p> <p>这样做的目的是，如果经过上述所有处理逻辑处理过后，<code>html</code>字符串没有任何变化，即表示<code>html</code>字符串没有匹配上任何一条规则，那么就把<code>html</code>字符串当作纯文本对待，创建文本类型的<code>AST</code>节点并且如果抛出异常：模板字符串中标签格式有误。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//将整个字符串作为文本对待
if (html === last) {
    options.chars &amp;&amp; options.chars(html);
    if (!stack.length &amp;&amp; options.warn) {
        options.warn((&quot;Mal-formatted tag at end of template: \&quot;&quot; + html + &quot;\&quot;&quot;));
    }
    break
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>接着，我们继续看<code>while</code>循环体内的代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>while (html) {
  // 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)
  if (!lastTag || !isPlainTextElement(lastTag)) {

  } else {
    // parse 的内容是在纯文本标签里 (script,style,textarea)
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在循环体内，首先判断了待解析的<code>html</code>字符串是否在纯文本标签里，如<code>script</code>，<code>style</code>，<code>textarea</code>，因为在这三个标签里的内容肯定不会有<code>HTML</code>标签，所以我们可直接当作文本处理，判断条件如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>!lastTag || !isPlainTextElement(lastTag)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>lastTag</code>为栈顶元素，<code>!lastTag</code>即表示当前<code>html</code>字符串没有父节点，而<code>isPlainTextElement(lastTag)</code> 是检测 <code>lastTag</code> 是否为是那三个纯文本标签之一，是的话返回<code>true</code>，不是返回<code>fasle</code></p> <p><strong>parseEndTag 函数源码</strong></p> <p>在解析结束标签时遗留的<code>parseEndTag</code>函数，该函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function parseEndTag (tagName, start, end) {
let pos, lowerCasedTagName
if (start == null) start = index
if (end == null) end = index

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase()
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos &gt;= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0
    }

    if (pos &gt;= 0) {
      // Close all the open elements, up the stack
      for (let i = stack.length - 1; i &gt;= pos; i--) {
        if (process.env.NODE_ENV !== 'production' &amp;&amp;
          (i &gt; pos || !tagName) &amp;&amp;
          options.warn
        ) {
          options.warn(
            `tag &lt;${stack[i].tag}&gt; has no matching end tag.`
          )
        }
        if (options.end) {
          options.end(stack[i].tag, start, end)
        }
      }

      // Remove the open elements from the stack
      stack.length = pos
      lastTag = pos &amp;&amp; stack[pos - 1].tag
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end)
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end)
      }
      if (options.end) {
        options.end(tagName, start, end)
      }
    }

}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br></div></div><p>该函数接收三个参数，分别是结束标签名<code>tagName</code>、结束标签在<code>html</code>字符串中的起始和结束位置<code>start</code>和<code>end</code>。</p> <p>这个三参数其实都是可选的，根据选参的不同其功能也不同。</p> <ul><li>第一种是三个参数都传递，用于处理普通的结束标签</li> <li>第二种是只传递<code>tagName</code></li> <li>第三种是三参数都不传递，用于处理栈中剩余未处理的标签</li></ul> <p><strong>总结</strong></p> <p>首先介绍了<code>HTML</code>解析器的工作流程，一句话概括就是：一边解析不同的内容一边调用对应的钩子对应</p> <h4 id="_4-4-文本解析器"><a href="#_4-4-文本解析器" class="header-anchor">#</a> 4.4 文本解析器</h4> <p>文本菜板器的源码位于<code>src/compiler/parser/text-parsre.js</code>中，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
const defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g
const buildRegex = cached(delimiters =&gt; {
const open = delimiters[0].replace(regexEscapeRE, '\\$&amp;')
  const close = delimiters[1].replace(regexEscapeRE, '\\$&amp;')
return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
})
export function parseText (text,delimiters) {
const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE
if (!tagRE.test(text)) {
return
}
const tokens = []
const rawTokens = []
/\*\*

- let lastIndex = tagRE.lastIndex = 0
- 上面这行代码等同于下面这两行代码:
- tagRE.lastIndex = 0
- let lastIndex = tagRE.lastIndex
  \*/
  let lastIndex = tagRE.lastIndex = 0
  let match, index, tokenValue
  while ((match = tagRE.exec(text))) {
  index = match.index
  // push text token
  if (index &gt; lastIndex) {
  // 先把'{{'前面的文本放入tokens中
      rawTokens.push(tokenValue = text.slice(lastIndex, index))
      tokens.push(JSON.stringify(tokenValue))
    }
    // tag token
    // 取出'{{ }}'中间的变量 exp
  const exp = parseFilters(match[1].trim())
  // 把变量 exp 改成\_s(exp)形式也放入 tokens 中
  tokens.push(`_s(${exp})`)
  rawTokens.push({ '@binding': exp })
  // 设置 lastIndex 以保证下一轮循环时，只从'}}'后面再开始匹配正则
  lastIndex = index + match[0].length
  }
  // 当剩下的 text 不再被正则匹配上时，表示所有变量已经处理完毕
  // 此时如果 lastIndex &lt; text.length，表示在最后一个变量后面还有文本
  // 最后将后面的文本再加入到 tokens 中
  if (lastIndex &lt; text.length) {
  rawTokens.push(tokenValue = text.slice(lastIndex))
  tokens.push(JSON.stringify(tokenValue))
  }

// 最后把数组 tokens 中的所有元素用'+'拼接起来
return {
expression: tokens.join('+'),
tokens: rawTokens
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br></div></div><p>我们看到，除开我们自己加的注释，代码其实不复杂，我们逐行分析。</p> <p><code>parseText</code>函数接收两个参数，一个是传入的待解析的文本内容<code>text</code>，一个包裹变量的符号<code>delimiters</code>。第一个参数好理解，那第二个参数是干什么的呢？</p> <p>函数体内首先定义了变量<code>tagRE</code>，表示一个正则表达式。这个正则表达式是用来检查广西是否包含变量的。</p> <h4 id="_4-5-优化阶段"><a href="#_4-5-优化阶段" class="header-anchor">#</a> 4.5 优化阶段</h4> <p>优化阶段其实干了两件事：</p> <ol><li>在<code>AST</code>中找出所有静态节点并打上标记；</li> <li>在<code>AST</code>中找出所有表态根节点并打上标记；</li></ol> <p>优化阶段的源码位于<code>src/compiler/optimizer.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function optimize (root: ?ASTElement, options: CompilerOptions) {
if (!root) return
isStaticKey = genStaticKeysCached(options.staticKeys || '')
isPlatformReservedTag = options.isReservedTag || no
// 标记静态节点
markStatic(root)
// 标记静态根节点
markStaticRoots(root, false)
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>标记静态节点</strong></p> <p>从<code>AST</code>中找出所有静态节点并标记其实不难，我们只需从根节点开始，先标记点是否静态节点，然后看根节点如果是元素节点，那么就向下递归它的子节点，子节点如果还有子节点那就继续向下递归，直到票房完所有节点。代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function markStatic (node: ASTNode) {
node.static = isStatic(node)
if (node.type === 1) {
// do not make component slot content static. this avoids
// 1. components not able to mutate slot nodes
// 2. static slot content fails for hot-reloading
if (
!isPlatformReservedTag(node.tag) &amp;&amp;
node.tag !== 'slot' &amp;&amp;
node.attrsMap['inline-template'] == null
) {
return
}
for (let i = 0, l = node.children.length; i &lt; l; i++) {
const child = node.children[i]
markStatic(child)
if (!child.static) {
node.static = false
}
}
if (node.ifConditions) {
for (let i = 1, l = node.ifConditions.length; i &lt; l; i++) {
const block = node.ifConditions[i].block
markStatic(block)
if (!block.static) {
node.static = false
}
}
}
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>上面代码中，首先调用<code>isStatic</code>函数标记节点是否为静态节点，该函数若返回<code>true</code>表示该节点是静态节点，若返回<code>false</code>表示该节点不是静态节点，函数实现如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function isStatic (node: ASTNode): boolean {
if (node.type === 2) { // expression
return false
}
if (node.type === 3) { // text
return true
}
return !!(node.pre || (
!node.hasBindings &amp;&amp; // no dynamic bindings
!node.if &amp;&amp; !node.for &amp;&amp; // not v-if or v-for or v-else
!isBuiltInTag(node.tag) &amp;&amp; // not a built-in
isPlatformReservedTag(node.tag) &amp;&amp; // not a component
!isDirectChildOfTemplateFor(node) &amp;&amp;
Object.keys(node).every(isStaticKey)
))
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>该函数的实现过程其实也说明了如何判断一个节点是否为静态节点。还记得在<code>HTML</code>解析器在调用钩子函数创建<code>AST</code>节点时会根据节点类型的不同为节点加上不同的<code>type</code>属性，用<code>type</code>属性来标记<code>AST</code>节点的节点类型，其对应关系如下：</p> <table><thead><tr><th>type 取值</th> <th>对应的 AST 节点类型</th></tr></thead> <tbody><tr><td>1</td> <td>元素节点</td></tr> <tr><td>2</td> <td>包含变量的动态文本节点</td></tr> <tr><td>3</td> <td>不包含变量的纯文本节点</td></tr></tbody></table> <p>如果元素节点是静态节点，那就必须满足以下几点要求：</p> <ul><li>如果节点使用<code>v-pre</code>指令，那就断定它是静态节点；</li> <li>如果节点没有使用<code>v-pre</code>指令，那它要成为静态节点必须满足：
<ul><li>不能使用动态绑定语法，即标签上不能有<code>v-</code>、<code>@</code>、<code>:</code>开头的属性；</li> <li>不能使用<code>v-if</code>、<code>v-else</code>、<code>v-for</code> 指令；</li> <li>不能是内置组件，即标签名不能是<code>slot</code>和<code>component</code>;</li> <li>标签名必须是平台保留标签，即不能是组件；</li> <li>当前节点的父节点不能是带有<code>v-for</code>和<code>template</code>标签；</li> <li>节点的所有属性的<code>key</code>都必须是静态节点才有的<code>key</code>，注：静态节点的<code>key</code>是有限的，它只能是<code>type</code>、<code>tag</code>、<code>attrsList</code>、<code>attrsMap</code>、<code>plain</code>、<code>parent</code>、<code>children</code>、<code>attrs</code>之一；</li></ul></li></ul> <p><strong>标记静态根节点</strong></p> <p>寻找表态根节点找静态节点的逻辑类似，都是从<code>AST</code>根节点递归向上遍历寻找，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function markStaticRoots (node: ASTNode, isInFor: boolean) {
if (node.type === 1) {
if (node.static || node.once) {
node.staticInFor = isInFor
}
// For a node to qualify as a static root, it should have children that
// are not just static text. Otherwise the cost of hoisting out will
// outweigh the benefits and it's better off to just always render it fresh.
if (node.static &amp;&amp; node.children.length &amp;&amp; !(
node.children.length === 1 &amp;&amp;
node.children[0].type === 3
)) {
node.staticRoot = true
return
} else {
node.staticRoot = false
}
if (node.children) {
for (let i = 0, l = node.children.length; i &lt; l; i++) {
markStaticRoots(node.children[i], isInFor || !!node.for)
}
}
if (node.ifConditions) {
for (let i = 1, l = node.ifConditions.length; i &lt; l; i++) {
markStaticRoots(node.ifConditions[i].block, isInFor)
}
}
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>一个节点要想成为表态根节点，它必须满足以下要求：</p> <ul><li>节点本身必须是静态节点；</li> <li>必须拥有子节点<code>children</code>；</li> <li>子节点不能只是只有一个</li></ul> <h4 id="_4-5-代码生成阶段"><a href="#_4-5-代码生成阶段" class="header-anchor">#</a> 4.5 代码生成阶段</h4> <p><code>Vue</code>实例在挂载的时候会调用其自身的<code>render</code>函数来生成实例上的<code>template</code>选项所对应的<code>VNode</code>，简单的来说就是<code>Vue</code>只要调用了<code>render</code>函数，就可以把模板转换成对应的虚拟<code>DOM</code>。那么<code>Vue</code>要想调用<code>render</code>函数，那必须先有这个<code>render</code>函数</p> <p><strong>如何根据 AST 生成 render 函数</strong></p> <p>代码生成阶段主要的工作就是根据已有的<code>AST</code>生成对应的<code>render</code>函数供组件挂载时调用，组件只要调用的这个<code>render</code>函数就可以得到<code>AST</code>对应的虚拟<code>DOM</code>的<code>VNode</code>。那么如何根据<code>AST</code>生成<code>render</code>函数呢？</p> <p>假设现有如下模板：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
&lt;div id=&quot;NLRX&quot;&gt;&lt;p&gt;Hello {{name}}&lt;/p&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该模板经过解析并优化后对应的<code>AST</code>如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ast = {
    'type':1,
    'tag':'div',
    'attrsList':[
        {
            'name':'id',
            'value':'NLRX'
        }
    ],
    'attrsMap':{
        'id':'NLRX'
    },
    'static':false,
    'parent':undefined,
    'plain':false,
    'children':[{
        'type':1,
        'tag':'p',
        'plain':false,
        'static':false,
        'children':[
            {
                'type': 2,
                'expression': '&quot;Hello &quot;+_s(name)',
                'text': 'Hello {{name}}',
                'static':false,
            }
        ]
    }]
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>根据已有的这个<code>AST</code>来生成对应的<code>render</code>函数。生成<code>render</code>函数的过程其实就是一个递归的过程，从顶向下依次递归<code>AST</code>中的每一个节点，根据不同的<code>AST</code>节点类型创建不同的<code>VNode</code>类型。接下来我们就来照已有的模板和<code>AST</code>实际演示了一下生成<code>render</code>函数的过程。</p> <ol><li>首先，根节点<code>div</code>是一个元素型<code>AST</code>节点，那么我们就要创建一个元素型<code>VNode</code>，我们把创建元素型<code>VNode</code>的方法叫做<code>_c(tagName,data,children)</code>。我们暂且不管<code>_c()</code>是什么，只需知道调用<code>_c()</code>就可以创建一个元素型<code>VNode</code>。那么就可以生成如下代码：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>_c('div',{attrs:{&quot;id&quot;:&quot;NLRX&quot;}},[/*子节点列表*/])
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="2"><li>根节点<code>div</code>有子节点，那么我们进入子节点列表<code>children</code>里遍历子节点，发现子节点<code>p</code>也是元素型的，那就继续创建元素型<code>VNode</code>并将其放入上述代码中根节点的子节点列表中，如下：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>_c('div',{attrs:{&quot;id&quot;:&quot;NLRX&quot;}},[_c('p',{attrs:{}},[/*子节点列表*/])])
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="3"><li>同理，继续遍历<code>p</code>节点的子节点，发现是一个文本型节点，那就创建一个文本型<code>VNode</code>并将其插入到<code>p</code>节点的子节点列表中，同理，创建文本型<code>VNode</code>我们调用<code>_v()</code>方法，如下：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>_c('div',{attrs:{&quot;id&quot;:&quot;NLRX&quot;}},[_c('p',{attrs:{}},[_v(&quot;Hello &quot;+_s(name))])])
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="4"><li>到此，整个<code>AST</code>就遍历完毕了，我们将得到的代码再包装一下，如下：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code> with(this){
   reurn _c(
     'div',
     {
       attrs:{&quot;id&quot;:&quot;NLRX&quot;},
     },
     [
       _c(
         'p',
         {
           attrs:{}
         },
         [
           _v(&quot;Hello &quot;+_s(name))
         ]
       )
     ]
   )
 }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><ol start="5"><li>最后，我们将上面得到的这个函数字符串传递给<code>createFunction</code>函数，<code>createFunction</code>函数会帮我们把得到的函数字符串转换成真正的函数，赋给组件中的<code>render</code>选项，从而就是<code>render</code>选项，从而就是<code>render</code>函数了。如下：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>res.render = createFunction(compiled.render, fnGenErrors)

function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err, code })
    return noop
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>源码分析</strong></p> <p>代码生成阶段的源码位于<code>src/compiler/codegen/index.js</code>中，源码虽然很长，但是逻辑不复杂，核心逻辑如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function generate (ast,option) {
  const state = new CodegenState(options)
  const code = ast ? genElement(ast, state) : '_c(&quot;div&quot;)'
  return {
    render: `with(this){return ${code}}`,
    staticRenderFns: state.staticRenderFns
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>调用<code>generate</code>函数并传入优化后得到的<code>ast</code>，在<code>generate</code>函数内部先判断<code>ast</code>是否为空，不为空则调用<code>genElement(ast, state)</code>函数创建<code>VNode</code>，为空则创建一上空的元素型<code>div</code>的<code>VNode</code>。然后将得到的结果用<code>with(this){return ${code}}</code>包裹返回。可以看出，真正起作用的是<code>genElement</code>函数。</p> <p><code>genElement</code>函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function genElement (el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre
  }

  if (el.staticRoot &amp;&amp; !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once &amp;&amp; !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for &amp;&amp; !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if &amp;&amp; !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    let code
    if (el.component) {
      code = genComponent(el.component, el, state)
    } else {
      let data
      if (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) {
        data = genData(el, state)
      }

      const children = el.inlineTemplate ? null : genChildren(el, state, true)
      code = `_c('${el.tag}'${
        data ? `,${data}` : '' // data
      }${
        children ? `,${children}` : '' // children
      })`
    }
    // module transforms
    for (let i = 0; i &lt; state.transforms.length; i++) {
      code = state.transforms[i](el, code)
    }
    return code
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p><code>genElement</code>函数逻辑很清晰，就是根据当前<code>AST</code>元素节点属性不同从而执行不同的代码生成函数。虽然元素节点属性的情况有很多种，但是最后真正创建出来的<code>VNode</code>无非就三种，分别是元素节点，文本节点，注释节点。</p> <p><strong>元素节点</strong></p> <p>生成元素型节点的<code>render</code>函数代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const data = el.plain ? undefined : genData(el, state)

const children = el.inlineTemplate ? null : genChildren(el, state, true)
code = `_c('${el.tag}'${
data ? `,${data}` : '' // data
}${
children ? `,${children}` : '' // children
})`
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>生成元素节点的<code>render</code>函数就是生成一个<code>_c()</code>函数调用的字符串，上文提到了<code>_c()</code>函数接收三个参数，分别是节点的标签名<code>tagName</code>，节点属性<code>data</code>，节点的子节点列表<code>children</code>。</p> <ol><li>获取节点属性 data</li></ol> <p>首先判断<code>plain</code>属性是否为<code>true</code>，若为<code>true</code>则表示节点没有属性，将<code>data</code>赋值为<code>undefined</code>；如果不为<code>true</code>则调用<code>genData</code>函数获取节点属性<code>data</code>数据。<code>genData</code>函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function genData (el: ASTElement, state: CodegenState): string {
  let data = '{'
  const dirs = genDirectives(el, state)
  if (dirs) data += dirs + ','

    // key
    if (el.key) {
        data += `key:${el.key},`
    }
    // ref
    if (el.ref) {
        data += `ref:${el.ref},`
    }
    if (el.refInFor) {
        data += `refInFor:true,`
    }
    // pre
    if (el.pre) {
        data += `pre:true,`
    }
    // 篇幅所限，省略其他情况的判断
    data = data.replace(/,$/, '') + '}'
    return data
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>源码中<code>genData</code>虽然很长，但是其逻辑非常简单，就是在拼接字符串,先给<code>data</code>赋值为一个<code>{</code>，然后判断存在哪些属性数据，就将这些数据拼接到<code>data</code>中，最后再加一个<code>}</code>，最终得到节点全部属性<code>data</code>。</p> <ol start="2"><li>获取子节点列表 children</li></ol> <p>获取子节点列表<code>children</code>其实就是遍历<code>AST</code>的<code>children</code>属性中的元素，然后根据元素属性的不同生成不同的<code>VNode</code>创建函数调用字符串，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function genChildren (el):  {
    if (children.length) {
        return `[${children.map(c =&gt; genNode(c, state)).join(',')}]`
    }
}
function genNode (node: ASTNode, state: CodegenState): string {
  if (node.type === 1) {
    return genElement(node, state)
  } if (node.type === 3 &amp;&amp; node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ol start="3"><li>上面两步完成之后，生成<code>_c()</code>函数调用字符串，如下：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>code = `_c('${el.tag}'${
    data ? `,${data}` : '' // data
}${
    children ? `,${children}` : '' // children
})`
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>文本节点</strong></p> <p>文本型的<code>VNode</code>可以调用<code>_v(text)</code>函数来创建，所以生成文本节点的<code>render</code>函数就是生成一个<code>_v(text)</code>函数调用的字符串。<code>_v()</code>函数接收文本内容作为参数，如果文本是动态文本，则使用动态文本<code>AST</code>节点的<code>expression</code>属性，如果是纯静态文本，则使用<code>text</code>属性，其生成代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function genText (text: ASTText | ASTExpression): string {
  return `_v(${text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))
  })`
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>注释节点</strong></p> <p>注释型的<code>VNode</code>可以调用<code>_e(text)</code>函数来创建，所以生成注释节点的<code>render</code>函数就是生成一个<code>_e(text)</code>函数调用的字符串。<code>_e()</code>函数接收注释内容作为参数，其生成代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function genComment (comment: ASTText): string {
  return `_e(${JSON.stringify(comment.text)})`
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="五、生命周期篇"><a href="#五、生命周期篇" class="header-anchor">#</a> 五、生命周期篇</h3> <ul><li>初始化阶段</li> <li>模板编译阶段</li> <li>挂载阶段</li> <li>销毁阶段</li></ul> <h4 id="_5-1-初始化阶段"><a href="#_5-1-初始化阶段" class="header-anchor">#</a> 5.1 初始化阶段</h4> <ul><li><code>new Vue</code></li> <li><code>initLifecycle</code></li> <li><code>initEvents</code></li> <li><code>initInjections</code></li> <li><code>initState</code></li></ul> <p><strong>new Vue 都干了什么</strong></p> <p>初始化阶段所做的第一件事就是<code>new Vue()</code>创建一个<code>Vue</code>实例，那么<code>new Vue()</code>的内部都干了什么呢？我们知道，<code>new</code>关键字在<code>JS</code>中表示从一个类中实例化出一个对象来，由此可见，<code>Vue</code>实际上是一个类。所以<code>new Vue()</code>实际上是执行了<code>Vue</code>类的构造函数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function Vue (options) {
if (process.env.NODE_ENV !== 'production' &amp;&amp;
!(this instanceof Vue)
) {
warn('Vue is a constructor and should be called with the `new` keyword')
}
this._init(options)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>可以看到，<code>Vue</code>类的定义非常简单，其构造函数核心就一行代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>this._init(options)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>调用原型上的<code>_init(options)</code>方法并把用户所写的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>initMixin(Vue)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这一行代码执行了<code>initMixin</code>函数，那<code>initMixin</code>函数又是从哪儿来的呢？该函数定义位于源码的``中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    const vm = this
    vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
    )
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p><strong>合并属性</strong></p> <p>在上文中，<code>_init</code>方法里首先会调用<code>mergeOptions</code>函数来进行属性合并，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
vm.$options = mergeOptions(
resolveConstructorOptions(vm.constructor),
options || {},
vm
)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>它实际上就是把 <code>resolveConstructorOptions(vm.constructor)</code> 的返回值和 <code>options</code> 做合并，返回<code>vm.constructor.options</code>，相当于<code>Vue.options</code>，那么这个<code>Vue.options</code>又是什么呢，其实在<code>initGlobalAPI(Vue)</code>的时候定义了这个值，代码在<code>src/core/global-api/index.js</code>中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initGlobalAPI (Vue: GlobalAPI) {
// ...
Vue.options = Object.create(null)
ASSET_TYPES.forEach(type =&gt; {
Vue.options[type + 's'] = Object.create(null)
})

extend(Vue.options.components, builtInComponents)
// ...
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>首先通过<code>Vue.options = Object.create(null)</code>创建一个空对象，然后遍历<code>ASSET_TYPES</code>，<code>ASSET_TYPES</code>的定义在<code>src/shared/contstants.js</code>中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export const ASSET_TYPES = [
'component',
'directive',
'filter'
]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上面遍历<code>ASSET_TYPES</code>后代码相当于：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.options.components = {}
Vue.options.directives = {}
Vue.options.filters = {}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>最后通过<code>extend(Vue.options.components,builtInCompontents)</code>把一些内置组件扩展到<code>Vue.options.components</code>上，<code>Vue</code>的内置组件目前有<code>&lt;keep-alive&gt;</code>、<code>&lt;transition&gt;</code>和<code>&lt;transition-group&gt;</code>组件，这也就是为什么我们在其它组件中使用这些组件不需要注册的原因。</p> <p><code>mergeOptions</code>这个函数，它的定义在<code>src/core/util/options.js</code>中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  export function mergeOptions (
  parent: Object,
  child: Object,
  vm?: Component
  ): Object {
  if (process.env.NODE_ENV !== 'production') {
  checkComponents(child)
  }

if (typeof child === 'function') {
child = child.options
}

normalizeProps(child, vm)
normalizeInject(child, vm)
normalizeDirectives(child)

// Apply extends and mixins on the child options,
// but only if it is a raw options object that isn't
// the result of another mergeOptions call.
// Only merged options has the \_base property.
if (!child.\_base) {
if (child.extends) {
parent = mergeOptions(parent, child.extends, vm)
}
if (child.mixins) {
for (let i = 0, l = child.mixins.length; i &lt; l; i++) {
parent = mergeOptions(parent, child.mixins[i], vm)
}
}
}

const options = {}
let key
for (key in parent) {
mergeField(key)
}
for (key in child) {
if (!hasOwn(parent, key)) {
mergeField(key)
}
}
function mergeField (key) {
const strat = strats[key] || defaultStrat
options[key] = strat(parent[key], child[key], vm, key)
}
return options
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><p>可以看出，<code>mergeOptions</code>函数的主要功能是把<code>parent</code>和<code>child</code>这两个对象根据一些合并策略，合并成一个新对象并返回。首先递归把<code>extends</code>和<code>mixins</code>合并到<code>parent</code>上</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> const extendsFrom = child.extends
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm)
  }
  if (child.mixins) {
    for (let i = 0, l = child.mixins.length; i &lt; l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm)
    }
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>然后创建一个空对象<code>options</code>，遍历<code>parent</code>，把<code>parent</code>中的每一项通过调用<code>mergeField</code>函数合并到空对象<code>options</code>里</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const options = {}
let key
for (key in parent) {
    mergeField(key)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>值得一提的是<code>mergeField</code>函数，它不是简单的把属性从一个对象里复制到另外一个对象里，而是根据被合并的不同的选项有着不同的合并策略。生命周期钩子函数的合并策略如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function mergeHook(parentVal,childVal){
    return childVal? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal
}

LIFECYCLE_HOOKS.forEach(hook =&gt; {
    strats[hook] = mergeHook
})

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这其中的<code>LIFECYCLE_HOOKS</code>的定义在<code>src/shared/constants.js</code>中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export const LIFECYCLE_HOOKS = [
'beforeCreate',
'created',
'beforeMount',
'mounted',
'beforeUpdate',
'updated',
'beforeDestroy',
'destroyed',
'activated',
'deactivated',
'errorCaptured'
]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这里定义了所有钩子函数名称，所以对于钩子函数的合并策略都是<code>mergeHook</code>函数。<code>mergeHook</code>函数的实现了一个多层嵌套的三元运算符，如果嵌套太不好理解的话我们可以将其展开，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function mergeHook (parentVal,childVal):  {
 if (childVal) {
   if (parentVal) {
     return parentVal.concat(childVal)
   } else {
     if (Array.isArray(childVal)) {
       return childVal
     } else {
       return [childVal]
     }
   }
 } else {
   return parentVal
 }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>callHook 函数如何触发钩子函数</strong></p> <p>关于<code>callHook</code>函数如何触发钩子函数的问题，我们只需看一下该函数的实现源码即可，该函数的源码位于<code>src/core/instance/lifecycle.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function callHook(vm,hook){
const handlers = vm.\$options[hook]
if(handlers){
for(let i = 0,j = handlers.length;i&lt;j;i++){
try{
hanlders[i].call(vm)
}catch(e){
handleError(e,vm,`${hook} hook`)
}
}
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>可以看到，<code>callHook</code>函数逻辑非常简单。首先从实例的<code>$options</code>中获取到需要触发的钩子名称所对应的钩子函数数组<code>handlers</code>，我们说过，每个生命周期钩子名称都对应一个钩子函数数组。然后遍历该数组，将数组中的每个钩子函数都执行一遍。</p> <p><strong>initLifecycle 函数分析</strong></p> <p><code>initLifecycle</code>函数的定义的位于源码的<code>src/core/instance/lifecycle.js</code>中，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initLifecycle (vm: Component) {
const options = vm.$options

// locate first non-abstract parent
let parent = options.parent
if (parent &amp;&amp; !options.abstract) {
while (parent.$options.abstract &amp;&amp; parent.$parent) {
parent = parent.$parent
    }
    parent.$children.push(vm)
}

vm.$parent = parent
  vm.$root = parent ? parent.\$root : vm

vm.$children = []
  vm.$refs = {}

vm._watcher = null
vm._inactive = null
vm._directInactive = false
vm._isMounted = false
vm._isDestroyed = false
vm._isBeingDestroyed = false
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p><strong>解析事件</strong></p> <p>在<code>Vue</code>中，当我们在父组件中使用子组件时可以给子组件上注册一些事件，这些事件包括使用<code>v-on</code>或<code>@</code>注册的自定义事件，也包括注册的浏览器原生事件，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;child @select=&quot;selectHandler&quot; @click.native=&quot;clickHandler&quot;&gt;&lt;/child&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>上面代码，首先要从解析事件开始说起，当遇到开始标签的时候，除了会解析开始标签，还会调用<code>processAttrs</code>方法解析标签中的属性，<code>processAttrs</code>方法位于源码的<code>src/compiler/parser/index.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function processAttrs (el) {
const list = el.attrsList
let i, l, name, rawName, value, modifiers, syncGen, isDynamic
for (i = 0, l = list.length; i &lt; l; i++) {
name = rawName = list[i].name
value = list[i].value
if (dirRE.test(name)) {
// mark element as dynamic
el.hasBindings = true
// modifiers
modifiers = parseModifiers(name.replace(dirRE, ''))
// support .foo shorthand syntax for the .prop modifier
if (process.env.VBIND_PROP_SHORTHAND &amp;&amp; propBindRE.test(name)) {
(modifiers || (modifiers = {})).prop = true
name = `.` + name.slice(1).replace(modifierRE, '')
} else if (modifiers) {
name = name.replace(modifierRE, '')
}
if (bindRE.test(name)) { // v-bind
name = name.replace(bindRE, '')
value = parseFilters(value)
isDynamic = dynamicArgRE.test(name)
if (isDynamic) {
name = name.slice(1, -1)
}
if (
process.env.NODE_ENV !== 'production' &amp;&amp;
value.trim().length === 0
) {
warn(
`The value for a v-bind expression cannot be empty. Found in &quot;v-bind:${name}&quot;`
)
}
if (modifiers) {
if (modifiers.prop &amp;&amp; !isDynamic) {
name = camelize(name)
if (name === 'innerHtml') name = 'innerHTML'
}
if (modifiers.camel &amp;&amp; !isDynamic) {
name = camelize(name)
}
if (modifiers.sync) {
syncGen = genAssignmentCode(value, `$event`)
if (!isDynamic) {
addHandler(
el,
`update:${camelize(name)}`,
syncGen,
null,
false,
warn,
list[i]
)
if (hyphenate(name) !== camelize(name)) {
addHandler(
el,
`update:${hyphenate(name)}`,
syncGen,
null,
false,
warn,
list[i]
)
}
} else {
// handler w/ dynamic event name
addHandler(
el,
`&quot;update:&quot;+(${name})`,
syncGen,
null,
false,
warn,
list[i],
true // dynamic
)
}
}
}
if ((modifiers &amp;&amp; modifiers.prop) || (
!el.component &amp;&amp; platformMustUseProp(el.tag, el.attrsMap.type, name)
)) {
addProp(el, name, value, list[i], isDynamic)
} else {
addAttr(el, name, value, list[i], isDynamic)
}
} else if (onRE.test(name)) { // v-on
name = name.replace(onRE, '')
isDynamic = dynamicArgRE.test(name)
if (isDynamic) {
name = name.slice(1, -1)
}
addHandler(el, name, value, modifiers, false, warn, list[i], isDynamic)
} else { // normal directives
name = name.replace(dirRE, '')
// parse arg
const argMatch = name.match(argRE)
let arg = argMatch &amp;&amp; argMatch[1]
isDynamic = false
if (arg) {
name = name.slice(0, -(arg.length + 1))
if (dynamicArgRE.test(arg)) {
arg = arg.slice(1, -1)
isDynamic = true
}
}
addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i])
if (process.env.NODE_ENV !== 'production' &amp;&amp; name === 'model') {
checkForAliasModel(el, value)
}
}
} else {
// literal attribute
if (process.env.NODE_ENV !== 'production') {
const res = parseText(value, delimiters)
if (res) {
warn(
`${name}=&quot;${value}&quot;:` +
'Interpolation inside attributes has been removed. ' +
'Use v-bind or the colon shorthand instead. For example, ' +
'instead of &lt;div id=&quot;{{ val }}&quot;&gt;, use &lt;div :id=&quot;val&quot;&gt;.',
list[i]
)
}
}
addAttr(el, name, JSON.stringify(value), list[i])
if (!el.component &amp;&amp;
name === 'muted' &amp;&amp;
platformMustUseProp(el.tag, el.attrsMap.type, name)) {
addProp(el, name, 'true', list[i])
}
}
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br></div></div><p><strong>initEvents 函数分析</strong></p> <p>了解了以上过程之后，开始分析<code>initEvents</code>函数，该函数位于源码的<code>src/instance/events.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initEvents (vm: Component) {
    vm._events = Object.create(null)
    vm._hasHookEvent = false
    const listeners = vm.$options._parentListeners
    if (listeners) {
        updateComponentListeners(vm, listeners)
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这个<code>updateComponentListeners</code>函数是什么呢？该函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function updateComponentListeners (
vm: Component,
listeners: Object,
oldListeners: ?Object
) {
target = vm
updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler, vm)
target = undefined
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>initInjections 函数分析</strong></p> <p>从函数名字上来看，该函数是用来初始化实例中的<code>inject</code>选项的。说到<code>inject</code>选项，那必然离不开<code>provide</code>选项，这两个选项都是成对出现的，它们的作用是：鸡毛一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间始终生效。</p> <p><code>provide</code>选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES 2015 Symbols 作为 key，但是只在原生支持<code>Symbol</code>和<code>Reflect.ownKeys</code>的环境下可工作。</p> <p><code>inject</code>选项应该是：</p> <ul><li>一个字符串数组或</li> <li>一个对象，对象的 key 是本地的绑定名，value 是：
<ul><li>在可用的注入</li></ul></li></ul> <p><code>initInjections</code>函数的具体原理，该函数定义在位于源码的``中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initInjections (vm: Component) {
const result = resolveInject(vm.\$options.inject, vm)
if (result) {
toggleObserving(false)
Object.keys(result).forEach(key =&gt; {
/\* istanbul ignore else \*/
if (process.env.NODE_ENV !== 'production') {
defineReactive(vm, key, result[key], () =&gt; {
warn(
`Avoid mutating an injected value directly since the changes will be` +
`overwritten whenever the provided component re-renders.` +
`injection being mutated: &quot;${key}&quot;`,
vm
)
})
} else {
defineReactive(vm, key, result[key])
}
})
toggleObserving(true)
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p><strong>initState 函数分析</strong></p> <p>这个函数是用来初始化实例状态的，主要包括<code>props</code>、<code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code>，我们把这些选项称为实例的状态选项。也就是说，<code>initState</code>函数就是用来初始化这些状态的。</p> <p>首先我们先来分析<code>initState</code>函数，该函数的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initState (vm: Component) {
    vm._watchers = []
    const opts = vm.$options
    if (opts.props) initProps(vm, opts.props)
    if (opts.methods) initMethods(vm, opts.methods)
    if (opts.data) {
        initData(vm)
    } else {
        observe(vm._data = {}, true)
    }
    if (opts.computed) initComputed(vm, opts.computed)
    if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch)
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>首先，给实例上新增了一个属性<code>_watchers</code>，用来存储当前实例中所有的<code>watcher</code>实例，无论是使用<code>vm.$watch</code>注册的<code>watcher</code>实例还是使用<code>watch</code>选项注册的<code>watcher</code>实例，都会被保存到该属性中。</p> <p><code>Vue</code>中对数据变化的侦测是使用属性拦截的方式实现的，但是<code>Vue</code>并不是对所有数据使用属性拦截的方式侦测变化，这是因为数据越多，数据上所绑定的依赖就会多，从而造成依赖追踪的内存开销就会很大，所以从<code>Vue 2.0</code>版本起，<code>Vue</code>不再对所有数据都进行侦测，而是将侦测粒度提高到组件层面，对每个组件进行侦测，所以在每个组件上新增了<code>vm._watchers</code>属性，用来存放这个组件内用到的所有状态的依赖，当其中一个状态发生变化时，就会通知到组件，然后由组件内部使用虚拟<code>DOM</code>进行数据比对，从而降低内存开销，提高性能。</p> <p>先判断实例中是否有<code>props</code>选项，如果有，就调用<code>props</code>选项初始化函数<code>initProps</code>去初始<code>props</code>选项；</p> <p>再判断实例中是否有<code>methods</code>选项，如果有，就调用<code>methods</code>选项初始函数<code>initMethods</code>去初始化<code>methods</code>选项；</p> <p>接着再判断实例中是否有<code>data</code>选项，如果有，就调用<code>data</code>选项寝化函数<code>initData</code>去初始化<code>data</code>选项；如果没有，就把<code>data</code>当作空对象并将其转换成响应式；</p> <p>接着再判断实例中是否有<code>computed</code>选项，如果有，就调用<code>computed</code>选项初始化函数<code>initComputed</code>去初始化<code>computed</code>选项；</p> <p>最后判断实例中是否有<code>watch</code>选项，如果有，就调用<code>watch</code>选项初始化函数<code>initWatch</code>去初始化<code>watch</code>选项；</p> <p><strong>初始化 props</strong></p> <p><code>props</code>选项通常是由当前组件的父级组件传入的，当父组件在调用子组件的时候，通常会把<code>props</code>属性值作为标签属性添加在子组件的标签上，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;Child prop1=&quot;xxx&quot; prop2=&quot;yyy&quot;&gt;&lt;/Child&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在模板编译的时候，当解析到组件标签时会将所有的标签属性都解析出来然后在子组件实例化的时候传给子组件。</p> <p>在子组件内部，通过<code>props</code>选项来接收父组件传来的数据，在接收的时候可以这样写：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 写法一
props: ['name']

// 写法二
props: {
    name: String, // [String, Number]
}

// 写法三
props: {
    name:{
		type: String
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><code>Vue</code>给用户提供了<code>props</code>选项写法非常自由，根据<code>Vue</code>的惯例，写法虽多但最终处理的时候肯定只处理一种写法，此时你肯定会想到，处理之前先对数据进行规范化，将所有写法都转化成一种写法。</p> <p><strong>规范化数据</strong></p> <p><code>props</code>数据规范化函数的定义位于源码的<code>src/core/util/options.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function normalizeProps (options: Object, vm: ?Component) {
  const props = options.props
  if (!props) return
  const res = {}
  let i, val, name
  if (Array.isArray(props)) {
    i = props.length
    while (i--) {
      val = props[i]
      if (typeof val === 'string') {
        name = camelize(val)
        res[name] = { type: null }
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.')
      }
    }
  } else if (isPlainObject(props)) {
    for (const key in props) {
      val = props[key]
      name = camelize(key)
      res[name] = isPlainObject(val)
        ? val
        : { type: val }
    }
  } else if (process.env.NODE_ENV !== 'production') {
    warn(
      `Invalid value for option &quot;props&quot;: expected an Array or an Object, ` +
      `but got ${toRawType(props)}.`,
      vm
    )
  }
  options.props = res
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>首先拿到实例中的<code>props</code>选项，如果不存在，则直接返回。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const props = options.props
if (!props) return
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果存在，则定义一个空对象<code>res</code>，用来存储最终的结果。接着判断如果<code>props</code>选项是一个数组（写法一），则遍历该数组中的每一项元素，如果该元素是字符串，那么先将该元素统一转化成驼峰式命名，然后将该元素作为<code>key</code>，将<code>{type:null}</code>作为<code>value</code>存入<code>res</code>中；如果不是字符串，则抛出异常，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (Array.isArray(props)) {
    i = props.length
    while (i--) {
        val = props[i]
        if (typeof val === 'string') {
            name = camelize(val)
            res[name] = { type: null }
        } else if (process.env.NODE_ENV !== 'production') {
            warn('props must be strings when using array syntax.')
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如果<code>props</code>选项不是数组那就判断是不是一个对象，如果是一个对象，那就是遍历对象中的每一对键值，拿到每一对键值后，先将键名统一转化成驼峰式命名，然后判断值是否还是一个对象，如果值是对象（写法三），那么就将该键值对存入<code>res</code>中；如果值不是对象（写法二），那么就将键名作为<code>key</code>，将<code>{type:null}</code>作为<code>value</code>存入<code>res</code>中。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (isPlainObject(props)) {
    for (const key in props) {
        val = props[key]
        name = camelize(key)
        res[name] = isPlainObject(val)
            ? val
        : { type: val }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如果<code>props</code>选项既不是数组也不是对象，那么如果在非生产环境下就抛出异常，最后将<code>res</code>作为规范化后的结果重新赋值给实例的<code>props</code>选项。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (process.env.NODE_ENV !== 'production') {
    warn(
        `Invalid value for option &quot;props&quot;: expected an Array or an Object, ` +
        `but got ${toRawType(props)}.`,
        vm
    )
}
options.props = res
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>无论是三种写法的哪一种，最终都会被转化成如下写法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>props: {
    name:{
        type: xxx
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>initProps 函数分析</strong></p> <p>将<code>props</code>选项规范化完成之后，接下来我们就可以真正的初始化<code>props</code>选项了，<code>initProps</code>函数的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function initProps (vm: Component, propsOptions: Object) {
    const propsData = vm.$options.propsData || {}
    const props = vm._props = {}
    const keys = vm.$options.\_propKeys = []
    const isRoot = !vm.\$parent
    // root instance props should be converted
    if (!isRoot) {
        toggleObserving(false)
    }
for (const key in propsOptions) {
    keys.push(key)
    const value = validateProp(key, propsOptions, propsData, vm)
    if (process.env.NODE_ENV !== 'production') {
        const hyphenatedKey = hyphenate(key)
        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
            warn(`&quot;${hyphenatedKey}&quot; is a reserved attribute and cannot be used as component prop.`,vm)
        }
        defineReactive(props, key, value, () =&gt; {
            if (!isRoot &amp;&amp; !isUpdatingChildComponent) {
            warn(
                `Avoid mutating a prop directly since the value will be` +
                `overwritten whenever the parent component re-renders.` +
                `Instead, use a data or computed property based on the prop's` +
                `value. Prop being mutated: &quot;${key}&quot;`,
                vm
            )
        }
    })
    } else {
    defineReactive(props, key, value)
    }
    if (!(key in vm)) {
        proxy(vm, `_props`, key)
    }
}
    toggleObserving(true)
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>可以看到，该函数接收两个参数：当前<code>Vue</code>实例和当前实例规范化后的<code>props</code>选项。</p> <p>在函数内部首先定义了 4 个变量，分别是：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const propsData = vm.$options.propsData || {}
const props = vm._props = {}
const keys = vm.$options._propKeys = []
const isRoot = !vm.$parent

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>propsData：父组件传入的真实<code>props</code>数据。</li> <li>props：指向<code>vm._props</code>指针，所有设置到</li> <li>keys：指向<code>vm.$options._propKeys</code>的指针，缓存</li> <li>isRoot：当前组件是否为根组件。</li></ul> <p><strong>初始化 methods</strong></p> <p>初始化<code>methods</code>相较而言就比较简单了，它的初始函数定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function initMethods (vm: Component, methods: Object) {
    const props = vm.$options.props
    for (const key in methods) {
        if (process.env.NODE_ENV !== 'production') {
            if (typeof methods[key] !== 'function') {
                warn(
                    `Method &quot;${key}&quot; has type &quot;${typeof methods[key]}&quot; in the component definition.` +
                    `Did you reference the function correctly?`,vm
                )
            }
            if (props &amp;&amp; hasOwn(props, key)) {
                warn(
                `Method &quot;${key}&quot; has already been defined as a prop.`,
                vm
                )
            }
            if ((key in vm) &amp;&amp; isReserved(key)) {
                warn(
                `Method &quot;${key}&quot; conflicts with an existing Vue instance method.` +
                `Avoid defining component methods that start with _ or $.`
                )
            }
    }
        vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm)
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p><strong>初始化 data</strong></p> <p>初始化<code>data</code>也比较简单，它的初始化函数定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initState (vm: Component) {
    vm._watchers = []
    const opts = vm.$options
    if (opts.props) initProps(vm, opts.props)
    if (opts.methods) initMethods(vm, opts.methods)
    if (opts.data) {
        initData(vm)
    } else {
        observe(vm._data = {}, true)
    }
    if (opts.computed) initComputed(vm, opts.computed)
    if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong>初始化 computed</strong></p> <p>初始化<code>initComputed</code>的内部原理是怎样的。<code>initComputed</code>函数的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function initComputed (vm: Component, computed: Object) {
    const watchers = vm._computedWatchers = Object.create(null)
    const isSSR = isServerRendering()
    for (const key in computed) {
        const userDef = computed[key]
        const getter = typeof userDef === 'function' ? userDef : userDef.get
        if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) {
            warn(
            `Getter is missing for computed property &quot;${key}&quot;.`,
            vm
            )
        }

        if (!isSSR) {
            watchers[key] = new Watcher(
                vm,
                getter || noop,
                noop,
                computedWatcherOptions
            )
        }

        if (!(key in vm)) {
            defineComputed(vm, key, userDef)
        } else if (process.env.NODE_ENV !== 'production') {
            if (key in vm.$data) {
                warn(`The computed property &quot;${key}&quot; is already defined in data.`, vm)
            } else if (vm.$options.props &amp;&amp; key in vm.$options.props) {
                warn(`The computed property &quot;${key}&quot; is already defined as a prop.`, vm)
            }
        }
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p><strong>初始化 watch</strong></p> <p>初始化<code>watch</code>选项，在日常开发中<code>watch</code>选项也经常会使用到，它可以用来侦听某个已有的数据，当该数据发生变化时执行对应的回调函数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function initWatch (vm: Component, watch: Object) {
    for (const key in watch) {
        const handler = watch[key]
        if (Array.isArray(handler)) {
            for (let i = 0; i &lt; handler.length; i++) {
                createWatcher(vm, key, handler[i])
            }
        } else {
            createWatcher(vm, key, handler)
        }
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="_5-2-模板编译阶段"><a href="#_5-2-模板编译阶段" class="header-anchor">#</a> 5.2 模板编译阶段</h4> <p>模板编译阶段主要工作是获取到用户传入的模板内容并将其编译成渲染函数。</p> <p>模板编译阶段并不是存在于<code>Vue</code>的所有构建版本中，它只存在于完整版中。在只包含运行时版本中并不存在该阶段，这是因为当使用<code>vue-loader</code>或<code>vueify</code>时，<code>*.vue</code>文件内部的模板会在构建时预编译成渲染函数，所以是不需要编译的，从而不存在模板编译阶段，由上一步的初始化阶段直接进入下一阶段的挂载阶段。</p> <p><code>vue</code>基于源码构建的有两个版本，一个是<code>runtime only</code>（一个只包含运行时的版本），另一个是<code>runtime+compiler</code>（一个同时包含编译器和运行时的完整版本）。而两个版本的区别仅在于后者包含了一个编译器。</p> <ul><li>完整版本</li></ul> <p>一个完整的 <code>Vue</code>版本是包含编译器的，我们可以使用<code>template</code>选项进行模板编写。编译器会自动将<code>template</code>选项中的模板字符串编译成渲染函数的代码，源码中就是<code>render</code>函数。如果你需要在客户端编译模板（比如传入一个字符串给<code>template</code>选项，或挂载到一个元素上并以其 <code>DOM</code>内部的<code>HTML</code>作为模板），就需要一个包含编译器的版本，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//  需要编译器的版本
new Vue({
    template:'&lt;div&gt;{{hi}}&lt;/div&gt;'
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>只包含运行时版本</li></ul> <p>只包含运行时的版本拥有创建<code>Vue</code>实例、渲染并处理<code>Virtual DOM</code>等功能，基本上就是除去编译器外的完整代码。该版本的适用场景有两种：</p> <ol><li>我们在选项中通过手写<code>render</code>函数去定义渲染过程，这个时候并不需要包含编译器的版本便可完整执行。</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 不需要编译器
new Vue({
    render(h){
        return h('div',this.hi)
    }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="2"><li>借助<code>vue-loader</code>这样的编译工具进行编译，当我们利用<code>wepback</code>进行<code>vue</code>的工程化开发时，常常会利用<code>vue-loader</code>对<code>*.vue</code>文件进行编译，尽管我们也是利用<code>template</code>模板标签去书写代码，但是此时的<code>Vue</code>已经不需要利用编译器去负责模板的编译工作了，这个过程交给了插件去实现。</li></ol> <p>编译过程对性能会造成一定的损耗，并且由于加入了编译的流程代码，<code>Vue</code>代码的总体积也更加庞大（运行时版本相比完整版体积要小大约 30%）。因此在实际开发中，我们需要借助像<code>webpack</code>的<code>vue-loader</code>这类工具进行编译，将<code>vue</code>对模板的编译阶段合并到<code>webpack</code>的构建流程中，这样不仅减少了生产环境代码的体积，也大大提高了运行时的性能，一举两得。</p> <p><strong>模板编译阶段分析</strong></p> <p>完整版本和只包含运行时版之间的差异主要在于是否有模板编译阶段，而是否有模板编译阶段主要表现在<code>vm.$mount</code>方法的实现上。实现上<code>$mount</code>也有两个版本。</p> <p><strong>两种<code>$mount</code>方法对比</strong></p> <p>只包含运行时版本的<code>$mount</code>代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$mount = function(el,hydrating){
    el = el &amp;&amp; inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在该版本中的<code>$mount</code>方法内部获取到<code>el</code>选项对应的<code>DOM</code>元素后直接调用<code>mountComponent</code>函数进行挂载操作，关于该函数我们会在挂载阶段详细介绍。</p> <p>而完整版本的<code>$mount</code>代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (el,hydrating) {
  // 省略获取模板及编译代码

  return mount.call(this, el, hydrating)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在完整版本的<code>$mount</code>定义之前，先将<code>Vue</code>原型上的<code>$mount</code>方法先缓存起来，记作变量<code>mount</code>。其实在源码中，是先定义史包含运行时版本的<code>$mount</code>方法，再定义完整版本的<code>$mount</code>方法，所以此时缓存的<code>mount</code>变量就是只包含运行时版本的<code>$mount</code>方法。</p> <p><strong>完整版的<code>vm.$mount</code>方法分析</strong></p> <p>完整版的<code>vm.$mount</code>方法定义位于源码的<code>src/platforms/web/entry-runtime-with-compiler.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;&amp; query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
        mark('compile')
      }

      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br></div></div><p>从代码中可以看到，该函数可以大致分为三部分：</p> <ul><li>根据传入的<code>el</code>参数获取<code>DOM</code>元素</li> <li>在用户没有手写<code>render</code>函数的情况下获取传入的模板<code>template</code>；</li> <li>将获取到的<code>template</code>编译成<code>render</code>函数；</li></ul> <p>首先，根据传入的<code>el</code>参数获取<code>DOM</code>元素。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>el = el &amp;&amp; query(el);

function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>由于<code>el</code>参数可以是元素，也可以是字符串类型的元素选择器，所以调用<code>query</code>函数来获取到<code>el</code>对应的<code>DOM</code>元素。由于<code>query</code>函数比较简单，就是根据传入的<code>el</code>参数是否为字符串从而以不同方式获取到对应的<code>DOM</code>元素。</p> <p>另外，这里还多了一个判断，就是判断获取到<code>el</code>对应的<code>DOM</code>元素如果是<code>body</code>或<code>html</code>元素时，将会抛出警告。这是因为<code>Vue</code>会将模板中的内容替换<code>el</code>对应的<code>DOM</code>元素，如果是<code>body</code>或<code>html</code>元素时，替换之后将会破坏整个<code>DOM</code>文档，所以不允许<code>el</code>是<code>body</code>或<code>html</code>。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (el === document.body || el === document.documentElement) {
  warn(
    &quot;Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.&quot;
  );
  return this
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>接着，在用户没有手写<code>render</code>函数的情况下获取传入的模板<code>template</code>；如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!options.render) {
  var template = options.template;
  if (template) {
    if (typeof template === 'string') {
      if (template.charAt(0) === '#') {
        template = idToTemplate(template);
        /* istanbul ignore if */
        if (!template) {
          warn(
            (&quot;Template element not found or is empty: &quot; + (options.template)),
            this
          );
        }
      }
    } else if (template.nodeType) {
        template = template.innerHTML;
    } else {
      {
        warn('invalid template option:' + template, this);
      }
      return this
    }
  } else if (el) {
    template = getOuterHTML(el);
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>首先获取用户传入的<code>template</code>选项赋给变量<code>template</code>，如果变量<code>template</code>存在，则接着判断如果<code>template</code>字符串并且以<code>#</code>开头，则认为<code>template</code>是<code>id</code>选择符，则调用<code>idToTemplate</code>函数获取到选择符对应的<code>DOM</code>元素的<code>innerHTML</code>作为模板，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (template) {
  if (typeof template === 'string') {
    if (template.charAt(0) === '#') {
      template = idToTemplate(template);
    }
  }
}

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el &amp;&amp; el.innerHTML
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如果<code>template</code>不是字符串，那就判断它是不是一个<code>DOM</code>元素，如果是，则使用该<code>DOM</code>元素的<code>innerHTML</code>作为模板，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (template.nodeType) {
  template = template.innerHTML;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>总结</strong></p> <p>介绍了<code>Vue</code>源码构建的两种版本：完整版本和只包含运行时版本。并且我们知道了模板编译阶段只存在于完整版中，在只包含运行时版本中不存在该阶段，这是因为在只包含运行时版本中，当使用<code>vue-loader</code>或<code>vueify</code>时，<code>*.vue</code>文件内部的模板会在构建时预编译成渲染函数，所以是不需要编译的，从而不存在模板编译阶段。</p> <p>然后对比了两种版本<code>$mount</code>方法的区别。它们的区别在于在<code>$mount</code>方法中是否进行了模板编译。在只包含运行时版本的<code>$mount</code>方法中获取到<code>DOM</code>元素后直接进入挂载阶段，而在完整的<code>$mount</code>方法中是先将模板进行编译，然后回过头调用只包含运行时版本的<code>$mount</code>方法进入挂载阶段。</p> <p>最后，我们知道了分析模板编译阶段其实就是分析完整版本的<code>vm.$mount</code>方法的实现，我们将完整版本的<code>vm.$mount</code>方法源码进行了逐行分析。知道了在该阶段所做的工作就是：从用户传入的<code>el</code>选项和<code>template</code>选项中获取到用户传入的内部或外部模板，然后将获取到的模板编译成渲染函数。</p> <h4 id="_5-3-挂载阶段"><a href="#_5-3-挂载阶段" class="header-anchor">#</a> 5.3 挂载阶段</h4> <p>挂载阶段所做的主要工作是创建<code>Vue</code>实例并用其替换<code>el</code>选项对应的<code>DOM</code>元素，同时还要开启对模板中数据（状态）的监控，当数据（状态）发生变化时通知其依赖进行视图更新。</p> <p><img src="vue17.jpg" alt="images"></p> <p><strong>挂载阶段分析</strong></p> <p>在完整版本的<code>$mount</code>方法中将模板编译完成之后，会回过头去调只包含运行时版本</p> <p><code>mountComponent</code>函数的定义位于源码的<code>src/core/instance/lifecycle.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function mountComponent (vm,el,hydrating) {
    vm.$el = el
    if (!vm.$options.render) {
        vm.$options.render = createEmptyVNode
    }
    callHook(vm, 'beforeMount')

    let updateComponent

    updateComponent = () =&gt; {
        vm._update(vm._render(), hydrating)
    }
    new Watcher(vm, updateComponent, noop, {
        before () {
            if (vm._isMounted) {
                callHook(vm, 'beforeUpdate')
            }
        }
    }, true /* isRenderWatcher */)
    hydrating = false

    if (vm.$vnode == null) {
        vm._isMounted = true
        callHook(vm, 'mounted')
    }
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>可以看到，在该函数中，首先会判断实例上是否存在渲染函数，如果不存在，则设置一个默认的渲染函数<code>createEmptyVNode</code>，该渲染函数会创建一个注释类型的<code>VNode</code>节点。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$el = el
if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>然后调用<code>callHook</code>函数来触发<code>beforeMount</code>生命同期钩子函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>callHook(vm, 'beforeMount')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>该钩子函数触发后标志着正式开始执行挂载操作。</p> <p>接下来定义了一个<code>updateComponent</code>函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>updateComponent = () =&gt; {
    vm._update(vm._render(), hydrating)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在该函数内部，首先执行渲染函数<code>vm._render()</code>得到一份最新的<code>VNode</code>节点树，然后执行<code>vm._update()</code>方法对最新的<code>VNode</code>节点树与上一次渲染的旧<code>VNode</code>节点树进行对比并更新<code>DOM</code>节点（即<code>patch</code>操作），完成一次渲染。</p> <h4 id="_5-4-销毁阶段"><a href="#_5-4-销毁阶段" class="header-anchor">#</a> 5.4 销毁阶段</h4> <p>销毁阶段所做的主要工作是将当前的<code>Vue</code>实例从其父级实例中删除，取消当前实例上的所有依赖追踪并且移除实例上的所有事件监听器。</p> <p><strong>销毁阶段分析</strong></p> <p>当调用了实例的<code>$destroy</code>方法之后，当前实例就进入了销毁阶段。所以分析销毁阶段就是分析<code>$destroy</code></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$destroy = function () {
    const vm: Component = this
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy')
    vm._isBeingDestroyed = true
    // remove self from parent
    const parent = vm.$parent
    if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) {
      remove(parent.$children, vm)
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown()
    }
    let i = vm._watchers.length
    while (i--) {
      vm._watchers[i].teardown()
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--
    }
    // call the last hook...
    vm._isDestroyed = true
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null)
    // fire destroyed hook
    callHook(vm, 'destroyed')
    // turn off all instance listeners.
    vm.$off()
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><h3 id="六、实例方法"><a href="#六、实例方法" class="header-anchor">#</a> 六、实例方法</h3> <ul><li>数据相关的方法</li> <li>事件相关的方法</li> <li>生命周期相关的方法</li></ul> <h4 id="_6-1-数据相关的方法"><a href="#_6-1-数据相关的方法" class="header-anchor">#</a> 6.1 数据相关的方法</h4> <p>参考小节<a href="#2.3-%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%9A%84-API-%E5%AE%9E%E7%8E%B0">变化侦测的 API 实现</a></p> <h4 id="_6-2-事件相关的方法"><a href="#_6-2-事件相关的方法" class="header-anchor">#</a> 6.2 事件相关的方法</h4> <p>与事件相关的实例方法有 4 个，分别是<code>vm.$on</code>、<code>vm.$emit</code>、<code>vm.$off</code>和<code>vm.$once</code>。它们是在<code>eventsMixin</code>函数中挂载到<code>Vue</code>原型上的，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function eventsMixin (Vue) {
    Vue.prototype.$on = function (event, fn) {}
    Vue.prototype.$once = function (event, fn) {}
    Vue.prototype.$off = function (event, fn) {}
    Vue.prototype.$emit = function (event) {}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>当执行<code>eventsMixin</code>函数后，会向<code>Vue</code>原型上挂载上述 4 个实例方法。</p> <ul><li><code>vm.$on</code></li> <li><code>vm.$emit</code></li> <li><code>vm.$off</code></li> <li><code>vm.$once</code></li></ul> <p><strong><code>vm.$on</code></strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$on( event, callback )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{string | Array&lt;string&gt;} event</code>(数组只在 2.2.0+中支持)</li> <li><code>{Function} callback</code></li></ul></li> <li><p><strong>作用：</strong></p></li></ul> <p>监听当前实例上的自定义事件。事件可以由<code>vm.$emit</code>触发。回调函数会接收所有传入事件触发函数的额外参数</p> <p>示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$on('test', function (msg) {
  console.log(msg)
})
vm.$emit('test', 'hi')
// =&gt; &quot;hi&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><strong>内部原理：</strong></li></ul> <p><code>$on</code>和<code>$emit</code>这两个方法的内部原理是设计模式中最典型的发布订阅模式，首先定义一个事件中心，通过<code>$on</code>订阅事件，将事件存储在事件中心里面，然后通过<code>$emit</code>触发事件中心里面存储的订阅事件。</p> <p>该方法的定义位于源码的<code>src/core/instance/event.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$on = function (event, fn) {
    const vm: Component = this
    if (Array.isArray(event)) {
        for (let i = 0, l = event.length; i &lt; l; i++) {
            this.$on(event[i], fn)
        }
    } else {
        (vm._events[event] || (vm._events[event] = [])).push(fn)
    }
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><code>$on</code>方法接收两个参数，第一个参数是订阅的事件名，可以是数组，表示订阅多个事件。第二个参数是回调函数，当触发所订阅的事件时会执行该回调函数。</p> <p>首先，判断传入的事件名是否是一个数组，如果是数组，就表示需要一次性订阅多个事件，就遍历该数组，将数组中的每一个事件都递归调用<code>$on</code> 方法将其作为单个事件订阅。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (Array.isArray(event)) {
    for (let i = 0, l = event.length; i &lt; l; i++) {
        this.$on(event[i], fn)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果不是数组，那就当做单个事件名来处理，以该事件名作为 <code>key</code>，先尝试在当前实例的<code>_events</code> 属性中获取其对应的事件列表，如果获取不到就给其赋空数组为默认值，并将第二个参数回调函数添加进去。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>else {
    (vm._events[event] || (vm._events[event] = [])).push(fn)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当前实例的<code>_events</code>属性是干嘛的呢？</p> <p>生命周期初始化阶段的初始化事件 <code>initEvents</code> 函数中，在该函数中，首先在当前实例上绑定了<code>_events</code> 属性并给其赋值为空对象，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function initEvents (vm: Component) {
    vm._events = Object.create(null)
    // ...

}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这个<code>_events</code>属性就是用来作为当前实例的事件中心，所有绑定在这个实例上的事件都会存储在事件中心<code>_events</code>属性中。</p> <p><strong><code>vm.$emit</code></strong></p> <p><code>vm.$emit</code>用法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$emit( eventName, […args] )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>内部原理</strong></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$emit = function (event: string): Component {
    const vm: Component = this
    let cbs = vm._events[event]
    if (cbs) {
      cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs
      const args = toArray(arguments, 1)
      for (let i = 0, l = cbs.length; i &lt; l; i++) {
        try {
          cbs[i].apply(vm, args)
        } catch (e) {
          handleError(e, vm, `event handler for &quot;${event}&quot;`)
        }
      }
    }
    return vm
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong><code>vm.$off</code></strong></p> <p>该函数的用法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$off( [event, callback] )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数</strong></p> <ul><li><code>{string | Array&lt;string&gt;} event</code></li> <li><code>{Function} [callback]</code></li></ul></li> <li><p><strong>作用</strong></p> <p>移除自定义事件监听器。</p> <ul><li>如果没有提供参数，则移除所有的事件监听器；</li> <li>如果只提供了事件，则移除该事件所有的监听器；</li> <li>如果同时提供了事件与回调，则只移除这个回调的监听器。</li></ul></li> <li><p><strong>内部原理</strong></p></li></ul> <p>该方法的定义位于源码的<code>src/core/instance/event.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$off = function (event, fn) {
    const vm: Component = this
    // all
    if (!arguments.length) {
        vm._events = Object.create(null)
        return vm
    }
    // array of events
    if (Array.isArray(event)) {
        for (let i = 0, l = event.length; i &lt; l; i++) {
            this.$off(event[i], fn)
        }
        return vm
    }
    // specific event
    const cbs = vm._events[event]
    if (!cbs) {
        return vm
    }
    if (!fn) {
        vm._events[event] = null
        return vm
    }
    if (fn) {
        // specific handler
        let cb
        let i = cbs.length
        while (i--) {
            cb = cbs[i]
            if (cb === fn || cb.fn === fn) {
                cbs.splice(i, 1)
                break
            }
        }
    }
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>该方法内部就是通过不断判断所传参数的情况进而不同的逻辑处理。</p> <p>首先，判断如果没有传入任何参数，这就是第一种情况：如果没有提供参数，则移除所有的事件监听器。我们</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!arguments.length) {
    vm._events = Object.create(null)
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接着，判断如果传入的需要移除的事件名是一个数组，就表示需要一次性移除多个事件，那么我们只需订阅多个事件一样，遍历该数组，然后将数组中的每一个事件都递归调用<code>$off</code>方法进行移除即可。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (Array.isArray(event)) {
    for (let i = 0, l = event.length; i &lt; l; i++) {
        this.$off(event[i], fn)
    }
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong><code>vm.$once</code></strong></p> <p>官方文档用法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$once( event, callback )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{string} event</code></li> <li><code>{Function} callback</code></li></ul></li> <li><p><strong>作用：</strong></p></li></ul> <p>监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。</p> <ul><li><strong>内部原理</strong></li></ul> <p>该方法的作用是先订阅事件，但是该事件只能触发一次，也就是说当该事件被触发后会立即移除。要实现这个功能也不难，我们可以定义一个子函数，用这个子函数来替换原本订阅的事件所对应的回调，也就是当触发订阅事件时，其实执行的是这个子函数，然后再子函数内部先把订阅移除，再执行原本的回调。</p> <p>该方法的定义位于源码的<code>src/core/instance/event.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$once = function (event, fn) {
    const vm: Component = this
    function on () {
        vm.$off(event, on)
        fn.apply(vm, arguments)
    }
    on.fn = fn
    vm.$on(event, on)
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="_6-3-生命周期相关的方法"><a href="#_6-3-生命周期相关的方法" class="header-anchor">#</a> 6.3 生命周期相关的方法</h4> <p>与生命周期想着的实例方法有 4 个，分别是<code>vm.$mount</code>、<code>vm.$forceUpdate</code>、<code>vm.$nextTick</code>和<code>vm.$destory</code>。</p> <ul><li><code>vm.$mount</code></li> <li><code>vm.$forceUpdate</code></li> <li><code>vm.$nextTick</code></li> <li><code>vm.$destory</code></li></ul> <p><strong><code>vm.$mount</code></strong></p> <p>官方使用如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$mount( [elementOrSelector] )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数</strong></p> <ul><li><code>{Element | string} [elementOrSelector]</code></li> <li><code>{boolean} [hydrating]</code></li></ul></li> <li><p><strong>返回值</strong>：<code>vm</code>- 实例自身</p></li> <li><p><strong>作用</strong>
如果<code>Vue</code>实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用<code>vm.$mount()</code>手动地挂载一个未挂载的实例。</p> <p>如果没有提供<code>elementOrSelector</code>参数，模板将被渲染为文档之外的元素，并且你必须使用原生<code>DOM API</code>把它插入文档中。</p></li> <li><p><strong>内部原理</strong></p></li></ul> <p>该方法的内部原理在介绍<strong>生命周期篇的模板编译阶段</strong>中已经详细分析过，此处不再重复。</p> <p><strong><code>vm.$forceUpdate</code></strong></p> <p>用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$forceUpdate()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>作用：</strong> 迫使<code>Vue</code>实例重新渲染</p></li> <li><p><strong>内部原理</strong></p></li></ul> <p>关于该方法的内部原理在介绍<strong>生命周期篇的模板编译阶段</strong>中已经详细分析过，此处不再重复。</p> <p><strong><code>vm.$forceUpdate</code></strong></p> <p>其使用如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$forceUpdate()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>作用：</strong></li></ul> <p>迫使<code>Vue</code>实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p> <ul><li><strong>内部原理</strong></li></ul> <p>当实例依赖的数据发生变化时，变化的数据会通知其收集的依赖列表中的依赖进行更新，收集依赖就是收集<code>watcher</code>，依赖更新就是<code>watcher</code>调用<code>update</code>方法更新，所以实例依赖的数据发生变化时，就会通知实例<code>watcher</code>去执行<code>update</code>方法进行更新。</p> <p>代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$forceUpdate = function () {
    const vm: Component = this
    if (vm._watcher) {
        vm._watcher.update()
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong><code>vm.$nextTick</code></strong></p> <p>参考<a href="https://km.xiaowuzi.info/js/vue-nexttick.html" target="_blank" rel="noopener noreferrer">Vue.netTick 理解与分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><strong><code>vm.$destory</code></strong></p> <p>其官方用法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$destroy()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>用法：</strong></li></ul> <p>完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。</p> <p>触发 <code>beforeDestroy</code> 和 <code>destroyed</code> 的钩子。</p> <h3 id="七、全局-api-篇"><a href="#七、全局-api-篇" class="header-anchor">#</a> 七、全局 API 篇</h3> <p>与实例方法不同，实例方法是将方法挂载到<code>Vue</code>的原型上，而全局 API 是直接在<code>Vue</code>上挂载方法。在<code>Vue</code>中，全局 API 一共有 12 个，分别是<code>Vue.extend</code>、<code>Vue.nextTick</code>、<code>Vue.set</code>、<code>Vue.delete</code>、<code>Vue.directive</code>、<code>Vue.filter</code>、<code>Vue.component</code>、<code>Vue.use</code>、<code>Vue.mixin</code>、<code>Vue.observable</code>、<code>Vue.version</code>。这 12 个 API 中有的是我们在日常业务开发中经常会用到的，有的是对 Vue 内部或外部插件提供的，我们在日常业务开发中几乎用不到。</p> <ol><li>Vue.extend</li> <li>Vue.nextTick</li> <li>Vue.set</li> <li>Vue.delete</li> <li>Vue.directive</li> <li>Vue.filter</li> <li>Vue.component</li> <li>directive、filter、component 小结</li> <li>Vue.use</li> <li>Vue.mixin</li> <li>Vue.compile</li> <li>Vue.observable</li> <li>Vue.version</li></ol> <h4 id="_7-1-vue-extend"><a href="#_7-1-vue-extend" class="header-anchor">#</a> 7.1 Vue.extend</h4> <p>既然是<code>Vue</code>类的子类，那么除了它本身独有的一些属性方法，还有一些是从<code>Vue</code>类中继承而来，所以创建子类的过程其实就是一边给子类上添加上独有的属性，一边将父类的公共属性到子类上。接下来，我们就来看看源码是如何实现这个过程的。</p> <p>该 API 的定义位于源码的<code>src/core/global-api/extend.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
Vue.extend = function (extendOptions: Object): Function {
extendOptions = extendOptions || {}
const Super = this
const SuperId = Super.cid
const cachedCtors = extendOptions.\_Ctor || (extendOptions.\_Ctor = {})
if (cachedCtors[SuperId]) {
return cachedCtors[SuperId]
}

    const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' &amp;&amp; name) {
        validateComponentName(name)
    }

    const Sub = function VueComponent (options) {
        this._init(options)
    }
    Sub.prototype = Object.create(Super.prototype)
    Sub.prototype.constructor = Sub
    Sub.cid = cid++
    Sub.options = mergeOptions(
        Super.options,
        extendOptions
    )
    Sub['super'] = Super

    if (Sub.options.props) {
        initProps(Sub)
    }
    if (Sub.options.computed) {
        initComputed(Sub)
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type]
    })
    // enable recursive self-lookup
    if (name) {
        Sub.options.components[name] = Sub
    }

    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    Sub.sealedOptions = extend({}, Sub.options)

    // cache constructor
    cachedCtors[SuperId] = Sub
    return Sub

}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br></div></div><h4 id="_7-2-vue-nexttick"><a href="#_7-2-vue-nexttick" class="header-anchor">#</a> 7.2 Vue.nextTick</h4> <p>全局 nextTick 方法同实例 nextTick 方法一样</p> <h4 id="_7-3-vue-set"><a href="#_7-3-vue-set" class="header-anchor">#</a> 7.3 Vue.set</h4> <p>全局 set 方法同实例 set 方法一样</p> <h4 id="_7-4-vue-delete"><a href="#_7-4-vue-delete" class="header-anchor">#</a> 7.4 Vue.delete</h4> <p>全局 delete 方法同实例 delete 方法一样</p> <h4 id="_7-5-vue-directive"><a href="#_7-5-vue-directive" class="header-anchor">#</a> 7.5 Vue.directive</h4> <p>其用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.directive( id, [definition] )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{string} id</code></li> <li><code>{Function | Object} [definition]</code></li></ul></li> <li><p><strong>作用：</strong></p> <p>注册或获取全局指令。</p></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>原理分析</strong></li></ul> <h4 id="_7-6-vue-filter"><a href="#_7-6-vue-filter" class="header-anchor">#</a> 7.6 Vue.filter</h4> <p>其用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.filter( id, [definition] )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>参数：</strong> <ul><li><code>{string} id</code></li> <li><code>{Function} [definition]</code></li></ul></li> <li><strong>作用</strong></li></ul> <p>注册或获取全局过滤器。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 注册
Vue.filter('my-filter', function (value) {
  // 返回处理后的值
})

// getter，返回已注册的过滤器
var myFilter = Vue.filter('my-filter')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><strong>原理分析</strong></li></ul> <p>该 API 是用来注册或获取全局过滤器的，接收两个参数：过滤器<code>id</code>和过滤的定义。同全局指令一样，注册过滤器是将定义好的过滤器存放在某个位置，获取过滤器是根据过滤器<code>id</code>从存放过滤器的位置来读取过滤器。</p> <p>其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.options = Object.create(null)
Vue.options['filters'] = Object.create(null)

Vue.filter= function (id,definition) {
    if (!definition) {
        return this.options['filters'][id]
    } else {
        this.options['filters'][id] = definition
        return definition
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>跟全局指令一样，<code>Vue.options['filters']</code>是用来存放全局过滤器的地方。还是根据是否传入了<code>definition</code>参数来决定本次操作是注册过滤器还是获取过滤器。如果没有传入<code>definition</code>参数，则表示本次操作为获取过滤器，那么就从存放过滤器的地方根据过滤器<code>id</code>来读取过滤器并返回；如果传入了<code>definition</code>参数，则表示本次操作为注册过滤器，那就直接将其保存在<code>this.options['filters']</code>中。</p> <h4 id="_7-7-vue-component"><a href="#_7-7-vue-component" class="header-anchor">#</a> 7.7 Vue.component</h4> <p>其用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.component( id, [definition] )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{string} id</code></li> <li><code>{Function | Object} [definition]</code></li></ul></li> <li><p><strong>作用：</strong></p> <p>注册或获取全局组件。注册还会自动使用给定的<code>id</code>设置组件的名称</p></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 注册组件，传入一个扩展过的构造器
Vue.component('my-component', Vue.extend({ /* ... */ }))

// 注册组件，传入一个选项对象 (自动调用 Vue.extend)
Vue.component('my-component', { /* ... */ })

// 获取注册的组件 (始终返回构造器)
var MyComponent = Vue.component('my-component')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_7-8-directive、filter、component-小结"><a href="#_7-8-directive、filter、component-小结" class="header-anchor">#</a> 7.8 directive、filter、component 小结</h4> <p>通过对<code>Vue.directive</code>、<code>Vue.filter</code>和<code>Vue.component</code>这三个 API 的分析，细心的你肯定会发现这三个 API 的代码实现非常的相似，是的，这是我们为了便于理解故意拆开的，其实在源码中这三个 API 的实现是写在一起的，</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export const ASSET_TYPES = [
  'component',
  'directive',
  'filter'
]

Vue.options = Object.create(null)
ASSET_TYPES.forEach(type =&gt; {
    Vue.options[type + 's'] = Object.create(null)
})

ASSET_TYPES.forEach(type =&gt; {
    Vue[type] = function (id,definition) {
        if (!definition) {
            return this.options[type + 's'][id]
        } else {
            if (process.env.NODE_ENV !== 'production' &amp;&amp; type === 'component') {
                validateComponentName(id)
            }
            if (type === 'component' &amp;&amp; isPlainObject(definition)) {
                definition.name = definition.name || id
                definition = this.options._base.extend(definition)
            }
            if (type === 'directive' &amp;&amp; typeof definition === 'function') {
                definition = { bind: definition, update: definition }
            }
            this.options[type + 's'][id] = definition
            return definition
        }
    }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><h4 id="_7-9-vue-use"><a href="#_7-9-vue-use" class="header-anchor">#</a> 7.9 Vue.use</h4> <p>其用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.use( plugin )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{Object | Function} plugin</code></li></ul></li> <li><p><strong>作用：</strong></p></li></ul> <p>安装 Vue.js 插件。如果插件是一个对象，必须提供<code>install</code>方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将<code>Vue</code>作为参数传入。</p> <ul><li><strong>原理分析：</strong></li></ul> <p>该 API 的定义位于源码的<code>src/core/global-api/use.js</code>中，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
Vue.use = function (plugin) {
const installedPlugins = (this.\_installedPlugins || (this.\_installedPlugins = []))
if (installedPlugins.indexOf(plugin) &gt; -1) {
return this
}

    // additional parameters
    const args = toArray(arguments, 1)
    args.unshift(this)
    if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args)
    } else if (typeof plugin === 'function') {
        plugin.apply(null, args)
    }
    installedPlugins.push(plugin)
    return this

}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>在该函数内部，首先定义了一个变量<code>installedPlugins</code>，该变量初始值是一个空数组，用来存储已安装过的插件。首先判断传入的插件是否存在于<code>installedPlugins</code>数组中（即已经被安装过），如果存在的话，则直接返回，防止重复安装。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))
if (installedPlugins.indexOf(plugin) &gt; -1) {
    return this
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接下来获取到传入的其余参数，并且使用<code>toArray</code>方法将其转换成数组，同时将 <code>Vue</code> 插入到该数组的第一个位置，这是因为在后续调用 <code>install</code> 方法时，<code>Vue</code> 必须作为第一个参数传入。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const args = toArray(arguments, 1)
args.unshift(this)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>首先，判断传入的插件如果是一个提供了<code>install</code>方法的对象，那么就执行该对象中提供的<code>install</code>方法并传入参数完成插件安装。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (typeof plugin.install === 'function') {
    plugin.install.apply(plugin, args)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果传入的插件是一个函数，那么就把这个函数当作<code>install</code>方法执行，同时传入参数完成插件安装。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>else if (typeof plugin === 'function') {
    plugin.apply(null, args)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果传入的插件是一个函数，那么就把这个函数当作<code>install</code>方法执行，同时传入参数完成插件安装。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>else if (typeof plugin === 'function') {
    plugin.apply(null, args)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>插件安装完成之后，将该插件添加进已安装插件列表中，防止重复安装。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>installedPlugins.push(plugin)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_7-10-vue-mixin"><a href="#_7-10-vue-mixin" class="header-anchor">#</a> 7.10 Vue.mixin</h4> <p>其用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.mixin( mixin )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{Object} mixin</code></li></ul></li> <li><p><strong>作用：</strong></p></li></ul> <p>全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。</p> <ul><li><strong>原理分析</strong></li></ul> <p>该 API 的定义位于源码的 <code>src/core/global-api/mixin.js</code> 中，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.mixin = function (mixin: Object) {
    this.options = mergeOptions(this.options, mixin)
    return this
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="八、过滤器篇"><a href="#八、过滤器篇" class="header-anchor">#</a> 八、过滤器篇</h3> <h4 id="_8-1-resolvefilter-函数分析"><a href="#_8-1-resolvefilter-函数分析" class="header-anchor">#</a> 8.1 resolveFilter 函数分析</h4> <p><code>resolveFilter</code>函数的定义位于源码的<code>src/core/instance/render-helper.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import { identity, resolveAsset } from 'core/util/index'

export function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可以盾到，<code>resolveFilter</code>函数内部只有一行代码，就是调用<code>resolveAsset</code>函数并获取其返回值，如果返回值不存在，则返回<code>identity</code>，而<code>identity</code>是一个返回同参数一样的值，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/**
 * Return same value
 */
export const identity = _ =&gt; _
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>resolveAsset</code>函数，该函数的定义位于源码的<code>src/core/util/options.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function resolveAsset (options,type,id,warnMissing) {
  if (typeof id !== 'string') {
    return
  }
  const assets = options[type]
  // 先从本地注册中查找
  if (hasOwn(assets, id)) return assets[id]
  const camelizedId = camelize(id)
  if (hasOwn(assets, camelizedId)) return assets[camelizedId]
  const PascalCaseId = capitalize(camelizedId)
  if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId]
  // 再从原型链中查找
  const res = assets[id] || assets[camelizedId] || assets[PascalCaseId]
  if (process.env.NODE_ENV !== 'production' &amp;&amp; warnMissing &amp;&amp; !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    )
  }
  return res
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>调用该函数时传入了 4 个参数，分别是当前实例的<code>$options</code>属性，<code>type</code>为<code>filters</code>，<code>id</code>为当前过滤器的<code>id</code>。</p> <h4 id="_8-2-parsefilters-函数分析"><a href="#_8-2-parsefilters-函数分析" class="header-anchor">#</a> 8.2 parseFilters 函数分析</h4> <p><code>parseFilters</code>函数的定义位于源码的<code>src/complier/parser/filter-parser.js</code>文件中，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function parseFilters (exp) {
  let inSingle = false                     // exp是否在 '' 中
  let inDouble = false                     // exp是否在 &quot;&quot; 中
  let inTemplateString = false             // exp是否在 `` 中
  let inRegex = false                      // exp是否在 \\ 中
  let curly = 0                            // 在exp中发现一个 { 则curly加1，发现一个 } 则curly减1，直到culy为0 说明 { ... }闭合
  let square = 0                           // 在exp中发现一个 [ 则curly加1，发现一个 ] 则curly减1，直到culy为0 说明 [ ... ]闭合
  let paren = 0                            // 在exp中发现一个 ( 则curly加1，发现一个 ) 则curly减1，直到culy为0 说明 ( ... )闭合
  let lastFilterIndex = 0
  let c, prev, i, expression, filters


  for (i = 0; i &lt; exp.length; i++) {
    prev = c
    c = exp.charCodeAt(i)
    if (inSingle) {
      if (c === 0x27 &amp;&amp; prev !== 0x5C) inSingle = false
    } else if (inDouble) {
      if (c === 0x22 &amp;&amp; prev !== 0x5C) inDouble = false
    } else if (inTemplateString) {
      if (c === 0x60 &amp;&amp; prev !== 0x5C) inTemplateString = false
    } else if (inRegex) {
      if (c === 0x2f &amp;&amp; prev !== 0x5C) inRegex = false
    } else if (
      c === 0x7C &amp;&amp; // pipe
      exp.charCodeAt(i + 1) !== 0x7C &amp;&amp;
      exp.charCodeAt(i - 1) !== 0x7C &amp;&amp;
      !curly &amp;&amp; !square &amp;&amp; !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1
        expression = exp.slice(0, i).trim()
      } else {
        pushFilter()
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // &quot;
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        let j = i - 1
        let p
        // find first non-whitespace prev char
        for (; j &gt;= 0; j--) {
          p = exp.charAt(j)
          if (p !== ' ') break
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim()
  } else if (lastFilterIndex !== 0) {
    pushFilter()
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim())
    lastFilterIndex = i + 1
  }

  if (filters) {
    for (i = 0; i &lt; filters.length; i++) {
      expression = wrapFilter(expression, filters[i])
    }
  }

  return expression
}

function wrapFilter (exp: string, filter: string): string {
  const i = filter.indexOf('(')
  if (i &lt; 0) {
    // _f: resolveFilter
    return `_f(&quot;${filter}&quot;)(${exp})`
  } else {
    const name = filter.slice(0, i)
    const args = filter.slice(i + 1)
    return `_f(&quot;${name}&quot;)(${exp}${args !== ')' ? ',' + args : args}`
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br></div></div><p>该函数的作用的是将传入的形如<code>'message | capitalize'</code>这样的过滤器字符串转化成<code>_f(&quot;capitalize&quot;)(message)</code>，接下来我们就来分析一下其内部逻辑。</p> <p>在该函数内部，首先定义了一些变量，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let inSingle = false
let inDouble = false
let inTemplateString = false
let inRegex = false
let curly = 0
let square = 0
let paren = 0
let lastFilterIndex = 0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>inSingle：标志 exp 是否在'...'中；</li> <li>inDouble：标志 exp 是否在&quot;...&quot;中；</li> <li>inTemplateString：标志 exp 是否在`...`中；</li> <li>inRegex：标志 exp 是否在\...\中；</li> <li>curly = 0：；</li></ul> <h3 id="九、指令篇"><a href="#九、指令篇" class="header-anchor">#</a> 九、指令篇</h3> <p>在<code>Vue</code>中，除了<code>Vue</code>本身为我们提供的一些内置指令之外，<code>Vue</code>还支持用户自定义指令。并且用户有两种定义的方式：一种是使用全局 API——<code>Vue.directive</code>来定义全局指令，这种方式定义的指令会被存放在<code>Vue.options['directives']</code>中；另一种是在组件内的<code>directive</code>选项专为该组件使用的局部指令，这种方式定义的指令会被存放在<code>vm.$options['directives']</code>中。</p> <h4 id="_9-1-何时生效"><a href="#_9-1-何时生效" class="header-anchor">#</a> 9.1 何时生效</h4> <p>在虚拟<code>DOM</code>渲染更新的时候，它在执行相关操作的同时，还会在每个阶段触发相应的钩子函数，我们只需监听不同的钩子函数，就可以在虚拟<code>DOM</code>渲染更新的不同阶段做一些额外的事情。下表给出了虚拟<code>DOM</code> 在渲染更新的不同阶段所触发的不同的钩子函数及其触发时机：</p> <table><thead><tr><th>钩子函数名称</th> <th>触发时机</th> <th>回调参数</th></tr></thead> <tbody><tr><td>init</td> <td>已创建 VNode，在 patch 期间发现新的虚拟节点时被触发</td> <td>VNode</td></tr> <tr><td>create</td> <td>已基于 VNode 创建了 DOM 元素</td> <td>emptyNode 和 VNode</td></tr> <tr><td>activate</td> <td>keep-alive 组件被创建</td> <td>emptyNode 和 innerNode</td></tr> <tr><td>insert</td> <td>VNode 对应的</td> <td>VNode</td></tr> <tr><td>prepatch</td> <td>已创建 VNode，在 patch 期间发现新的虚拟节点时被触发</td> <td>VNode</td></tr> <tr><td>update</td> <td>已创建 VNode，在 patch 期间发现新的虚拟节点时被触发</td> <td>VNode</td></tr> <tr><td>postpatch</td> <td>已创建 VNode，在 patch 期间发现新的虚拟节点时被触发</td> <td>VNode</td></tr> <tr><td>destory</td> <td>已创建 VNode，在 patch 期间发现新的虚拟节点时被触发</td> <td>VNode</td></tr> <tr><td>remove</td> <td>已创建 VNode，在 patch 期间发现新的虚拟节点时被触发</td> <td>VNode</td></tr></tbody></table> <h4 id="_9-2-指令钩子函数"><a href="#_9-2-指令钩子函数" class="header-anchor">#</a> 9.2 指令钩子函数</h4> <p><code>Vue</code>对于自定义指令定义对象提供了几个钩子函数，这几个钩子函数分别对应着指令的几种状态，一个指令从第一次被绑定到元素上到最终与被绑定的元素解绑，它会经过以下几种状态：</p> <ul><li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li> <li>inserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</li> <li>update：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong></li> <li>componentUpdated：指令所在组件的 VNode<strong>及其子 VNode</strong>全部更新后调用。</li> <li>unbind：只调用一次，指令与元素解绑时调用。</li></ul> <h4 id="_9-3-如何生效"><a href="#_9-3-如何生效" class="header-anchor">#</a> 9.3 如何生效</h4> <p>当虚拟<code>DOM</code>渲染更新的时候会触发<code>create</code>、<code>update</code>、<code>destory</code>这三个钩子函数，从而就会执行<code>updateDirectives</code>函数来处理指令的想着逻辑，执行指令函数，让指令生效。</p> <p><code>updateDirectives</code>函数的定义位于源码的<code>src/core/vdom/modules/directives.js</code>文件中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function updateDirectives (oldVnode: VNodeWithData, vnode: VNodeWithData) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode)
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>_update</code>方法定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function _update (oldVnode, vnode) {
  const isCreate = oldVnode === emptyNode
  const isDestroy = vnode === emptyNode
  const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context)
  const newDirs = normalizeDirectives(vnode.data.directives, vnode.context)

  const dirsWithInsert = []
  const dirsWithPostpatch = []

  let key, oldDir, dir
  for (key in newDirs) {
    oldDir = oldDirs[key]
    dir = newDirs[key]
    if (!oldDir) {
      // new directive, bind
      callHook(dir, 'bind', vnode, oldVnode)
      if (dir.def &amp;&amp; dir.def.inserted) {
        dirsWithInsert.push(dir)
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value
      dir.oldArg = oldDir.arg
      callHook(dir, 'update', vnode, oldVnode)
      if (dir.def &amp;&amp; dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir)
      }
    }
  }

  if (dirsWithInsert.length) {
    const callInsert = () =&gt; {
      for (let i = 0; i &lt; dirsWithInsert.length; i++) {
        callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode)
      }
    }
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert)
    } else {
      callInsert()
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', () =&gt; {
      for (let i = 0; i &lt; dirsWithPostpatch.length; i++) {
        callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode)
      }
    })
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy)
      }
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br></div></div><p>可以看到，该方法内首先定义了一些变量，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const isCreate = oldVnode === emptyNode
const isDestroy = vnode === emptyNode
const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context)
const newDirs = normalizeDirectives(vnode.data.directives, vnode.context)

const dirsWithInsert = []
const dirsWithPostpatch = []
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>isCreate：判断当前节点<code>vnode</code>对应的旧节点<code>oldVnode</code>是不是一个空节点，如果是的话，表明当前节点是一个新创建的节点。</li> <li>isDestroy：判断当前节点<code>vnode</code>是不是一个空节点，如果是的话，表明当前节点对应的旧节点将要被销毁。</li> <li>oldDirs：旧的指令集合，即<code>oldVnode</code>中保存的指令。</li> <li>newDirs：新的指令集合，即<code>vnode</code>中保存的指令。</li> <li>dirsWithInsert：保存需要触发<code>inserted</code>指令钩子函数的指令列表。</li> <li>dirsWidthPostpatch：保存需要触发<code>componentUpdated</code>指令钩子函数的指令列表。</li></ul> <h3 id="十、总结"><a href="#十、总结" class="header-anchor">#</a> 十、总结</h3> <p><img src="vue-code.png" alt="images"></p> <h3 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h3> <ul><li><a href="https://github.com/muwoo/blogs" target="_blank" rel="noopener noreferrer">vue 源码分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://hcysun.me/vue-design/art/" target="_blank" rel="noopener noreferrer">Vue 技术内幕<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener noreferrer">Vue.js 技术揭秘<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener noreferrer">Vue.js 源码解析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/dirkhe1051931999/hjBlog/tree/master/blog-vue-sourcecode-study" target="_blank" rel="noopener noreferrer">你想要的 vue 源码分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5ce5565d6fb9a07ed2244513" target="_blank" rel="noopener noreferrer">学习 Vue 源码的必要知识储备<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://nlrx-wjc.github.io/Learn-Vue-Source-Code/start/" target="_blank" rel="noopener noreferrer">逐行剖析 Vue.js 源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener noreferrer">渲染器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.cnblogs.com/tugenhua0707/category/1577630.html" target="_blank" rel="noopener noreferrer">深入 Vue 技术栈及源码系列<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://www.zhufengpeixun.cn/train/vue-info/source.html" target="_blank" rel="noopener noreferrer">Vue 原理剖析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/lihongxun945/myblog/issues/22" target="_blank" rel="noopener noreferrer">Vue2.x 源码解析系列一：我的源码阅读心得<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>《深入浅出 Vue.js》</li></ul> <h2 id="联系作者"><a href="#联系作者" class="header-anchor">#</a> 联系作者</h2> <div align="center"><p>
        平凡世界，贵在坚持。
    </p> <img src="/about/contact.png"></div>
```
</div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新于:</span> <span class="time">2015/11/13 下午2:35:04</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/js/vue-vuex-code.html" class="prev">
        vue-vuex 源码分析
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----><!----><div></div></div></div>
    <script src="/assets/js/app.6429a744.js" defer></script><script src="/assets/js/2.c7f5c1a5.js" defer></script><script src="/assets/js/208.b97b4b55.js" defer></script><script src="/assets/js/3.fb5a4386.js" defer></script>
  </body>
</html>
