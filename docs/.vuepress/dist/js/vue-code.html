<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue 源码分析 | 小武子知识库</title>
    <meta name="description" content="用心，谈技术。大前端">
    <link rel="icon" href="/hero.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.29089cef.css" as="style"><link rel="preload" href="/assets/js/app.e6aa2542.js" as="script"><link rel="preload" href="/assets/js/2.274a054e.js" as="script"><link rel="preload" href="/assets/js/200.63b2f061.js" as="script"><link rel="preload" href="/assets/js/3.65dbdf4c.js" as="script"><link rel="prefetch" href="/assets/js/10.aef65459.js"><link rel="prefetch" href="/assets/js/100.7471f0b6.js"><link rel="prefetch" href="/assets/js/101.73424917.js"><link rel="prefetch" href="/assets/js/102.72402d46.js"><link rel="prefetch" href="/assets/js/103.c139240a.js"><link rel="prefetch" href="/assets/js/104.d19c7143.js"><link rel="prefetch" href="/assets/js/105.15522215.js"><link rel="prefetch" href="/assets/js/106.86b41d0b.js"><link rel="prefetch" href="/assets/js/107.4e2f0e4e.js"><link rel="prefetch" href="/assets/js/108.a1682d5b.js"><link rel="prefetch" href="/assets/js/109.81b8baea.js"><link rel="prefetch" href="/assets/js/11.da35ea5c.js"><link rel="prefetch" href="/assets/js/110.973f4408.js"><link rel="prefetch" href="/assets/js/111.207749aa.js"><link rel="prefetch" href="/assets/js/112.0e34b644.js"><link rel="prefetch" href="/assets/js/113.1b8168c5.js"><link rel="prefetch" href="/assets/js/114.4256b5bc.js"><link rel="prefetch" href="/assets/js/115.2efbcf1c.js"><link rel="prefetch" href="/assets/js/116.c3a6cf10.js"><link rel="prefetch" href="/assets/js/117.789e4104.js"><link rel="prefetch" href="/assets/js/118.63d77cda.js"><link rel="prefetch" href="/assets/js/119.4d5b48ba.js"><link rel="prefetch" href="/assets/js/12.8364525f.js"><link rel="prefetch" href="/assets/js/120.980160ae.js"><link rel="prefetch" href="/assets/js/121.5b871b65.js"><link rel="prefetch" href="/assets/js/122.7d73e74c.js"><link rel="prefetch" href="/assets/js/123.d1330219.js"><link rel="prefetch" href="/assets/js/124.69bd6867.js"><link rel="prefetch" href="/assets/js/125.ce6c84f7.js"><link rel="prefetch" href="/assets/js/126.6d5724c4.js"><link rel="prefetch" href="/assets/js/127.e835dc45.js"><link rel="prefetch" href="/assets/js/128.06161a39.js"><link rel="prefetch" href="/assets/js/129.64f24805.js"><link rel="prefetch" href="/assets/js/13.bae4dad9.js"><link rel="prefetch" href="/assets/js/130.24255b61.js"><link rel="prefetch" href="/assets/js/131.efd142f6.js"><link rel="prefetch" href="/assets/js/132.97e7d184.js"><link rel="prefetch" href="/assets/js/133.62996613.js"><link rel="prefetch" href="/assets/js/134.93ae724d.js"><link rel="prefetch" href="/assets/js/135.85abe91a.js"><link rel="prefetch" href="/assets/js/136.edf0bd5d.js"><link rel="prefetch" href="/assets/js/137.0de4651a.js"><link rel="prefetch" href="/assets/js/138.719f5ffe.js"><link rel="prefetch" href="/assets/js/139.41fec342.js"><link rel="prefetch" href="/assets/js/14.36590bec.js"><link rel="prefetch" href="/assets/js/140.777ad6aa.js"><link rel="prefetch" href="/assets/js/141.17346522.js"><link rel="prefetch" href="/assets/js/142.221b21c3.js"><link rel="prefetch" href="/assets/js/143.dbad9efa.js"><link rel="prefetch" href="/assets/js/144.040c0d4f.js"><link rel="prefetch" href="/assets/js/145.be1068d9.js"><link rel="prefetch" href="/assets/js/146.d32dadb8.js"><link rel="prefetch" href="/assets/js/147.d22289ef.js"><link rel="prefetch" href="/assets/js/148.bcf8a2fc.js"><link rel="prefetch" href="/assets/js/149.de4487a8.js"><link rel="prefetch" href="/assets/js/15.01548ff0.js"><link rel="prefetch" href="/assets/js/150.ddc05661.js"><link rel="prefetch" href="/assets/js/151.e15b6062.js"><link rel="prefetch" href="/assets/js/152.5ff58960.js"><link rel="prefetch" href="/assets/js/153.4dfc8b3e.js"><link rel="prefetch" href="/assets/js/154.16449054.js"><link rel="prefetch" href="/assets/js/155.b575016d.js"><link rel="prefetch" href="/assets/js/156.88627da5.js"><link rel="prefetch" href="/assets/js/157.6fd5fba4.js"><link rel="prefetch" href="/assets/js/158.07a82f5e.js"><link rel="prefetch" href="/assets/js/159.c1dc663c.js"><link rel="prefetch" href="/assets/js/16.58553274.js"><link rel="prefetch" href="/assets/js/160.af7858bb.js"><link rel="prefetch" href="/assets/js/161.3d7aeaf6.js"><link rel="prefetch" href="/assets/js/162.79ef5604.js"><link rel="prefetch" href="/assets/js/163.d23bc50b.js"><link rel="prefetch" href="/assets/js/164.17ce6859.js"><link rel="prefetch" href="/assets/js/165.d5735b2a.js"><link rel="prefetch" href="/assets/js/166.4ebdbf98.js"><link rel="prefetch" href="/assets/js/167.9f0e23f8.js"><link rel="prefetch" href="/assets/js/168.baf65ab3.js"><link rel="prefetch" href="/assets/js/169.9bcbf1f2.js"><link rel="prefetch" href="/assets/js/17.a3ff3767.js"><link rel="prefetch" href="/assets/js/170.7fae4329.js"><link rel="prefetch" href="/assets/js/171.f8bf8f6e.js"><link rel="prefetch" href="/assets/js/172.c4e71243.js"><link rel="prefetch" href="/assets/js/173.967e3ac9.js"><link rel="prefetch" href="/assets/js/174.3dd85add.js"><link rel="prefetch" href="/assets/js/175.4cf34a2f.js"><link rel="prefetch" href="/assets/js/176.3f17329f.js"><link rel="prefetch" href="/assets/js/177.f73200a2.js"><link rel="prefetch" href="/assets/js/178.316c4d3c.js"><link rel="prefetch" href="/assets/js/179.066e1ca7.js"><link rel="prefetch" href="/assets/js/18.11f8e3d5.js"><link rel="prefetch" href="/assets/js/180.2d49dcad.js"><link rel="prefetch" href="/assets/js/181.493442e9.js"><link rel="prefetch" href="/assets/js/182.0b8ba4ca.js"><link rel="prefetch" href="/assets/js/183.b16c3a05.js"><link rel="prefetch" href="/assets/js/184.baebf891.js"><link rel="prefetch" href="/assets/js/185.6137157d.js"><link rel="prefetch" href="/assets/js/186.a83cae27.js"><link rel="prefetch" href="/assets/js/187.a5b52398.js"><link rel="prefetch" href="/assets/js/188.a7229947.js"><link rel="prefetch" href="/assets/js/189.f1455daa.js"><link rel="prefetch" href="/assets/js/19.f3d93a65.js"><link rel="prefetch" href="/assets/js/190.081d930e.js"><link rel="prefetch" href="/assets/js/191.9f5a8a96.js"><link rel="prefetch" href="/assets/js/192.f309ace7.js"><link rel="prefetch" href="/assets/js/193.9b69455f.js"><link rel="prefetch" href="/assets/js/194.957a0538.js"><link rel="prefetch" href="/assets/js/195.93e92e1b.js"><link rel="prefetch" href="/assets/js/196.13f7eaac.js"><link rel="prefetch" href="/assets/js/197.959de939.js"><link rel="prefetch" href="/assets/js/198.2b587a39.js"><link rel="prefetch" href="/assets/js/199.26793fa4.js"><link rel="prefetch" href="/assets/js/20.af63466f.js"><link rel="prefetch" href="/assets/js/201.1d02fcce.js"><link rel="prefetch" href="/assets/js/202.0d5d1312.js"><link rel="prefetch" href="/assets/js/203.7c43b1e3.js"><link rel="prefetch" href="/assets/js/204.b72e7f98.js"><link rel="prefetch" href="/assets/js/205.a088bf70.js"><link rel="prefetch" href="/assets/js/206.75da4c83.js"><link rel="prefetch" href="/assets/js/207.a550138f.js"><link rel="prefetch" href="/assets/js/208.47a7687d.js"><link rel="prefetch" href="/assets/js/209.4a1de82a.js"><link rel="prefetch" href="/assets/js/21.bc5f6397.js"><link rel="prefetch" href="/assets/js/210.b646b5a2.js"><link rel="prefetch" href="/assets/js/211.9a3f2d38.js"><link rel="prefetch" href="/assets/js/212.69256a2a.js"><link rel="prefetch" href="/assets/js/213.6d8b2d5a.js"><link rel="prefetch" href="/assets/js/214.ee88b89f.js"><link rel="prefetch" href="/assets/js/215.0b75f987.js"><link rel="prefetch" href="/assets/js/216.e87d0f42.js"><link rel="prefetch" href="/assets/js/217.958ae3b1.js"><link rel="prefetch" href="/assets/js/218.081d2489.js"><link rel="prefetch" href="/assets/js/219.a5c6aa48.js"><link rel="prefetch" href="/assets/js/22.af424005.js"><link rel="prefetch" href="/assets/js/220.5e5b21fc.js"><link rel="prefetch" href="/assets/js/221.5af6bc98.js"><link rel="prefetch" href="/assets/js/222.397d64fd.js"><link rel="prefetch" href="/assets/js/223.bd68e952.js"><link rel="prefetch" href="/assets/js/224.a9899055.js"><link rel="prefetch" href="/assets/js/225.4984bb72.js"><link rel="prefetch" href="/assets/js/226.16980719.js"><link rel="prefetch" href="/assets/js/227.57ec9198.js"><link rel="prefetch" href="/assets/js/228.b4b9e1ab.js"><link rel="prefetch" href="/assets/js/229.8feedc41.js"><link rel="prefetch" href="/assets/js/23.9df45bd1.js"><link rel="prefetch" href="/assets/js/230.c4558465.js"><link rel="prefetch" href="/assets/js/231.2a176740.js"><link rel="prefetch" href="/assets/js/232.293e75ce.js"><link rel="prefetch" href="/assets/js/233.3974cca7.js"><link rel="prefetch" href="/assets/js/234.e3e4f17f.js"><link rel="prefetch" href="/assets/js/235.94895d31.js"><link rel="prefetch" href="/assets/js/236.18b79308.js"><link rel="prefetch" href="/assets/js/237.5a2c56c8.js"><link rel="prefetch" href="/assets/js/238.d780ec22.js"><link rel="prefetch" href="/assets/js/239.f99e4141.js"><link rel="prefetch" href="/assets/js/24.2238092d.js"><link rel="prefetch" href="/assets/js/240.4587c9b2.js"><link rel="prefetch" href="/assets/js/241.652e9297.js"><link rel="prefetch" href="/assets/js/242.7350e0cf.js"><link rel="prefetch" href="/assets/js/243.19be4cdb.js"><link rel="prefetch" href="/assets/js/244.8d5ee08f.js"><link rel="prefetch" href="/assets/js/245.083c2221.js"><link rel="prefetch" href="/assets/js/246.570d4a34.js"><link rel="prefetch" href="/assets/js/247.6ae44617.js"><link rel="prefetch" href="/assets/js/248.4fd16900.js"><link rel="prefetch" href="/assets/js/249.68657d9d.js"><link rel="prefetch" href="/assets/js/25.ea461716.js"><link rel="prefetch" href="/assets/js/250.29dae0c6.js"><link rel="prefetch" href="/assets/js/251.f5a84583.js"><link rel="prefetch" href="/assets/js/252.6085bc34.js"><link rel="prefetch" href="/assets/js/253.12a26a7e.js"><link rel="prefetch" href="/assets/js/254.c168c363.js"><link rel="prefetch" href="/assets/js/255.1775aaca.js"><link rel="prefetch" href="/assets/js/256.45cee990.js"><link rel="prefetch" href="/assets/js/257.647d82b9.js"><link rel="prefetch" href="/assets/js/258.11ae16bf.js"><link rel="prefetch" href="/assets/js/259.208e846a.js"><link rel="prefetch" href="/assets/js/26.58a373a4.js"><link rel="prefetch" href="/assets/js/260.8b3b4485.js"><link rel="prefetch" href="/assets/js/261.6a95b5ba.js"><link rel="prefetch" href="/assets/js/262.79363aee.js"><link rel="prefetch" href="/assets/js/263.34dab30a.js"><link rel="prefetch" href="/assets/js/264.72463d56.js"><link rel="prefetch" href="/assets/js/265.5beb1ba0.js"><link rel="prefetch" href="/assets/js/266.c1407b65.js"><link rel="prefetch" href="/assets/js/267.f6e27b53.js"><link rel="prefetch" href="/assets/js/268.bd644243.js"><link rel="prefetch" href="/assets/js/269.8e4bb24b.js"><link rel="prefetch" href="/assets/js/27.884eb585.js"><link rel="prefetch" href="/assets/js/270.373a9665.js"><link rel="prefetch" href="/assets/js/271.7e26c44c.js"><link rel="prefetch" href="/assets/js/272.ac4de07c.js"><link rel="prefetch" href="/assets/js/273.963a8523.js"><link rel="prefetch" href="/assets/js/274.9a183b4b.js"><link rel="prefetch" href="/assets/js/275.527a1a08.js"><link rel="prefetch" href="/assets/js/276.6d79ccf6.js"><link rel="prefetch" href="/assets/js/277.dcf655ea.js"><link rel="prefetch" href="/assets/js/278.c9260e51.js"><link rel="prefetch" href="/assets/js/279.6b12e8d4.js"><link rel="prefetch" href="/assets/js/28.acd802c4.js"><link rel="prefetch" href="/assets/js/280.44cc5610.js"><link rel="prefetch" href="/assets/js/281.2b789a06.js"><link rel="prefetch" href="/assets/js/282.adef6c3f.js"><link rel="prefetch" href="/assets/js/29.0faa6964.js"><link rel="prefetch" href="/assets/js/30.d3551a97.js"><link rel="prefetch" href="/assets/js/31.176028d0.js"><link rel="prefetch" href="/assets/js/32.9d328e39.js"><link rel="prefetch" href="/assets/js/33.8f0154f9.js"><link rel="prefetch" href="/assets/js/34.a866c971.js"><link rel="prefetch" href="/assets/js/35.f75c2c05.js"><link rel="prefetch" href="/assets/js/36.dca0bbb5.js"><link rel="prefetch" href="/assets/js/37.6d4730ab.js"><link rel="prefetch" href="/assets/js/38.da1b259c.js"><link rel="prefetch" href="/assets/js/39.9e4e1a6e.js"><link rel="prefetch" href="/assets/js/4.a49af5c6.js"><link rel="prefetch" href="/assets/js/40.cc700c30.js"><link rel="prefetch" href="/assets/js/41.aad52eff.js"><link rel="prefetch" href="/assets/js/42.1c680d97.js"><link rel="prefetch" href="/assets/js/43.35e0ca47.js"><link rel="prefetch" href="/assets/js/44.4c0f6e28.js"><link rel="prefetch" href="/assets/js/45.498d9614.js"><link rel="prefetch" href="/assets/js/46.759fe128.js"><link rel="prefetch" href="/assets/js/47.08f9590d.js"><link rel="prefetch" href="/assets/js/48.03c0639a.js"><link rel="prefetch" href="/assets/js/49.70c49421.js"><link rel="prefetch" href="/assets/js/5.444b0f34.js"><link rel="prefetch" href="/assets/js/50.e750242e.js"><link rel="prefetch" href="/assets/js/51.dab64a9d.js"><link rel="prefetch" href="/assets/js/52.3b49453b.js"><link rel="prefetch" href="/assets/js/53.d25777d4.js"><link rel="prefetch" href="/assets/js/54.c196a1a1.js"><link rel="prefetch" href="/assets/js/55.52f1399d.js"><link rel="prefetch" href="/assets/js/56.d3c502ef.js"><link rel="prefetch" href="/assets/js/57.05e80294.js"><link rel="prefetch" href="/assets/js/58.e320974b.js"><link rel="prefetch" href="/assets/js/59.262d302a.js"><link rel="prefetch" href="/assets/js/6.444877f5.js"><link rel="prefetch" href="/assets/js/60.2e391790.js"><link rel="prefetch" href="/assets/js/61.55057cb4.js"><link rel="prefetch" href="/assets/js/62.b9ca9738.js"><link rel="prefetch" href="/assets/js/63.7509db7b.js"><link rel="prefetch" href="/assets/js/64.cd14869f.js"><link rel="prefetch" href="/assets/js/65.f76f2802.js"><link rel="prefetch" href="/assets/js/66.7b088bd8.js"><link rel="prefetch" href="/assets/js/67.05e42b78.js"><link rel="prefetch" href="/assets/js/68.f4ccc74b.js"><link rel="prefetch" href="/assets/js/69.0db1a021.js"><link rel="prefetch" href="/assets/js/7.fa06d8c5.js"><link rel="prefetch" href="/assets/js/70.b1b3a60b.js"><link rel="prefetch" href="/assets/js/71.e8431640.js"><link rel="prefetch" href="/assets/js/72.a2cceddc.js"><link rel="prefetch" href="/assets/js/73.7fb595ce.js"><link rel="prefetch" href="/assets/js/74.cc425a51.js"><link rel="prefetch" href="/assets/js/75.06036f2b.js"><link rel="prefetch" href="/assets/js/76.e01ed152.js"><link rel="prefetch" href="/assets/js/77.c2871fcf.js"><link rel="prefetch" href="/assets/js/78.8c8acf4d.js"><link rel="prefetch" href="/assets/js/79.b6e4b429.js"><link rel="prefetch" href="/assets/js/8.0507d873.js"><link rel="prefetch" href="/assets/js/80.72932063.js"><link rel="prefetch" href="/assets/js/81.36be4dd9.js"><link rel="prefetch" href="/assets/js/82.fc089fea.js"><link rel="prefetch" href="/assets/js/83.2c0daf33.js"><link rel="prefetch" href="/assets/js/84.e6dded5e.js"><link rel="prefetch" href="/assets/js/85.3c72b911.js"><link rel="prefetch" href="/assets/js/86.5c73edc8.js"><link rel="prefetch" href="/assets/js/87.4f3f6b4e.js"><link rel="prefetch" href="/assets/js/88.387cc3b0.js"><link rel="prefetch" href="/assets/js/89.b78889be.js"><link rel="prefetch" href="/assets/js/9.6a5a8a8e.js"><link rel="prefetch" href="/assets/js/90.31da6f66.js"><link rel="prefetch" href="/assets/js/91.57aaf7ed.js"><link rel="prefetch" href="/assets/js/92.eb0e1858.js"><link rel="prefetch" href="/assets/js/93.270f2fc6.js"><link rel="prefetch" href="/assets/js/94.105d7ab1.js"><link rel="prefetch" href="/assets/js/95.08aaa998.js"><link rel="prefetch" href="/assets/js/96.f85af3e9.js"><link rel="prefetch" href="/assets/js/97.78569e42.js"><link rel="prefetch" href="/assets/js/98.675fad73.js"><link rel="prefetch" href="/assets/js/99.f360fc5a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.29089cef.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">小武子知识库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/js/" class="nav-link router-link-active">javascript</a></div><div class="nav-item"><a href="/css/" class="nav-link">css</a></div><div class="nav-item"><a href="/html5/" class="nav-link">HTML5</a></div><div class="nav-item"><a href="/tool/" class="nav-link">工具</a></div><div class="nav-item"><a href="/project/" class="nav-link">软件工程</a></div><div class="nav-item"><a href="/cs/" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试题</a></div><div class="nav-item"><a href="/materials/" class="nav-link">资料收集</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于作者</a></div><div class="nav-item"><a href="https://www.github.com/fttony" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/js/" class="nav-link router-link-active">javascript</a></div><div class="nav-item"><a href="/css/" class="nav-link">css</a></div><div class="nav-item"><a href="/html5/" class="nav-link">HTML5</a></div><div class="nav-item"><a href="/tool/" class="nav-link">工具</a></div><div class="nav-item"><a href="/project/" class="nav-link">软件工程</a></div><div class="nav-item"><a href="/cs/" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试题</a></div><div class="nav-item"><a href="/materials/" class="nav-link">资料收集</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于作者</a></div><div class="nav-item"><a href="https://www.github.com/fttony" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>javascript基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/es5-expression.html" class="sidebar-link">表达式与运算符</a></li><li><a href="/js/es5-type.html" class="sidebar-link">JS 数据类型与数据类型转换</a></li><li><a href="/js/es5-prototype.html" class="sidebar-link">原型与原型链</a></li><li><a href="/js/es5-this.html" class="sidebar-link">this 解析</a></li><li><a href="/js/es5-closure.html" class="sidebar-link">闭包</a></li><li><a href="/js/es5-apply-call-bind.html" class="sidebar-link">apply&amp;bind&amp;call</a></li><li><a href="/js/es5-dom.html" class="sidebar-link">DOM与BOM</a></li><li><a href="/js/es5-event.html" class="sidebar-link">JS事件</a></li><li><a href="/js/es5-execution-context.html" class="sidebar-link">执行上下文与执行上下文栈</a></li><li><a href="/js/es5-extends.html" class="sidebar-link">继承</a></li><li><a href="/js/es5-fn.html" class="sidebar-link">函数</a></li><li><a href="/js/es5-news.html" class="sidebar-link">new 理解</a></li><li><a href="/js/es5-array.html" class="sidebar-link">数组</a></li><li><a href="/js/es5-object.html" class="sidebar-link">对象</a></li><li><a href="/js/es5-reg.html" class="sidebar-link">正则表达式学习</a></li><li><a href="/js/es5-scope.html" class="sidebar-link">作用域</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>javascript进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/js-clone.html" class="sidebar-link">JS的浅拷贝与深拷贝</a></li><li><a href="/js/js-curry.html" class="sidebar-link">函数柯理化</a></li><li><a href="/js/js-debounce.html" class="sidebar-link">节流与防抖动</a></li><li><a href="/js/js-precision.html" class="sidebar-link">js 精度丢失问题</a></li><li><a href="/js/js-memory.html" class="sidebar-link">js 内存管理</a></li><li><a href="/js/js-memory-1.html" class="sidebar-link">JS 内存泄漏、监控和分析</a></li><li><a href="/js/js-async.html" class="sidebar-link">事件循环和异步编程的崛起</a></li><li><a href="/js/js-bit.html" class="sidebar-link">js 位运算</a></li><li><a href="/js/js-eventloop.html" class="sidebar-link">理解 EventLoop</a></li><li><a href="/js/js-module.html" class="sidebar-link">js 模块化</a></li><li><a href="/js/js-run.html" class="sidebar-link">javascript 执行过程</a></li><li><a href="/js/js-ast.html" class="sidebar-link">解析、抽象语法树（AST）+ 提升编译速度 5 个技巧</a></li><li><a href="/js/js-v8.html" class="sidebar-link">V8 简介</a></li><li><a href="/js/js-principle.html" class="sidebar-link">JS 编译器，解释引擎</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>es6</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/es6-array.html" class="sidebar-link">数组扩展</a></li><li><a href="/js/es6-fn.html" class="sidebar-link">函数扩展</a></li><li><a href="/js/es6-class-1.html" class="sidebar-link">Class 基本用法</a></li><li><a href="/js/es6-class-2.html" class="sidebar-link">Class 继承</a></li><li><a href="/js/es6-async.html" class="sidebar-link">async 函数</a></li><li><a href="/js/es6-generator-1.html" class="sidebar-link">Generator 函数的语法</a></li><li><a href="/js/es6-generator-2.html" class="sidebar-link">Generator 函数的异步应用</a></li><li><a href="/js/es6-iterator.html" class="sidebar-link">Iterator 和 for...of 循环</a></li><li><a href="/js/es6-let-const.html" class="sidebar-link">let 与 const</a></li><li><a href="/js/es6-module.html" class="sidebar-link">Module 对象</a></li><li><a href="/js/es6-number.html" class="sidebar-link">数值扩展</a></li><li><a href="/js/es6-object.html" class="sidebar-link">对象扩展</a></li><li><a href="/js/es6-promise.html" class="sidebar-link">Promise 对象</a></li><li><a href="/js/es6-proxy-reflect.html" class="sidebar-link">Proxy 和 Reflect</a></li><li><a href="/js/es6-set-map.html" class="sidebar-link">Set和Map数据结构</a></li><li><a href="/js/es6-string.html" class="sidebar-link">字符串扩展</a></li><li><a href="/js/es6-symbol.html" class="sidebar-link">Symbol</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/ts-introduct.html" class="sidebar-link">ts 学习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>nodejs</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/node-introdect.html" class="sidebar-link">node 介绍</a></li><li><a href="/js/node-eventloop.html" class="sidebar-link">Node 的事件循环机制</a></li><li><a href="/js/node-buffer.html" class="sidebar-link">buffer 模块</a></li><li><a href="/js/node-cluster.html" class="sidebar-link">cluster 集群</a></li><li><a href="/js/node-egg.html" class="sidebar-link">egg 基础应用</a></li><li><a href="/js/node-events.html" class="sidebar-link">events 模块</a></li><li><a href="/js/node-express.html" class="sidebar-link">express 基础应用</a></li><li><a href="/js/node-fs.html" class="sidebar-link">fs 模块</a></li><li><a href="/js/node-http.html" class="sidebar-link">http 模块</a></li><li><a href="/js/node-rpc.html" class="sidebar-link">RPC 调用</a></li><li><a href="/js/node-koa.html" class="sidebar-link">koa 基础应用</a></li><li><a href="/js/node-koa-code.html" class="sidebar-link">koa 源码分析</a></li><li><a href="/js/node-net.html" class="sidebar-link">net 模块</a></li><li><a href="/js/node-process.html" class="sidebar-link">process 进程</a></li><li><a href="/js/node-querystring.html" class="sidebar-link">querystring 模块</a></li><li><a href="/js/node-stream.html" class="sidebar-link">stream 模块</a></li><li><a href="/js/node-queue.html" class="sidebar-link">node.js 中的消息队列</a></li><li><a href="/js/node-url.html" class="sidebar-link">url 模块</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>vue框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/mvvm.html" class="sidebar-link">mvvm 框架介绍</a></li><li><a href="/js/jquery-code.html" class="sidebar-link">jquery 源码分析</a></li><li><a href="/js/undescore.html" class="sidebar-link">undescore 源码分析</a></li><li><a href="/js/vue-jsx.html" class="sidebar-link">Vue 中使用 JSX</a></li><li><a href="/js/vue-lifecycle.html" class="sidebar-link">Vue 生命周期</a></li><li><a href="/js/vue-keep.html" class="sidebar-link">keep-alive 学习</a></li><li><a href="/js/vue-dom.html" class="sidebar-link">虚拟 DOM 解析</a></li><li><a href="/js/vue-communication.html" class="sidebar-link">vue 组件通信</a></li><li><a href="/js/vue-bind.html" class="sidebar-link">vue 双向数据绑定原理</a></li><li><a href="/js/vue-nexttick.html" class="sidebar-link">Vue.netTick 理解与分析</a></li><li><a href="/js/vue-watch.html" class="sidebar-link">Vue 中的 computed,watch,methods 理解与分析</a></li><li><a href="/js/vue-router.html" class="sidebar-link">vue-router 学习及原理</a></li><li><a href="/js/vue-router-code.html" class="sidebar-link">vue-router 源码分析</a></li><li><a href="/js/vue-vuex.html" class="sidebar-link">vuex 学习及原理</a></li><li><a href="/js/vue-vuex-code.html" class="sidebar-link">vue-vuex 源码分析</a></li><li><a href="/js/vue-code.html" class="active sidebar-link">vue 源码分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/vue-code.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/js/vue-code.html#内容" class="sidebar-link">内容</a></li><li class="sidebar-sub-header"><a href="/js/vue-code.html#联系作者" class="sidebar-link">联系作者</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-源码分析"><a href="#vue-源码分析" aria-hidden="true" class="header-anchor">#</a> vue 源码分析</h1> <h2 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h2> <p>本人平时学习及收集内容，欢迎参入一起讨论。</p> <h2 id="内容"><a href="#内容" aria-hidden="true" class="header-anchor">#</a> 内容</h2> <ul><li><a href="#%E4%B8%80%E3%80%81%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1">源码目录设计</a></li> <li><a href="#%E4%BA%8C%E3%80%81%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%AF%87">变化侦测篇</a></li> <li><a href="#%E4%B8%89%E3%80%81%E8%99%9A%E6%8B%9F-dom-%E7%AF%87">虚拟 DOM 篇</a></li> <li><a href="#%E5%9B%9B%E3%80%81%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E7%AF%87">模板编译篇</a></li> <li><a href="#%E4%BA%94%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AF%87">生命周期篇</a></li> <li><a href="#%E5%85%AD%E3%80%81%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">实例方法</a></li> <li><a href="#%E4%B8%83%E3%80%81%E5%85%A8%E5%B1%80-api-%E7%AF%87">全局 API 篇</a></li> <li><a href="#%E5%85%AB%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AF%87">过滤器篇</a></li> <li><a href="#%E4%B9%9D%E3%80%81%E6%8C%87%E4%BB%A4%E7%AF%87">指令篇</a></li></ul> <h3 id="一、源码目录设计"><a href="#一、源码目录设计" aria-hidden="true" class="header-anchor">#</a> 一、源码目录设计</h3> <p>Vue.js 的源码都在 src 目录下，其目录结构如下。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>├─dist                   # 项目构建后的文件
├─scripts                # 与项目构建相关的脚本和配置文件
├─flow                   # flow的类型声明文件
├─src                    # 项目源代码
│    ├─complier          # 与模板编译相关的代码
│    ├─core              # 通用的、与运行平台无关的运行时代码
│    │  ├─observe        # 实现变化侦测的代码
│    │  ├─vdom           # 实现virtual dom的代码
│    │  ├─instance       # Vue.js实例的构造函数和原型方法
│    │  ├─global-api     # 全局api的代码
│    │  └─components     # 内置组件的代码
│    ├─server            # 与服务端渲染相关的代码
│    ├─platforms         # 特定运行平台的代码，如weex
│    ├─sfc               # 单文件组件的解析代码
│    └─shared            # 项目公用的工具代码
└─test                   # 项目测试代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>compiler</li> <li>core</li> <li>platform</li> <li>server</li> <li>sfc</li> <li>shared</li></ul> <h4 id="_1-1-compiler"><a href="#_1-1-compiler" aria-hidden="true" class="header-anchor">#</a> 1.1 compiler</h4> <p><code>compiler</code>目录包含<code>Vue.js</code>所有编译相关的代码。它包括把模板解析成 ast 语法树、ast 语法树优化，代码生成等功能。</p> <p>编译的工作可以在构建时做（借助<code>webpack</code>、<code>vue-loader</code>等辅助插件）；也可以在运行时做，使用包含构建功能的<code>vue.js</code>。显然，编译是一项耗性能的工作，所以更推荐前者——离线编译。</p> <h4 id="_1-2-core"><a href="#_1-2-core" aria-hidden="true" class="header-anchor">#</a> 1.2 core</h4> <p><code>core</code>目录包含了<code>Vue.js</code>的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。</p> <p>这里的代码可谓是 Vue.js 的灵魂，也是我们之后需要重点分析的地方</p> <h4 id="_1-3-platform"><a href="#_1-3-platform" aria-hidden="true" class="header-anchor">#</a> 1.3 platform</h4> <p><code>Vue.js</code>是一个跨平台的<code>MVVM</code>框架，它可以跑在<code>web</code>上，也可以配合<code>weex</code>跑在<code>native</code>客户端上。<code>platform</code>是 <code>Vue.js</code>的入口，2 个目录代表 2 个主要入口，分别打包成运行在<code>web</code>上和<code>weex</code>上的<code>Vue.js</code>。</p> <p>我们会重点分析<code>web</code>入口打包后的<code>Vue.js</code>，对于<code>weex</code>入口打包的<code>Vue.js</code>，感兴趣的同学可以自行研究。</p> <h4 id="_1-4-server"><a href="#_1-4-server" aria-hidden="true" class="header-anchor">#</a> 1.4 server</h4> <p><code>Vue.js 2.0</code>支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。注意：这部分代码是跑在服务端的<code>Node.js</code>，不要和跑在浏览器端的<code>Vue.js</code>混为一谈。</p> <p>服务端渲染主要的工作是把组件渲染为服务器端的<code>HTML</code>字符串，将它们直接发送到浏览器，最后将静态标记&quot;混合&quot;为客户端上完全交互的应用程序。</p> <h4 id="_1-5-sfc"><a href="#_1-5-sfc" aria-hidden="true" class="header-anchor">#</a> 1.5 sfc</h4> <p>通常我们开发<code>Vue.js</code>都会借助<code>webpack</code>构建， 然后通过<code>.vue</code>单文件来编写组件。</p> <p>这个目录下的代码逻辑会把<code>.vue</code>文件内容解析成一个<code>JavaScript</code>的对象。</p> <h4 id="_1-6-shared"><a href="#_1-6-shared" aria-hidden="true" class="header-anchor">#</a> 1.6 shared</h4> <p><code>Vue.js</code>会定义一些工具方法，这里定义的工具方法都是会被浏览器端的<code>Vue.js</code>和服务端的<code>Vue.js</code>所共享的。</p> <h3 id="二、变化侦测篇"><a href="#二、变化侦测篇" aria-hidden="true" class="header-anchor">#</a> 二、变化侦测篇</h3> <ul><li>Object 的变化侦测</li> <li>Array 的变化侦测</li> <li>变化侦测的 API 实现</li></ul> <h4 id="_2-1-object-的变化侦测"><a href="#_2-1-object-的变化侦测" aria-hidden="true" class="header-anchor">#</a> 2.1 Object 的变化侦测</h4> <p><strong>使用 Object 数据变得“可观测”</strong></p> <p>数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的“可观测”。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 源码位置：src/core/observer/index.js

/**
 *  Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象
 */
export class Observer {
  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    // 给value新增一个__ob__属性，值为该value的Observer实例
    //
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i &lt; keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }
}


/**
 * 使一个对象转化成可观测对象
 * @param { Object } obj 对象
 * @param { String } key 对象的key
 * @param { Any } val 对象的某个key的值
 */
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property &amp;&amp; property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property &amp;&amp; property.get
  const setter = property &amp;&amp; property.set
  if ((!getter || setter) &amp;&amp; arguments.length === 2) {
    val = obj[key]
  }

    // 递归调用，判断属性值是否是对象
  let childOb = !shallow &amp;&amp; observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter &amp;&amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow &amp;&amp; observe(newVal)
      dep.notify()
    }
  })
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br></div></div><p><strong>什么是依赖收集</strong></p> <p>视图里谁用到了这个数据就更新谁，我们换个优雅说法：我们把“谁用到了这个数据”称为“谁依赖了这个数据”，我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数据中，把每个依赖都通知一遍，告诉他们：“你们依赖的数据变啦，你们该更新啦！”。这个过程就是依赖收集。</p> <p><strong>何时收集依赖？何时通知依赖更新？</strong></p> <p>在 getter 中收集依赖，在 setter 中通知依赖更新。</p> <p><strong>把依赖收集到哪里</strong></p> <p>我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array&lt;Watcher&gt;;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

    // 订阅
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }
    // 通知更新
  notify () {
    // 转化成数组
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) {
      subs.sort((a, b) =&gt; a.id - b.id)
    }
    for (let i = 0, l = subs.length; i &lt; l; i++) {
      subs[i].update()
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>有了依赖管理器后，我们就可以在 getter 中收集依赖，在 setter 中通知依赖更新了，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function defineReactive (obj,key,val){
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property &amp;&amp; property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property &amp;&amp; property.get
  const setter = property &amp;&amp; property.set
  if ((!getter || setter) &amp;&amp; arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow &amp;&amp; observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter &amp;&amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow &amp;&amp; observe(newVal)
      dep.notify()
    }
  })
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><p>在上述代码中，我们在<code>getter</code>中调用了<code>dep.depend()</code>方法收集依赖，在<code>setter</code>中调用<code>dep.notify()</code>方法通知所有依赖更新。</p> <p><strong>依赖到底是谁</strong></p> <p>上面我们明白了什么是依赖？何时收集依赖？以及收集的依赖存放到何处？那么我们收集的依赖到底是谁？</p> <p>其实在<code>Vue</code>中还实现了一个叫做<code>Watcher</code>的类，而<code>Watcher</code>类的实例就是我们上面所说的那个“谁”。换句话说就是：谁用了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例。在之后数据变化时，我们不直接去通知依赖更新，而通知依赖对应的<code>Watch</code>实例，由<code>Watcher</code>实例去通知真正的视图。</p> <p><code>Watcher</code>类的具体实现如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default class Watcher {
  constructor (vm,expOrFn,cb) {
    this.vm = vm;
    this.cb = cb;
    this.getter = parsePath(expOrFn)
    this.value = this.get()
  }
  get () {
    window.target = this;
    const vm = this.vm
    let value = this.getter.call(vm, vm)
    window.target = undefined;
    return value
  }
  update () {
    const oldValue = this.value
    this.value = this.get()
    this.cb.call(this.vm, this.value, oldValue)
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><code>Watcher</code>类的代码实现逻辑：</p> <ol><li>当实例化<code>Watcher</code>类时，会先执行其构造函数；</li> <li>在构造函数中调用了<code>this.get()</code>实例方法；</li> <li>在<code>get()</code>方法中，首先通过<code>window.target = this</code>把实例自身赋给了全局的一个唯一对象<code>window.target</code>上，然后通过<code>let value = this.getter.call(vm,vm)</code>获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>，上文我们说过，在<code>getter</code>里会调用<code>dep.depend()</code>收集依赖，而在<code>dep.depend()</code>中取到挂载<code>window.target</code>上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</li> <li>而当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用了<code>dep.notify()</code>方法，在<code>dep.notify()</code>方法中，遍历所有依赖(即 watcher 实例)，执行依赖的<code>update()</code>方法，也就是<code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code>方法中调用数据变化的更新回调函数，从而更新视图</li></ol> <p>总结一下：<code>Watcher</code>先把自己设置到全局唯一的指定位置(<code>window.target</code>)，然后读取数据。因为读取了数据，所以会触发这个数据的<code>getter</code>。接着，在<code>getter</code>中就会从全局唯一的那个位置读取当前正在读取数据的<code>Watcher</code>，并把这个<code>wather</code>收集到<code>Dep</code>中去。收集好之后，当数据发生变化时，会向<code>Dep</code>中的每个<code>Wather</code>发送通知。通过这样的方式。<code>Wather</code>可以主动去订阅任意一个数据的变化。</p> <p><strong>不足之处</strong></p> <p>虽然我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，但是这个方法仅仅只能观测到<code>object</code>数据的取值及设置值，当我们向<code>object</code>数据里添加一对新的<code>key/value</code>或删除一对已有的<code>key/value</code>时，它是无法观测到的，导致当我们对<code>object</code>数据添加或删除时，无法通知依赖，无法驱动视力进行响应式更新。</p> <p><code>Vue</code>也注意到了这一点，为了解决这一问题，<code>Vue</code>增加了两个全局 API：<code>Vue.set</code>和<code>Vue.delete</code>。</p> <p><strong>总结</strong></p> <p>我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，并且封装了<code>Observer</code>类，让我们能够方便的把<code>object</code>数据中的所有属性（包括子属性）都转换成<code>getter/setter</code>的形式来侦测变化。</p> <p>其整个流程大致如下：</p> <ol><li><code>Data</code>通过<code>observer</code>转换成了<code>getter/setter</code>的形式来追踪变化。</li> <li>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将<code>Watcher</code>添加到依赖中。</li> <li>当数据发生了变化时，会触发<code>setter</code>，从而向<code>Dep</code>'中的依赖（vcb 即 Watcher）发送通知。</li> <li><code>Watcher</code>接收到通知后，会向外界发送能知，变化通知到外界后可能会触发视图更新，也有可能触发某个回调数等。</li></ol> <h4 id="_2-2-array-的变化侦测"><a href="#_2-2-array-的变化侦测" aria-hidden="true" class="header-anchor">#</a> 2.2 Array 的变化侦测</h4> <p>上一节文章中我们介绍了<code>Object</code>数据的变化侦测方式，本节我们来看一下对<code>Array</code>型数据的变化<code>Vue</code>是如何进行侦测的。</p> <p>我们知道，<code>Object.defineProperty</code>监测<code>Object</code>型数据时是给<code>Object</code>型数据的每个<code>key/value</code>添加上了<code>getter</code>和<code>setter</code>，这样，对于<code>Object</code>型数据我们再通过<code>key</code>值取值或设置值时就可以被监测到。</p> <p>数组并不是只能由索引值来操作数组，更常用的操作数组的方法是使用数组原型上的一些方法如<code>push</code>，<code>shift</code>等来操作数组，当使用这些数据原型方法来数组时，<code>Object.defineProperty</code>就监测不到了，所以<code>Vue</code>对<code>Array</code>型数据单独设计了数据监测方式。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    ob.dep.notify()
    return result
  })
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p><strong>数组方法拦截器</strong></p> <p>在<code>Vue</code>中创建了一个数组方法拦截器，它拦截在数组实例与<code>Array.prototype</code>之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用<code>Array.prototype</code>上的原生方法。如下图所示：</p> <p><img src="vue12.png" alt="images"></p> <p>经过整理，<code>Array</code>原型中可以改变数组自身内容的方法有 7 个，分别是：<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>。源码中的拦截器代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 源码位置：/src/core/observer/array.js

const arrayProto = Array.prototype
// 创建一个对象作为拦截器
export const arrayMethods = Object.create(arrayProto)

// 改变数组自身内容的7个方法
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  const original = arrayProto[method]      // 缓存原生方法
  Object.defineProperty(arrayMethods, method, {
    enumerable: false,
    configurable: true,
    writable: true,
    value:function mutator(...args){
      const result = original.apply(this, args)
      return result
    }
  })
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>首先创建了继承自<code>Array</code>原型的空对象<code>arrayMethods</code>，接着在<code>arrayMethods</code>上使用<code>object.defineProperty</code>方法将那些可以改变数组自身的 7 个方法遍历逐个进行封装。最后，当我们使用<code>push</code>方法的时候，其实用的是<code>arrayMethods.push</code>，而<code>arrayMethods.push</code>就是封装的新函数<code>mutator</code>，也就是说，实际上执行的是函数<code>mutator</code>，而<code>mutator</code>函数的内部执行了<code>original</code>函数，这个<code>original</code>函数就是<code>Array.prototype</code>上对应的原生方法。那么，接下我们就可以在<code>mutator</code>函数中做一些其他的事，比如说发送变化通知。</p> <p><strong>使用拦截器</strong></p> <p>我们把撞拦截器做好还不够，还要把它挂载到数组实例与<code>Array.prototype</code>之间，这样拦截器才能够生效。</p> <p>其实挂载不难，我们只需数据的<code>__proto__</code> 属性设置为拦截器<code>arrayMethods</code>即可，源码实现如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 源码位置：/src/core/observer/index.js
export class Observer {
  constructor (value) {
    this.value = value
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }
}
// 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性
export const hasProto = '__proto__' in {}

const arrayKeys = Object.getOwnPropertyNames(arrayMethods)

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src: Object, keys: any) {
  target.__proto__ = src
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) {
  for (let i = 0, l = keys.length; i &lt; l; i++) {
    const key = keys[i]
    def(target, key, src[key])
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><p>上面代码中首先判断了浏览器是否支持<code>__proto__</code>，如果支持，则调用<code>protoAugment</code>函数把<code>value__proto__ = arrayMethods</code>；如果不支持，则调用<code>copyAugment</code>函数把拦截器中重写的 7 个方法循环加入到<code>value</code>上。</p> <p>拦截器生效以后，当数组数据再发生变化时，我们就可以在拦截器中通知变化了，也就是说现在我们就可以知道数组数据何时发生变化了。</p> <p><strong>数组新增元素的侦测</strong></p> <p>如果向数组里新增一个元素的话，我们可以也需要将新增的这个元素转化成可侦测的响应式数据。</p> <p>这个实现起来也很容易，我们只需要拿到新增的这个元素，然后调用<code>observe</code>函数将其转化即可。我们知道，可以向数组内新增元素的方法有 3 个，分别是：<code>push</code>、<code>unshift</code>、<code>splice</code>。我们需对这 3 中方法分别处理，拿到新增的元素，再将其转化即可。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args   // 如果是push或unshift方法，那么传入参数就是新增的元素
        break
      case 'splice':
        inserted = args.slice(2) // 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素
        break
    }
    if (inserted) ob.observeArray(inserted) // 调用observe函数将新增的元素转化成响应式
    // notify change
    ob.dep.notify()
    return result
  })
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>在上面拦截器定义代码中，如果是<code>push</code>或<code>unshift</code>方法，那么传入参数就是新增的元素；如果<code>splice</code>方法，那么传入参数列表中下标为 2 的就是新增的元素，拿到新增的元素后，就可以<code>observe</code>函数将新增的元素转化成响应的了。</p> <p><strong>深度侦测</strong></p> <p>在<code>Vue</code>中，不论是<code>Object</code>型数组据还是<code>Array</code>型数据所实现的数据变化侦测都是深度侦测，所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。举个例子：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let arr = [{
    name:'NLRX',
    age:'18'
}]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>数组中包含了一个对象，如果该对象的某个属性发生了变化也应该被侦测到，这就是深度侦测。</p> <p>对于<code>Array</code>型数据，调用了<code>observeArray()</code>方法，该方法内部会遍历数组中的每一个元素，然后通过调用<code>observe</code>函数将每一个元素都转化成可侦测的响应式数据。</p> <p><strong>不足之处</strong></p> <p>对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let arr = [1,2,3]
arr[0] = 5;       // 通过数组下标修改数组中的数据
arr.length = 0    // 通过修改数组长度清空数组
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>而使用上述鸽子中的操作方式来修改数组是无法侦测到的。同样，<code>Vue</code>也注意到了这个问题，为了解决这一问题，<code>Vue</code>增加了两个全局 API：<code>Vue.set</code>和<code>Vue.delete</code>。</p> <h4 id="_2-3-变化侦测的-api-实现"><a href="#_2-3-变化侦测的-api-实现" aria-hidden="true" class="header-anchor">#</a> 2.3 变化侦测的 API 实现</h4> <ul><li><code>vm.$watch</code></li> <li><code>vm.$set</code></li> <li><code>vm.$delete</code></li></ul> <p><strong><code>vm.$watch</code></strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$watch(expOrFn, callback, [options]);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>参数：
<ul><li><code>{string | Function} expOrFn</code></li> <li><code>{Function | Object} callback</code></li> <li><code>{Object} [options]</code> <ul><li><code>{boolean} deep</code></li> <li><code>{boolean} immediate</code></li></ul></li></ul></li> <li>返回值：<code>{Function} unwatch</code></li> <li>用法：</li></ul> <p>观察<code>Vue</code>实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。</p> <p>注意：在变异（不是替换）对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。<code>Vue</code>不会保留变异之前值的副本。</p> <ul><li>示例：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>//  键路径
vm.$watch(&quot;a.b.c&quot;,function(newVal,oldVal){
    // 做点什么
})

// 函数
vm.$watch(
  function() {
    // 表达式 `this.a + this.b` 每次得出一个不同的结果时
    // 处理函数都会被调用。
    // 这就像监听一个未被定义的计算属性
    return this.a + this.b;
  },
  function(newVal, oldVal) {
    // 做点什么
  }
);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><code>vm.$watch</code>返回一个取消观察函数，用来停止触发回调</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var unwatch = vm.$watch(&quot;a&quot;, cb);
// 之后取消观察
unwatch();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>选项：deep</li></ul> <p>为了发现对象内部值的变化，可以在选项参数中指定<code>deep:true</code>。注意监听数组的变动不需要这么做。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$watch(&quot;someObject&quot;, callback, {
  deep: true
});
vm.someObject.nestedValue = 123;
// callback is fired
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>选项：immediate</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$watch(&quot;a&quot;, callback, {
  immediate: true
});
// 立即以 `a` 的当前值触发回调
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>内部原理</li></ul> <p><code>$watch</code>的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$watch = function (expOrFn,cb,options) {
    const vm: Component = this
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {}
    options.user = true
    const watcher = new Watcher(vm, expOrFn, cb, options)
    if (options.immediate) {
      try {
        cb.call(vm, watcher.value)
      } catch (error) {
        handleError(error, vm, `callback for immediate watcher &quot;${watcher.expression}&quot;`)
      }
    }
    return function unwatchFn () {
      watcher.teardown()
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>在函数内部，首先判断传入的回调函数是否为一个对象，如果传入的回调函数是个对象，那就表明用户是把第二个参数回调函数<code>cb</code>和第三个参数选项<code>options</code>合起来传入的，此时调用<code>createWatcher</code>函数，该函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function createWatcher (vm,expOrFn,handler,options) {
  if (isPlainObject(handler)) {
    options = handler
    handler = handler.handler
  }
  if (typeof handler === 'string') {
    handler = vm[handler]
  }
  return vm.$watch(expOrFn, handler, options)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>该函数内部其实就是从用户合起来传入的对象中把回调函数<code>cb</code>和参数<code>options</code>剥离出来，然后再以常规的方式调用<code>$watch</code>方法并将剥离出来的参数传进去。</p> <p>接着获取到用户传入的<code>options</code>，如果用户没有传入则将其赋值为一个默认空对象，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>options = options || {};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>$watch</code>方法内部会创建一个<code>watcher</code>实例，由于该实例是用户手动调用<code>$watch</code>方法创建而来的，所以给<code>options</code>添加<code>user</code>属性并赋值为<code>true</code>，用于区分用户创建的<code>watcher</code>实例和<code>Vue</code>内部创建的<code>watcher</code>实例，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>options.user = true;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着，传入参数创建一个 watcher 实例，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const watcher = new Watcher(vm, expOrFn, cb, options);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着判断如果用户在选项参数<code>options</code> 中指定的<code>immediate</code> 为<code>true</code>，则立即用被观察数据当前的值触发回调，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (options.immediate) {
  cb.call(vm, watcher.value);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>最后返回一个取消观察函数<code>unwatchFn</code>，用来停止触发回调。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>return function unwatchFn() {
  watcher.teardown();
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个取消观察<code>unwatchFn</code>内部其实是调用了<code>watcher</code>实例的<code>teardown</code>方法，那和我们来看一下这个<code>teardown</code>方法是如何实现的。其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default class Watcher {
  constructor(/* ... */) {
    // ...
    this.deps = [];
  }
  teardown() {
    let i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>创建<code>watcher</code>实例的时候会读取被观察的数据，读取了数据就表示依赖了数据，所以<code>watcher</code>实例就会存在于数据的依赖列表中，同时<code>watcher</code>实例也记录了自己依赖了哪些数据，另外我们还说过，每个数据都有一个自己的依赖管理器<code>dep</code>，<code>watcher</code>实例记录自己依赖了哪些数据其实就是把数据的依赖管理器<code>dep</code>存放在<code>watcher</code>实例的<code>this.deps=[]</code>属性中，当取消观察时即<code>watcher</code>实例不想依赖这些数据了，那么就遍历自己记录的这些数据的依赖管理器，告诉这些数据可以从你们依赖列表中把我删除了。</p> <p>当选项参数<code>options</code>中的<code>deep</code>属性为<code>true</code>时，如何实现深度观察呢？</p> <p>要实现这个功能也不难，我们知道，要想让数据变化时通知我们，那我们只需成为这个数据的依赖即可，因为数据变化时会通知它所有的依赖，那么如何成为数据的依赖呢，很简单，读取一下数据即可。也就是说我们只需在创建<code>watcher</code>实例的时候把<code>obj</code>对象内部所有的值都递归的读一遍，那么这个<code>watcher</code>实例就会被加入到对象内所有值的依赖列表中，之后当对象内任意某个值发生变化时就能够得到通知了。</p> <p><code>traverse</code>函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const seenObjects = new Set();

export function traverse(val: any) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse(val: any, seen: SimpleSet) {
  let i, keys;
  const isA = Array.isArray(val);
  if (
    (!isA &amp;&amp; !isObject(val)) ||
    Object.isFrozen(val) ||
    val instanceof VNode
  ) {
    return;
  }
  if (val.__ob__) {
    const depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) _traverse(val[i], seen);
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) _traverse(val[keys[i]], seen);
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>该函数其实就是个递归遍历的过程，把被观察数据的内部值都递归遍历读取一遍。</p> <p>首先判断传入的<code>val</code>类型，如果它不是<code>Array</code>或<code>Object</code>，再或者已经被冻结，那么直接返回，退出程序。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const isA = Array.isArray(val);
if ((!isA &amp;&amp; !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
  return;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>然后拿到<code>val</code>的<code>dep.id</code>，存入创建好的集合<code>seen</code>中，因为集合相比数据而言它有天然的去重效果，以此来保证存入的<code>dep.id</code>没有重复，不会造成重复收集依赖，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (val.__ob__) {
  const depId = val.__ob__.dep.id;
  if (seen.has(depId)) {
    return;
  }
  seen.add(depId);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>接下来判断如果是数组，则循环数组，将数组中每一项递归调用<code>_traverse</code>；如果是对象，则取出对象所有的<code>key</code>，然后执行读取操作，再递归内部值，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (isA) {
  i = val.length;
  while (i--) _traverse(val[i], seen);
} else {
  keys = Object.keys(val);
  i = keys.length;
  while (i--) _traverse(val[keys[i]], seen);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这样，把被观察数据内部所有的值都递归的读取一遍后，那么这个<code>watcher</code>实例就会被加入到对象内所有值的依赖列表中，之后当对象内任意某个值发生变化时就能够得到通知了。</p> <p><strong><code>vm.$set</code></strong></p> <p><code>vm.$set</code>是全局<code>Vue.set</code>的<strong>别名</strong>，其用法相同。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$set(target, propertyName / index, value);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p>参数：</p> <ul><li><code>{Object | Array} target</code></li></ul></li> <li><p>返回值：设置的值</p></li> <li><p>用法：向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为<code>Vue</code>无法探测普通的新增属性。</p></li> <li><p>内部原理</p></li></ul> <p>对于<code>object</code>型数据，当我们向<code>object</code>数据里添加一对新的<code>key/value</code>或删除一对已有的<code>key/value</code>时，<code>vue</code>是无法观测到的；而对于<code>Array</code>弄数据，当我们通过数组下标个性数组中的数据时，<code>Vue</code>也是无法观测到的</p> <p>正是因为存在这个问题，所以<code>Vue</code>设计了<code>set</code>和<code>delete</code>这两个方法来解决这一问题；</p> <p><code>set</code>方法的定义位于源码的<code>src/core/observer/index.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  if (key in target &amp;&amp; !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob &amp;&amp; ob.vmCount)) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }
  if (!ob) {
    target[key] = val
    return val
  }
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>首先判断在非生产环境下如果传入的<code>target</code>是否为<code>undefined</code>、<code>null</code>或是原始类型，如果是原始类型，如果是，则抛出警告，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (process.env.NODE_ENV !== 'production' &amp;&amp;
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接着判断如果传入的<code>target</code>是数组并且传入的<code>key</code>是有效索引的话，那么就取当前数组长度与<code>key</code>这两者的最大值作为数组的新长度，然后使用数组的<code>splice</code>方法将传入的索引<code>key</code>对应的<code>val</code>值添加进数组。这里注意一点，为什么要用<code>splice</code>方法呢？数组的<code>splice</code>方法已经被我们创建的拦截器重写了，也就是说，当使用<code>splice</code>方法向数组内添加元素时，该元素会自动被变成响应式的。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果传入的<code>target</code>不是数组，那就当做对象来处理。</p> <p>首先判断传入的<code>key</code>是否已经存在于<code>target</code>中，如果存在，表明这次操作不是新增属性，而对已有的属性进行简单的修改值，那么就只修改属性值即可，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (key in target &amp;&amp; !(key in Object.prototype)) {
  target[key] = val;
  return val;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接下来获取到<code>target</code>的<code>__ob__</code>属性，我们说过，该属性是否为<code>true</code>标志着<code>target</code>是否为响应式对象，接着判断如果<code>target</code>是<code>Vue</code>实例，或者是<code>Vue</code>实例的根数据对象，则抛出警告并退出程序，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const ob = (target: any).__ob__;
if (target._isVue || (ob &amp;&amp; ob.vmCount)) {
  process.env.NODE_ENV !== &quot;production&quot; &amp;&amp;
    warn(
      &quot;Avoid adding reactive properties to a Vue instance or its root $data &quot; +
        &quot;at runtime - declare it upfront in the data option.&quot;
    );
  return val;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>接着判断如果<code>ob</code>属性为<code>false</code>，那么表明<code>target</code>不是一个响应式对象，那么我们只需简单给它添加上新的属性，不用将新属性转化成响应式，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!ob) {
  target[key] = val;
  return val;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>最后，如果<code>target</code>是对象，并且是响应式，那么就调用<code>defineReactive</code>方法将新属性添加到<code>target</code>上，<code>defineReactive</code>方法会将新属性添加完之后并将其转化成响应式，最后通知依赖更新，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>defineReactive(ob.value, key, val);
ob.dep.notify();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>以上，就是<code>set</code>方法的内部原理。其逻辑流程图如下：</p> <p><img src="vue14.jpg" alt="images"></p> <p><strong><code>vm.$delete</code></strong></p> <p><code>vm.$delete</code>是全局<code>Vue.delete</code>的<strong>别名</strong>，其用法相同</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$delete(target, propertyName / index);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数</strong>：</p> <ul><li><code>{Object | Array} target</code></li> <li><code>{string | number} propertyName/index</code></li></ul></li> <li><p><strong>用法</strong>：</p></li></ul> <p>删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开<code>Vue</code>不检测到属性被删除的限制，但是你应该很少会使用它。</p> <ul><li><strong>内部原理</strong>：</li></ul> <p><code>delete</code>方法是用来解决<code>Vue</code>不能检测到属性被删除的限制，该方法的定义位于源码的<code>src/core/observer/index.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function del (target: Array&lt;any&gt; | Object, key: any) {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot delete reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    target.splice(key, 1)
    return
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob &amp;&amp; ob.vmCount)) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    )
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key]
  if (!ob) {
    return
  }
  ob.dep.notify()
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>该方法的内部原理与<code>set</code>方法有几分相似。</p> <p>首先判断在非生产环境下如果传入的<code>target</code>不存在，或者<code>target</code>是原始值，则抛出警告，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> if (process.env.NODE_ENV !== 'production' &amp;&amp;
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot delete reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接着判断如果传入的<code>target</code>是数组并且传入的<code>key</code>是有效索引的话，就使用数组的<code>splice</code>方法将索引<code>key</code>对应的值删掉，数组的<code>splice</code>方法已经被我们创建的拦截器重写了，所以使用该方法会自动通知相关依赖。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    target.splice(key, 1)
    return
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果传入的<code>target</code>不是数组，那就当做对象来处理</p> <p>接下来获取到<code>target</code>的<code>__ob__</code>属性，该属性是否为<code>true</code>标志着<code>target</code>是否为响应式对象，接着判断如果<code>target</code>是<code>Vue</code>实例，或者是<code>Vue</code>实例的根数据对象，则抛出警告并退出程序，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const ob = (target: any).__ob__;
if (target._isVue || (ob &amp;&amp; ob.vmCount)) {
  process.env.NODE_ENV !== &quot;production&quot; &amp;&amp;
    warn(
      &quot;Avoid adding reactive properties to a Vue instance or its root $data &quot; +
        &quot;at runtime - declare it upfront in the data option.&quot;
    );
  return val;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>接着判断传入的<code>key</code>是否存在于<code>target</code>中，如果<code>key</code>本来就不存在于<code>target</code>中，那就不用删除，直接退出程序即可，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!hasOwn(target, key)) {
  return;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>最后，如果<code>target</code>是对象，并且传入的<code>key</code>也存在于<code>target</code>中，那么就从<code>target</code>中将该属性删除，同时判断当前的<code>target</code>是否为响应式对象，如果是响应式对象，则通知依赖更新；如果不是，删除完后直接返回不通知更新，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>delete target[key];
if (!ob) {
  return;
}
ob.dep.notify();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="三、虚拟-dom-篇"><a href="#三、虚拟-dom-篇" aria-hidden="true" class="header-anchor">#</a> 三、虚拟 DOM 篇</h3> <p>参考<a href="https://km.xiaowuzi.info/js/vue-dom.html" target="_blank" rel="noopener noreferrer">Vue 虚拟 DOM<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="四、模板编译篇"><a href="#四、模板编译篇" aria-hidden="true" class="header-anchor">#</a> 四、模板编译篇</h3> <ul><li><a href="#_4-1-%E6%A6%82%E8%BF%B0">概述</a></li> <li><a href="#_4-2-%E6%95%B4%E4%BD%93%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B">整体运行流程</a></li> <li><a href="#_4-3-html-%E8%A7%A3%E6%9E%90%E5%99%A8">HTML 解析器</a></li> <li><a href="#_4-4-%E6%96%87%E6%9C%AC%E8%A7%A3%E6%9E%90%E5%99%A8">文本解析器</a></li> <li><a href="#_4-5-%E4%BC%98%E5%8C%96%E9%98%B6%E6%AE%B5">优化阶段</a></li> <li><a href="#_4-5-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E9%98%B6%E6%AE%B5">代码生成阶段</a></li></ul> <p>我们知道，在日常开发中，我们把写在<code>&lt;template&gt;&lt;/template&gt;</code>标签中的类似于原生<code>HTML</code>的内容称之为模板。这时你可能会问了，为什么说是“类似于原生<code>HTML</code>的内容”而不是“就是<code>HTML</code>的内容”？因为我们在开发中，在<code>&lt;template&gt;&lt;/template&gt;</code>标签中除了写一些原生<code>HTML</code>的标签，我们还会写一些亦是插值，如或者写一些<code>Vue</code>指令，如<code>v-on</code>、<code>v-if</code>等。而这些东西都是在原生<code>HTML</code>语法中不存在的，不被接受的。但事实上我们确实这么写了，也被正确识别了，页面也正常显示了，这又是为什么呢？</p> <p>这就归功于<code>Vue</code>的模板编译了，<code>Vue</code>会把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理生成渲染函数，也就是<code>render</code>函数，而<code>redner</code>函数会将模板内容生成对应的<code>VNode</code>，而<code>VNode</code>再经过<code>patch</code>过程从而得到将要渲染的视图中的<code>VNode</code>，最后根据<code>VNode</code>创建真实的<code>DOM</code>节点并插入到视图中，最终完成视图的渲染更新。</p> <p>而把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理成渲染函数，也就是<code>render</code>函数的这一段过程称之为模板编译过程。</p> <h4 id="_4-1-概述"><a href="#_4-1-概述" aria-hidden="true" class="header-anchor">#</a> 4.1 概述</h4> <p><strong>整体渲染流程</strong></p> <p>所谓渲染流程，就是把用户写的类似原生<code>HTML</code>的模板经过一系列处理最终反应到视图中称之为整个渲染流程。这个流程在上文中其实已经说到了，下面我们以流程图的形式宏观的了解一下，流程图如下：</p> <p><img src="vue-code01.png" alt="images"></p> <p>从图中我们也可以看到，模板编译过程就是把用户写的模板经过一系列处理最终生成<code>render</code>函数的过程。</p> <p>将一堆字符串模板解析成抽象语法树<code>AST</code>后，我们就可以对其进行各种操作处理了，处理完后用处理后的<code>AST</code>来生成<code>render</code>函数。其具体流程可大致分为三个阶段：</p> <ol><li>模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树<code>AST</code>；</li> <li>优化阶段：遍历<code>AST</code>，找出其中的静态节点，并打上标记；</li> <li>代码生成阶段：将<code>AST</code>转换成渲染函数；</li></ol> <p>这三个阶段在源码中分别对应三个模块，下面给出三个模块的源代码在源码中的路径：</p> <ol><li>模板解析段——解析器——源码路径：<code>src/compiler/parser/index.js</code></li> <li>优化阶段——优化器——源码路径：<code>src/compiler/optimizer.js</code></li> <li>代码生成阶段——代码生成器——源码路径：<code>src/compiler/codegen/index.js</code></li></ol> <p>其对应的源码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 源码位置：/src/complier/index.js

export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>可以看到<code>baseCompile</code>的代码非常的简短主要核心代码。</p> <ul><li><strong>const ast = parse(template.trim(),options)</strong>：<code>parse</code>会用与此同时等方式解析<code>template</code>模板中的指令、<code>class</code>、<code>style</code>等数据，形成<code>AST</code>。</li> <li><strong>optimize(ast,options)</strong>：<code>optimize</code>的主要作用是标记静态节点，这是<code>Vue</code>在编译过程中的一处优化，档在进行<code>patch</code>的过程中，<code>DOM-Diff</code>算法会直接跳过静态节点，从而减少了比较的过程，优化了<code>patch</code>的性能。</li> <li><strong>const code = generate(ast,options)</strong>：将<code>AST</code>转化成<code>render</code>函数字符串的过程，得到结果是<code>render</code>函数的字符串以及<code>staticRenderFns</code>字符串。</li></ul> <p>最终<code>baseCompile</code>的返回值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    ast:ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>最终返回了抽象语法树(ast)，渲染函数(render)，静态渲染函数(staticRenderFns)，且<code>render</code>的值为<code>code.render</code>，<code>staticRendreFns</code>的值为<code>code.staticRenderFns</code>，也就是说通过<code>generate</code>处理<code>ast</code>之后得到的返回值<code>code</code>是一个对象。</p> <p>流程图如下：</p> <p><img src="vue13.png" alt="images"></p> <h4 id="_4-2-整体运行流程"><a href="#_4-2-整体运行流程" aria-hidden="true" class="header-anchor">#</a> 4.2 整体运行流程</h4> <p>在模板解析阶段主要做的工作是把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签内写的模板使用正则等方式解析成抽象语法树（<code>AST</code>）。而这一阶段在源码中对应解析器（<code>parser</code>）模块。</p> <p>解析器，顾名思义，就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成<code>AST</code>。我们知道在<code>&lt;template&gt;&lt;/template&gt;</code>模板内，除了有常规的<code>HTML</code>标签外，用户还会一些文本信息以及在文本信息中包含过滤器。而这些不同的内容在解析起来肯定需要不同的解析规则，所以解析器不可能只有一个，它应该除了有解析常规<code>HTML</code>的 HTML 解析器，还应该有解析文本的文本解析器以及解析文本如果包含过滤器的过滤器解析器。</p> <p>文本信息和标签属性信息却又是存在于 HTML 标签之内的，所以在解析整个模板的时候它的流程应该是这样子的</p> <p><strong>回到源码</strong></p> <p>解析器的源码位于<code>/src/complier/parser</code>文件夹下，其主线代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 代码位置：/src/complier/parser/index.js

export function parse(template, options) {
   // ...
  parseHTML(template, {
    warn,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    start (tag, attrs, unary) {

    },
    end () {

    },
    chars (text: string) {

    },
    comment (text: string) {

    }
  })
  return root
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p><code>parse</code>函数就是解析器的主函数，在<code>parse</code>函数内调用了<code>parseHTML</code>函数对象模板字符串进行解析，在<code>parseHTML</code>函数解析模板字符串的过程中，如果遇到广西信息，就会调用文本解析器<code>parseText</code>函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器<code>parseFilters</code>函数进行解析。</p> <p><strong>总结</strong></p> <p>模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为 HTML 解析器，文本解析器和过滤器解析器。而文本信息与过滤器信息又存在于 HTML 标签中，所以在解析器主线函数<code>parse</code>中先调用 HTML 解析器<code>parseHTML</code>函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析。</p> <h4 id="_4-3-html-解析器"><a href="#_4-3-html-解析器" aria-hidden="true" class="header-anchor">#</a> 4.3 HTML 解析器</h4> <p><strong>HTML 解析器内部运行流程</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//  代码位置：/src/complier/parser/index.js

/**
 *  Convert HTML string to AST.
 *  将HTML模板字符串转化为AST
 */
export function parse(template,options){
    // ...
    parseHTML(template,{
        warn,
        expectHTML: options.expectHTML,
        isUnaryTag: options.isUnaryTag,
        canBeLeftOpenTag: options.canBeLeftOpenTag,
        shouldDecodeNewlines: options.shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
        shouldKeepComment: options.comments,
        // 当解析到开始标签时，调用该函数
        start(tag,attrs,unary){

        },
        // 当解析到结束标签时，调用该函数
        end(){

        },
        // 当解析到文本时，调用该函数
        chars(text){

        },
        // 当解析到注释时，调用该函数
        comment(text){

        }
    })
    return root
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>从代码中我们可以看到，调用<code>parseHTML</code>函数时为其传入的两个参数分别是：</p> <ul><li>template 待转换的模板字符串；</li> <li>options 转换时所需的选项；</li></ul> <p>第一个参数是待转换的模板字符串，无需多言；重点看第二个参数，第二个参数提供了一些解析<code>HTML</code>模板时的一些参数，同时还定义了 4 个钩子函数。我们说了模板编译阶段主线函数<code>parse</code>会将<code>HTML</code>模板字符串转化成<code>AST</code>，而<code>parseHTML</code>是用来解析模板字符串的，把模板字符串中不同的内容解释出来之后，然后使用这个 4 个钩子函数提取出来的内容生成对应的<code>AST</code>。</p> <p>把这 4 个钩子函数作为参数会给解析器<code>parseHTML</code>，当解析器解析出不同的内容时调用不同的钩子函数从而生成不同的<code>AST</code>。</p> <ul><li>当解析到开始标签时调用<code>start</code>函数生成元素类型的<code>AST</code>节点，代码如下；</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 当解析到标签的开始位置时，触发start
start (tag, attrs, unary, start, end) {
    let element = crateASTElement(tag,atrrs,currentParent)
}

export function crateASTElement(tag,attrs,parent){
    return {
        type: 1,
        tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        rawAttrsMap: {},
        parent,
        children: []
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>从上面代码中我们可以看到，<code>start</code>函数接收五个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>、开始<code>start</code>、结束<code>end</code>。当调用该钩子函数时，内部会调用<code>createASTElement</code>函数来创建元素类型的<code>AST</code>节点</p> <ul><li>当解析到结束标签时调用<code>end</code>函数；</li> <li>当解析到文本调用<code>chars</code>函数生成文本类型的<code>AST</code>节点；</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 当解析到标签的文本时，触发chars
chars (text, start, end) {
      if (!currentParent) {
        if (process.env.NODE_ENV !== 'production') {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.',
              { start }
            )
          } else if ((text = text.trim())) {
            warnOnce(
              `text &quot;${text}&quot; outside root element will be ignored.`,
              { start }
            )
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &amp;&amp;
        currentParent.tag === 'textarea' &amp;&amp;
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      const children = currentParent.children
      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text)
      } else if (!children.length) {
        text = ''
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          text = lineBreakRE.test(text) ? '' : ' '
        } else {
          text = ' '
        }
      } else {
        text = preserveWhitespace ? ' ' : ''
      }
      if (text) {
        if (!inPre &amp;&amp; whitespaceOption === 'condense') {
          text = text.replace(whitespaceRE, ' ')
        }
        let res
        let child: ?ASTNode
        if (!inVPre &amp;&amp; text !== ' ' &amp;&amp; (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text
          }
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text
          }
        }
        if (child) {
          if (process.env.NODE_ENV !== 'production' &amp;&amp; options.outputSourceRange) {
            child.start = start
            child.end = end
          }
          children.push(child)
        }
      }
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br></div></div><p>当解析到标签的文本时，触发<code>charts</code>钩子函数，在该钩子函数内部，首先会判断文本是不是一个带变量的动态文本，如“hello”。如果是动态文本，则创建动态文本类型的<code>AST</code>节点；如果不是动态文本，则创建纯静态文本类型的<code>AST</code>节点。</p> <ul><li>当解析到注释时调用<code>comment</code>函数生成注释类型的<code>AST</code>节点；</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 当解析到标签的注释时，触发comment
comment (text: string) {
  let element = {
    type: 3,
    text,
    isComment: true
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>当解析到标签的注释时，触发<code>comment</code>钩子函数，该钩子函数会创建一个注释类型的<code>AST</code>节点。</p> <p>一边解析不同的内容一边调用对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>，这就是<code>HTML</code>解析器所要做的工作。</p> <p><strong>如何解析不同的内容</strong></p> <p>要从模板字符串中解析出不同的内容，那</p> <ul><li>文本，例如“难凉热血”</li> <li>HTML 注释，例如<code>&lt;!--我是注释--&gt;</code></li> <li>条件注释，例如<code>&lt;!--[if !IE] --&gt;我是注释&lt;![endif]--&gt;</code></li> <li>DOCTYPE，例如<code>&lt;!DOCTYPE html&gt;</code></li> <li>开始标签，例如<code>&lt;div&gt;</code></li> <li>结束标签，例如<code>&lt;/div&gt;</code></li></ul> <p>这几种内容都有其各自独有的特点，也就是说我们要根据不同内容所具有的不同的特点通过编写不同的表达式将这些内容从模板字符串中一一解析出来，然后再把不同的内容做不同的处理。</p> <p><strong>解析 HTML 注释</strong></p> <p>解析注释比较简单，我们知道<code>HTML</code>注释是以<code>&lt;!--</code>开头，以<code>--&gt;</code>结尾，这两者中间的内容，那么我们只需用正则判断待解析的模板字符串<code>html</code>是否以<code>&lt;!--</code>开头，若是，那就继续向后寻找<code>--&gt;</code>，如果找到了，OK，溈就解析出来了。代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const comment = /^&lt;!\--/
if(comment.test(html)){
    // 若为注释，则继续查找是否存在'--&gt;'
    const commentEnd = html.indexOf('--&gt;')

    if(commentEnd &gt;= 0){
        // 若存在 '--&gt;'，继续判断options中是否保留注释
        if(options.shouldKeepComment){
            // 若保留注释，则把注释截取出来给options.comment，创建溈类型的AST节点
            options.comment(html,substring(4,commentEnd) index, index + commentEnd + 3)
        }
        // 若不保留注释，则将游标移动到'--&gt;'之后，继续向后解析
        advance(commentEnd+3)
        continue
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>如果模板字符串<code>html</code>符合注释开始的正则，那么就继续向后查找是否存在<code>--&gt;</code>，若存在，则把<code>html</code>从第 4 位（<code>&quot;&lt;!--&quot;</code>长度为 4）开始截取，直到<code>--&gt;</code>处，截取得到的内容就是注释的真实内容，然后调用 4 个钩子函数中的 comment 函数，将真实的注释内容传进去，创建注释类型的 AST 节点。</p> <p>在上面代码中，如果模板字符串<code>html</code>符合注释开始的正则，那么就继续向后查找是否存在<code>--&gt;</code>，若存在，则把<code>html</code>从第 4 位（<code>&quot;&lt;!--&quot;</code>长度为 4）开始截取，直到<code>--&gt;</code>处，截取得到的内容就是注释的真实内容，然后调用 4 个钩子函数中的<code>comment</code>函数，将真实的注释内容传进去，创建溈类型的<code>AST</code>节点。</p> <p>上面代码中有一处值得注意的地方，那就是我们平常在模板中可以在<code>&lt;template&gt;&lt;/template&gt;</code>标签上配置<code>comments</code></p> <p><code>advance</code>函数是用来移动解析游标的，解析完一部分就把游标向后移动一部分，确保不会重复解析，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function advance(n){
    index +=n       // index为解析游标
    html = html.substring(n)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>为了更加直观地说明<code>advance</code>的作用，请看下图：</p> <p><img src="vue15.png" alt="images"></p> <p>调用<code>advance</code>函数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>advance(3)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>得到结果：</p> <p><img src="vue16.png" alt="images"></p> <p>从图中可以看到，解析游标<code>index</code>最开始在模板字符串的位置 0 处，当调用了<code>advance(3)</code>之后，解析游标到了位置 3 处，每次解析完一段内容就将游标向后移动一段，接着再从解析游标往后解析，这样就保证了解析过的内容不会被重复解析。</p> <p><strong>解析条件注释</strong></p> <p>解析条件注释也比较简单，其原理跟解析注释相同，都是先用与正则判断是否是以条件注释特有的开头标识开始，然后寻找其特有的结束标识，若找到，则说明是条件注释，将其截取出来即可，由于条件注释不存在于真正的<code>DOM</code>树中，所以不需要调用钩子函数创建<code>AST</code>节点。代码如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 解析是否是条件注释
const conditionalComment = /^&lt;!\[/
if(conditionalComment.test(html)){
    // 若为条件注释，则继续查找是否存在']&gt;'
    const conditionalEnd = html.indexOf(']&gt;')

    if(conditionalEnd &gt;=0){
        // 若存在  ']&gt;',则从原本的html字符串中把条件注释裁掉
        // 把剩下的内容重新赋给html，继续向后匹配
        advance(conditionalEnd+2)
        continue
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>解析 DOCTYPE</strong></p> <p>解析<code>DOCTYPE</code>的原理同解析条件注释完全相同，此处不再赘述，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const doctype = /^&lt;!DOCTYPE [^&gt;]+&gt;/i
// 解析是否是DOCTYPE
const doctypeMatch  = html.match(doctype)
if (doctypeMatch) {
  advance(doctypeMatch[0].length)
  continue
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>解析开始标签</strong></p> <p>相较于前三种内容的解析，解析开始标签会稍微复杂一点，但是万变不离其宗，它的原理还是想通的，都是使用正则去匹配提取。</p> <p>首先使用开始标签的正则去匹配模板字符串，看模板字符串是否具有开始标签的特征，如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/**
 *  匹配开始标签的正则
 */
const ncname = '[a-zA-Z_][\\w\\-\\.]*';
const qnameCapture = `((?:${ncname}\\:)?${ncname})`
const startTagOpen = new RegExp(`^&lt;${qnameCapture}`)

const start = html.match(startTagOpen)
if(start){
    const match = {
    tagName: start[1],
    attrs: [],
    start: index
  }
}

// 以开始标签开始的模板：
'&lt;div&gt;&lt;/div&gt;'.match(startTagOpen)  =&gt; ['&lt;div','div',index:0,input:'&lt;div&gt;&lt;/div&gt;']
// 以结束标签开始的模板：
'&lt;/div&gt;&lt;div&gt;&lt;/div&gt;'.match(startTagOpen) =&gt; null
// 以文本开始的模板：
'我是文本&lt;/p&gt;'.match(startTagOpen) =&gt; null
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>当解析到开始标签时，会调用 4 个钩子函数中的<code>start</code>函数，而<code>start</code>函数需要传递 5 个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>、开始位置<code>start</code>、结束位置<code>end</code>。标签名通过与此同时的结果就可以拿到，即上面代码中的<code>start[1]</code>，而标签属性<code>attrs</code>以及标签是否自闭合<code>unary</code>需要进行一步解析。</p> <ol><li>解析标签属性</li></ol> <p>我们知道，标签属性一般是写在开始标签的标签名之后的，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>另外，我们在上面匹配是否开始标签正则中已经可以拿到开始标签的标签名，即上面代码中的<code>start[0]</code>，那么我们可以将这一部分先从模板字符串裁掉，则剩下的部分如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>我们只需用剩下的这部分去匹配标签属性的正则，就可以将标签属性提取出来了，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const attribute = /^\s*([^\s&quot;'&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|'([^']*)'+|([^\s&quot;'=&lt;&gt;`]+)))?/
let html = 'class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;'
let attr = html.match(attribute)
console.log(attr)
// [&quot;class=&quot;a&quot;&quot;, &quot;class&quot;, &quot;=&quot;, &quot;a&quot;, undefined, undefined, index: 0, input: &quot;class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;&quot;, groups: undefined]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可以看到，第一个标签属性<code>class=&quot;a&quot;</code>已经被拿到了。另外，标签属性有可能有多个也有可能没有，如果没有的话那好办，匹配标签属性的正则就会匹配失败，标签属性就为空数组；而如果标签属性有多个的话，那就需要循环匹配了，匹配出第一个标签属性后，就把该属性裁掉，用剩下的字符串继续匹配，走到不再满足正则为止，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const attribute = /^\s*([^\s&quot;'&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|'([^']*)'+|([^\s&quot;'=&lt;&gt;`]+)))?/
const startTagClose = /^\s*(\/?)&gt;/
const match = {
 tagName: start[1],
 attrs: [],
 start: index
}
 while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
 advance(attr[0].length)
 match.attrs.push(attr)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上面代码的<code>while</code>循环中，如果剩下的字符串不符合开始标签的结束特征（startTagClose）并且符合标签属性的特征的话，那就说明还有未提取出的标签属性，那就进入循环，继续提取，直到把所有标签属性都提取完毕。</p> <p>所谓不符合开始标签的结束特征是指当前剩下的字符串不是以开始标签结束符开头的，我们知道一个开始标签的结束符有可能是一个<code>&gt;</code>（非自闭合标签），也有可能是<code>/&gt;</code>（自闭合标签），如果剩下的字符串（如<code>&gt;&lt;/div&gt;</code>）以开始标签的结束符开头，那么就表示标签属性已经被提取完毕了。</p> <ol start="2"><li>解析标签是否是自闭合</li></ol> <p>在<code>HTML</code>中，有自闭合标签（如<code>&lt;img src=&quot;&quot; /&gt;</code>）也有非自闭合标签（如<code>&lt;div&gt;&lt;/div&gt;</code>），这两种类型的标签在创建<code>AST</code>节点是处理方式是有区别的，所以我们需要解析出当前标签是否自闭合标签。</p> <p>解析的方式很简单，我们知道，经过标签属性提取之后，那么剩下的字符串无非就两种，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!--非自闭合标签--&gt;
&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>或</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!--自闭合标签--&gt;
/&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>所以我们可以用剩下的字符串去切尔西开始标签结束符正则，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const startTagClose = /^\s*(\/?)&gt;/
let end = html.match(startTagClose)
'&gt;&lt;/div&gt;'.match(startTagClose) // [&quot;&gt;&quot;, &quot;&quot;, index: 0, input: &quot;&gt;&lt;/div&gt;&quot;, groups: undefined]
'/&gt;'.match(startTagClose) // [&quot;/&gt;&quot;, &quot;/&quot;, index: 0, input: &quot;/&gt;&lt;div&gt;&lt;/div&gt;&quot;, groups: undefined]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>可以看到，非自闭合标签匹配结果中的<code>end[1]</code>为<code>&quot;&quot;</code>，而自闭合标签匹配结果中的<code>end[1]</code>为<code>&quot;/&quot;</code>。所以根据匹配结果的<code>end[1]</code>是否是<code>&quot;&quot;</code>我们即可判断出当前标签是否为自闭合标签，源码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const startTagClose = /^\s*(\/?)&gt;/
let end = html.match(startTagClose)
if (end) {
 match.unarySlash = end[1]
 advance(end[0].length)
 match.end = index
 return match
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>解析完毕后，就可以用解析得到的结果去调用<code>start</code>钩子函数去创建元素型的<code>AST</code>节点了。</p> <p><code>Vue</code>并没有直接去调<code>start</code>钩子函数去创建<code>AST</code>节点，而是调用了<code>handleStartTag</code>函数，在该函数内部才去调用的<code>start</code>钩子函数，这是因为虽然经过<code>parseStartTag</code>函数已经把创建<code>AST</code>节点必要信息提出来了，但是提取出来的标签属性数组还是需要处理一下。<code>handleStartTag</code>函数源码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function handleStartTag (match) {
    const tagName = match.tagName
    const unarySlash = match.unarySlash

    if (expectHTML) {
      // ...
    }

    const unary = isUnaryTag(tagName) || !!unarySlash

    const l = match.attrs.length
    const attrs = new Array(l)
    for (let i = 0; i &lt; l; i++) {
      const args = match.attrs[i]
      const value = args[3] || args[4] || args[5] || ''
      const shouldDecodeNewlines = tagName === 'a' &amp;&amp; args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      }
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs })
      lastTag = tagName
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end)
    }
  }

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p><code>handleStartTag</code>函数用来对<code>parseStartTag</code>函数的解析结果进行进一步处理，它接收<code>parseStartTag</code>函数的返回值作为参数。</p> <p><code>handleStartTag</code>函数的开始定义几个常量：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const tagName = match.tagName       // 开始标签的标签名
const unarySlash = match.unarySlash  // 是否为自闭合标签的标志，自闭合为&quot;&quot;,非自闭合为&quot;/&quot;
const unary = isUnaryTag(tagName) || !!unarySlash  // 布尔值，标志是否为自闭合标签
const l = match.attrs.length    // match.attrs 数组的长度
const attrs = new Array(l)  // 一个与match.attrs数组长度相等的数组
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接下来是循环处理提取出来的标签属性数组<code>match.attrs</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (let i = 0; i &lt; l; i++) {
    const args = match.attrs[i]
    const value = args[3] || args[4] || args[5] || ''
    const shouldDecodeNewlines = tagName === 'a' &amp;&amp; args[1] === 'href'
    ? options.shouldDecodeNewlinesForHref
    : options.shouldDecodeNewlines
    attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>首先定义了 <code>args</code> 常量，它是解析出来的标签属性数组中的每一个属性对象，即 <code>match.attrs</code> 数组中每个元素对象。 它长这样：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const args = [&quot;class=&quot;a&quot;&quot;, &quot;class&quot;, &quot;=&quot;, &quot;a&quot;, undefined, undefined, index: 0, input: &quot;class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;&quot;, groups: undefined]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接下来是循环处理提取出来的标签属性数组<code>match.attrs</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (let i = 0; i &lt; l; i++) {
    const args = match.attrs[i]
    const value = args[3] || args[4] || args[5] || ''
    const shouldDecodeNewlines = tagName === 'a' &amp;&amp; args[1] === 'href'
    ? options.shouldDecodeNewlinesForHref
    : options.shouldDecodeNewlines
    attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>首先定义了<code>args</code>常量，它是解析出来的标签属性数组中的每一个属性对象，即<code>match.attrs</code>数组中每个元素对象。 它长这样：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const args = [&quot;class=&quot;a&quot;&quot;, &quot;class&quot;, &quot;=&quot;, &quot;a&quot;, undefined, undefined, index: 0, input: &quot;class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;&quot;, groups: undefined]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着定义了<code>value</code>，用于存储标签属性的属性值，我们可以看到，在代码中尝试取<code>args</code>的<code>args[3]</code>、<code>args[4]</code>、<code>args[5]</code>，如果都取不到，则给<code>value</code>复制为空</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const value = args[3] || args[4] || args[5] || ''
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着定义了<code>shouldDecodeNewlines</code>，这个常量主要是做一些兼容性处理， 如果 <code>shouldDecodeNewlines</code> 为 <code>true</code>，意味着 <code>Vue</code> 在编译模板的时候，要对属性值中的换行符或制表符做兼容处理。而<code>shouldDecodeNewlinesForHref</code> 为 <code>true</code> 意味着 <code>Vue</code>在编译模板的时候，要对 <code>a</code> 标签的 <code>href</code> 属性值中的换行符或制表符做兼容处理。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const shouldDecodeNewlines = tagName === 'a' &amp;&amp; args[1] === 'href'
    ? options.shouldDecodeNewlinesForHref
    : options.shouldDecodeNewlinesconst value = args[3] || args[4] || args[5] || ''
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>最后将处理好的结果存入之前定义好的与<code>match.attrs</code>数组长度相等的<code>attrs</code>数组中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>attrs[i] = {
    name: args[1],    // 标签属性的属性名，如class
    value: decodeAttr(value, shouldDecodeNewlines) // 标签属性的属性值，如class对应的a
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>最后，如果该标签是非自闭合标签，则将标签推入栈中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!unary) {
    stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs })
    lastTag = tagName
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果该标签是自闭标签，现在就可以调用<code>start</code>钩子函数并传入处理好的参数来创建<code>AST</code>节点了，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (options.start) {
    options.start(tagName, attrs, unary, match.start, match.end)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>解析结束标签</strong></p> <p>结束标签的解析要比解析开始标签容易多了，因为它不需要解析什么属性，只需要判断剩下的模板字符串是否符合结束标签的特征，如果是，就将结束标签名提取出来，再调用 4 个钩子函数中的<code>end</code>函数就好了。</p> <p>首先判断剩余的模板字符串是否符合结束标签的特征，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const ncname = '[a-zA-Z_][\\w\\-\\.]*'
const qnameCapture = `((?:${ncname}\\:)?${ncname})`
const endTag = new RegExp(`^&lt;\\/${qnameCapture}[^&gt;]*&gt;`)
const endTagMatch = html.match(endTag)

'&lt;/div&gt;'.match(endTag)  // [&quot;&lt;/div&gt;&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;/div&gt;&quot;, groups: undefined]
'&lt;div&gt;'.match(endTag)  // null
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果模板字符串结束标签的特征，则会获得匹配结果数组；如果不合符，则得到 null。</p> <p>接着再调用<code>end</code>钩子函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (endTagMatch) {
    const curIndex = index
    advance(endTagMatch[0].length)
    parseEndTag(endTagMatch[1], curIndex, index)
    continue
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>没有直接去调用 end 函数，而是调用了 parseEndTag 函数。</p> <p><strong>解析文本</strong></p> <p>在解析模板字符串之前，我们先查找一下第一个<code>&lt;</code>出现在什么位置，如果第一个<code>&lt;</code>在第一个位置，那么说明模板字符串是以其它 5 种类型开始的；如果第一个<code>&lt;</code>不在第一个位置而在模板字符串中某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了；如果在整个模板字符串里面没有找到<code>&lt;</code>，那说明整个模板字符串都是文本，源码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let textEnd = html.indexOf('&lt;')
// '&lt;' 在第一个位置，为其余5种类型
if (textEnd === 0) {
    // ...
}
// '&lt;' 不在第一个位置，文本开头
if (textEnd &gt;= 0) {
    // 如果html字符串不是以'&lt;'开头,说明'&lt;'前面的都是纯文本，无需处理
    // 那就把'&lt;'以后的内容拿出来赋给rest
    rest = html.slice(textEnd)
    while (
        !endTag.test(rest) &amp;&amp;
        !startTagOpen.test(rest) &amp;&amp;
        !comment.test(rest) &amp;&amp;
        !conditionalComment.test(rest)
    ) {
        // &lt; in plain text, be forgiving and treat it as text
        /**
           * 用'&lt;'以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment
           * 如果都匹配不上，表示'&lt;'是属于文本本身的内容
           */
        // 在'&lt;'之后查找是否还有'&lt;'
        next = rest.indexOf('&lt;', 1)
        // 如果没有了，表示'&lt;'后面也是文本
        if (next &lt; 0) break
        // 如果还有，表示'&lt;'是文本中的一个字符
        textEnd += next
        // 那就把next之后的内容截出来继续下一轮循环匹配
        rest = html.slice(textEnd)
    }
    // '&lt;'是结束标签的开始 ,说明从开始到'&lt;'都是文本，截取出来
    text = html.substring(0, textEnd)
    advance(textEnd)
}
// 整个模板字符串里没有找到`&lt;`,说明整个模板字符串都是文本
if (textEnd &lt; 0) {
    text = html
    html = ''
}
// 把截取出来的text转化成textAST
if (options.chars &amp;&amp; text) {
    options.chars(text)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><p>如果<code>&lt;</code> 不在第一个位置而在模板字符串间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了，接着我们还要从第一个<code>&lt;</code>的位置继续向后判断，因为还存在这样一种情况，那就是如果广西里面本来就包含一个<code>&lt;</code>，例如<code>1&lt;2&lt;/div&gt;</code>。为了处理这种情况，我们把从第一个<code>&lt;</code>的位置直到模板字符串结束都截取出来记作<code>rest</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let rest = html.slice(textEnd)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着用<code>rest</code>去匹配以上 5 种类型的正则，如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>while (
    !endTag.test(rest) &amp;&amp;
    !startTagOpen.test(rest) &amp;&amp;
    !comment.test(rest) &amp;&amp;
    !conditionalComment.test(rest)
) {

}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，接着以这个<code>&lt;</code>的位置继续向后查找，看是否还有<code>&lt;</code>，如果没有了，则表示后面的都是文本；如果后面还有下一个<code>&lt;</code>，那表明至少在这个<code>&lt;</code>到下一个<code>&lt;</code>中间的内容都是文本，至于下一个<code>&lt;</code>以后的内容是什么，则还需要重复以上的逻辑继续判断。代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>while (
    !endTag.test(rest) &amp;&amp;
    !startTagOpen.test(rest) &amp;&amp;
    !comment.test(rest) &amp;&amp;
    !conditionalComment.test(rest)
) {
    // &lt; in plain text, be forgiving and treat it as text
    /**
    * 用'&lt;'以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment
    * 如果都匹配不上，表示'&lt;'是属于文本本身的内容
    */
    // 在'&lt;'之后查找是否还有'&lt;'
    next = rest.indexOf('&lt;', 1)
    // 如果没有了，表示'&lt;'后面也是文本
    if (next &lt; 0) break
    // 如果还有，表示'&lt;'是文本中的一个字符
    textEnd += next
    // 那就把next之后的内容截出来继续下一轮循环匹配
    rest = html.slice(textEnd)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>最后截取文本内容 <code>text</code> 并调用 4 个钩子函数中的 <code>chars</code> 函数创建文本型的<code>AST</code> 节点。</p> <p><strong>如何保证 AST 节点层级关系</strong></p> <p><code>Vue</code>在<code>HTML</code>解析器的开头定义了一个栈<code>stack</code>，这个栈的作用就是用来维护<code>AST</code>节点层级的，<code>HTML</code>解析器在从前向后解析模板字符串时，每当遇到开始标签时就会调用<code>start</code>钩子函数，那么在<code>start</code>钩子函数内部我们可以将解析得到的开始标签推入栈中，而每当遇到结束标签时就会调用<code>end</code>钩子函数，那么我们也可以在<code>end</code>钩子函数内部将解析得到的结束标签所对应的开始标签从栈中弹出。</p> <p>解析器<code>parseHTML</code>函数，函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function parseHTML(html, options) {
	var stack = [];
	var expectHTML = options.expectHTML;
	var isUnaryTag$$1 = options.isUnaryTag || no;
	var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
	var index = 0;
	var last, lastTag;

	// 开启一个 while 循环，循环结束的条件是 html 为空，即 html 被 parse 完毕
	while (html) {
		last = html;
		// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)
		if (!lastTag || !isPlainTextElement(lastTag)) {
		   let textEnd = html.indexOf('&lt;')
              /**
               * 如果html字符串是以'&lt;'开头,则有以下几种可能
               * 开始标签:&lt;div&gt;
               * 结束标签:&lt;/div&gt;
               * 注释:&lt;!-- 我是注释 --&gt;
               * 条件注释:&lt;!-- [if !IE] --&gt; &lt;!-- [endif] --&gt;
               * DOCTYPE:&lt;!DOCTYPE html&gt;
               * 需要一一去匹配尝试
               */
            if (textEnd === 0) {
                // 解析是否是注释
        		if (comment.test(html)) {

                }
                // 解析是否是条件注释
                if (conditionalComment.test(html)) {

                }
                // 解析是否是DOCTYPE
                const doctypeMatch = html.match(doctype)
                if (doctypeMatch) {

                }
                // 解析是否是结束标签
                const endTagMatch = html.match(endTag)
                if (endTagMatch) {

                }
                // 匹配是否是开始标签
                const startTagMatch = parseStartTag()
                if (startTagMatch) {

                }
            }
            // 如果html字符串不是以'&lt;'开头,则解析文本类型
            let text, rest, next
            if (textEnd &gt;= 0) {

            }
            // 如果在html字符串中没有找到'&lt;'，表示这一段html字符串都是纯文本
            if (textEnd &lt; 0) {
                text = html
                html = ''
            }
            // 把截取出来的text转化成textAST
            if (options.chars &amp;&amp; text) {
                options.chars(text)
            }
		} else {
			// 父元素为script、style、textarea时，其内部的内容全部当做纯文本处理
		}

		//将整个字符串作为文本对待
		if (html === last) {
			options.chars &amp;&amp; options.chars(html);
			if (!stack.length &amp;&amp; options.warn) {
				options.warn((&quot;Mal-formatted tag at end of template: \&quot;&quot; + html + &quot;\&quot;&quot;));
			}
			break
		}
	}

	// Clean up any remaining tags
	parseEndTag();
	//parse 开始标签
	function parseStartTag() {

	}
	//处理 parseStartTag 的结果
	function handleStartTag(match) {

	}
	//parse 结束标签
	function parseEndTag(tagName, start, end) {

	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br></div></div><p>上述代码中大致分为三部分：</p> <ul><li>定义的一些常量和变量</li> <li>while 循环</li> <li>解析过程中用到的辅助函数</li></ul> <p>定义了几个常量，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const stack = []       // 维护AST节点层级的栈
const expectHTML = options.expectHTML
const isUnaryTag = options.isUnaryTag || no
const canBeLeftOpenTag = options.canBeLeftOpenTag || no   //用来检测一个标签是否是可以省略闭合标签的非自闭合标签
let index = 0   //解析游标，标识当前从何处开始解析模板字符串
let last,   // 存储剩余还未解析的模板字符串
    lastTag  // 存储着位于 stack 栈顶的元素
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>接着开启 while 循环，循环的终止条件是 模板字符串 html 为空，即模板字符串被全部编译完毕。在每次 while 循环中， 先把 html 的值赋给变量 last，如<code>last = html</code></p> <p>这样做的目的是，如果经过上述所有处理逻辑处理过后，<code>html</code>字符串没有任何变化，即表示<code>html</code>字符串没有匹配上任何一条规则，那么就把<code>html</code>字符串当作纯文本对待，创建文本类型的<code>AST</code>节点并且如果抛出异常：模板字符串中标签格式有误。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//将整个字符串作为文本对待
if (html === last) {
    options.chars &amp;&amp; options.chars(html);
    if (!stack.length &amp;&amp; options.warn) {
        options.warn((&quot;Mal-formatted tag at end of template: \&quot;&quot; + html + &quot;\&quot;&quot;));
    }
    break
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>接着，我们继续看<code>while</code>循环体内的代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>while (html) {
  // 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)
  if (!lastTag || !isPlainTextElement(lastTag)) {

  } else {
    // parse 的内容是在纯文本标签里 (script,style,textarea)
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在循环体内，首先判断了待解析的<code>html</code>字符串是否在纯文本标签里，如<code>script</code>，<code>style</code>，<code>textarea</code>，因为在这三个标签里的内容肯定不会有<code>HTML</code>标签，所以我们可直接当作文本处理，判断条件如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>!lastTag || !isPlainTextElement(lastTag)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>lastTag</code>为栈顶元素，<code>!lastTag</code>即表示当前<code>html</code>字符串没有父节点，而<code>isPlainTextElement(lastTag)</code> 是检测 <code>lastTag</code> 是否为是那三个纯文本标签之一，是的话返回<code>true</code>，不是返回<code>fasle</code></p> <p><strong>parseEndTag 函数源码</strong></p> <p>在解析结束标签时遗留的<code>parseEndTag</code>函数，该函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function parseEndTag (tagName, start, end) {
let pos, lowerCasedTagName
if (start == null) start = index
if (end == null) end = index

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase()
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos &gt;= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0
    }

    if (pos &gt;= 0) {
      // Close all the open elements, up the stack
      for (let i = stack.length - 1; i &gt;= pos; i--) {
        if (process.env.NODE_ENV !== 'production' &amp;&amp;
          (i &gt; pos || !tagName) &amp;&amp;
          options.warn
        ) {
          options.warn(
            `tag &lt;${stack[i].tag}&gt; has no matching end tag.`
          )
        }
        if (options.end) {
          options.end(stack[i].tag, start, end)
        }
      }

      // Remove the open elements from the stack
      stack.length = pos
      lastTag = pos &amp;&amp; stack[pos - 1].tag
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end)
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end)
      }
      if (options.end) {
        options.end(tagName, start, end)
      }
    }

}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br></div></div><p>该函数接收三个参数，分别是结束标签名<code>tagName</code>、结束标签在<code>html</code>字符串中的起始和结束位置<code>start</code>和<code>end</code>。</p> <p>这个三参数其实都是可选的，根据选参的不同其功能也不同。</p> <ul><li>第一种是三个参数都传递，用于处理普通的结束标签</li> <li>第二种是只传递<code>tagName</code></li> <li>第三种是三参数都不传递，用于处理栈中剩余未处理的标签</li></ul> <p>如果<code>tagName</code>存在，那么就从后往前遍历栈，在栈中寻找与<code>tagName</code>相同的标签并记录其所在的位置<code>pos</code>，如果<code>tagName</code>不存在，则将<code>pos</code>置为 0。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (tagName) {
    for (pos = stack.length - 1; pos &gt;= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
            break
        }
    }
} else {
    // If no tag name is provided, clean shop
    pos = 0
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>接着<code>pos&gt;=0</code>时，开启一个<code>for</code>循环，从栈顶位置从后向前遍历直到<code>pos</code>处，如果发现<code>stack</code>栈中存在索引大于<code>pos</code>元素，那么该元素一定是缺少闭合标签的，这是因为在正常情况下，<code>stack</code>栈的栈顶元素应该和当前的结束标签<code>tagName</code>匹配，也就是说正常的<code>pos</code>应该是栈顶位置，后面不应该再有元素，如果后面还有元素，那么后面的元素就都缺少闭合标签那么这个时候如果是在非生产环境会抛出警告，告诉你缺少闭合标签。除此之外，还会调用<code>options.end(stack[i].tag, start, end)</code> 立即将其闭合，这是为了保证解析结果的正确性。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (pos &gt;= 0) {
	// Close all the open elements, up the stack
	for (var i = stack.length - 1; i &gt;= pos; i--) {
		if (i &gt; pos || !tagName ) {
			options.warn(
				(&quot;tag &lt;&quot; + (stack[i].tag) + &quot;&gt; has no matching end tag.&quot;)
			);
		}
		if (options.end) {
			options.end(stack[i].tag, start, end);
		}
	}

	// Remove the open elements from the stack
	stack.length = pos;
	lastTag = pos &amp;&amp; stack[pos - 1].tag;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>最后把<code>pos</code>位置以后的元素都从<code>stack</code>栈中弹出，以及把<code>lastTag</code>更新为栈顶元素</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>stack.length = pos;
lastTag = pos &amp;&amp; stack[pos - 1].tag;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>接着，如果<code>pos</code>没有大于等于 0，即当<code>tagName</code>没有在<code>stack</code>栈中找到对应的开始标签时，<code>pos</code>为-1。那么此时再判断<code>tagName</code>是否为<code>br</code>或<code>p</code>标签，为什么要单独判断这两个标签呢？这是因为在浏览器中如果我们写了如下<code>HTML</code>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div&gt;
    &lt;/br&gt;
    &lt;/p&gt;
&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>浏览器会自动把<code>&lt;/br&gt;</code>标签解析为正常的<code>&lt;br&gt;</code>标签，而对于<code>&lt;/p&gt;</code>浏览器则自动将其补全为<code>&lt;p&gt;&lt;/p&gt;</code>，所以 Vue 为了与浏览器对这两个标签的行为保持一致，故对这两个便签单独判断处理，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (lowerCasedTagName === 'br') {
    if (options.start) {
        options.start(tagName, [], true, start, end)  // 创建&lt;br&gt;AST节点
    }
}
// 补全p标签并创建AST节点
if (lowerCasedTagName === 'p') {
    if (options.start) {
        options.start(tagName, [], false, start, end)
    }
    if (options.end) {
        options.end(tagName, start, end)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>以上就是对结束标签的解析与处理。</p> <p>另外，在<code>while</code>循环后面还有一行代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>parseEndTag()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这行代码执行的时机是<code>html===last</code>，即<code>html</code>字符串中的标签格式有误时会跳出<code>while</code>循环，此时就会执行这行代码，这行代码是调用<code>parseEndTag</code>函数并不传递任何参数，如果<code>parseEndTag</code>函数不传递任何参数是用于处理栈中剩余未处理的标签。这是因为如果不传递任何函数，此时<code>parseEndTag</code>函数里的<code>pos</code>就为 0，那么<code>pos&gt;=0</code>就会恒成立，那么就会逐个警告缺少闭合标签并调用<code>options.end</code>将其闭合。</p> <p><strong>总结</strong></p> <p>首先介绍了<code>HTML</code>解析器的工作流程，一句话概括就是：一边解析不同的内容一边调用对应的钩子对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>。</p> <p>接着介绍了<code>HTML</code>解析器是如何解析用户所写的模板字符串中各种类型的内容的，把各种类型的解析方式都分别进行了介绍。</p> <p>其次，介绍了在解析器内维护了一个栈，用来保证构建的<code>AST</code>节点层级与真正<code>DOM</code>层级一致。</p> <h4 id="_4-4-文本解析器"><a href="#_4-4-文本解析器" aria-hidden="true" class="header-anchor">#</a> 4.4 文本解析器</h4> <p>当<code>HTML</code>解析器解析到文本内容时会调用 4 个钩子函数中的<code>chars</code>函数来创建文本型的<code>AST</code>节点，并且也就说了在<code>chars</code>函数中会根据文本内容是否包含变量再细分为创建含有变量<code>AST</code>节点和不包含变量的<code>AST</code>节点，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 当解析到标签的文本时，触发chars
chars(text){
    if(res = parseText(text)){
       let element = {
           type: 2,
           expression: res.expression,
           tokens: res.tokens,
           text
       }
    } else {
       let element = {
           type: 3,
           text
       }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>创建含有变量的<code>AST</code>节点时节点的<code>type</code>属性为 2，并且相较于不包含变量的<code>AST</code>节点多了两个属性：<code>expression</code>和<code>tokens</code>。那么如何来判断文本里面是否包含变量以及多的那两个属性是什么呢？这就涉及到文本解析器了，当<code>Vue</code>用<code>HTML</code>解析器解析出文本时，再将解析出来的文本解析器，最后由文本解析器解析该段文本里面是否包含变量以及如果包含变量时再解析<code>expression</code>和<code>tokens</code>。</p> <p><strong>结果分析</strong></p> <p>从上面<code>chars</code>函数的代码中可以看到，把<code>HTML</code>解析器解析得到的文本内容<code>text</code>传给文本解析器<code>parseText</code>函数，根据<code>parseText</code>函数是否有返回值判断该文本是否包含变量，以及从返回值中取需要的<code>expression</code>和<code>tokens</code>。</p> <p>假设现有由 <code>HTML</code> 解析器解析得到的文本内容如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let text = &quot;我叫{{name}}，我今年{{age}}岁了&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>经过文本解析器解析后得到：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let res = parseText(text)
res = {
    expression:&quot;我叫&quot;+_s(name)+&quot;，我今年&quot;+_s(age)+&quot;岁了&quot;,
    tokens:[
        &quot;我叫&quot;,
        {'@binding': name },
        &quot;，我今年&quot;
        {'@binding': age },
    	&quot;岁了&quot;
    ]
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>从上面的结果中我们看到到，<code>expression</code>属性就是把广西中的变量和非变量提出来，然后把变量用<code>_s()</code>包裹，最后按照文本里的顺序把它们用<code>+</code>连接起来。而<code>tokens</code>是个数组，数组内容也是文本中的变量和非变量，不一样的是把变量构造成<code>{'@binding': xxx}</code>。</p> <p>这主要是为了给后面代码生成阶段的生成<code>render</code>函数时用的。</p> <p>文本解析器内部就干了三件事：</p> <ul><li>判断传入的文本是否包含变量</li> <li>构造 expression</li> <li>构造 tokens</li></ul> <p><strong>源码分析</strong></p> <p>文本解析器的源码位于<code>src/compiler/parser/text-parsre.js</code>中，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g
const buildRegex = cached(delimiters =&gt; {
const open = delimiters[0].replace(regexEscapeRE, '\\$&amp;')
  const close = delimiters[1].replace(regexEscapeRE, '\\$&amp;')
return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
})
export function parseText (text,delimiters) {
const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE
if (!tagRE.test(text)) {
return
}
const tokens = []
const rawTokens = []
/\*\*

- let lastIndex = tagRE.lastIndex = 0
- 上面这行代码等同于下面这两行代码:
- tagRE.lastIndex = 0
- let lastIndex = tagRE.lastIndex
  \*/
  let lastIndex = tagRE.lastIndex = 0
  let match, index, tokenValue
  while ((match = tagRE.exec(text))) {
  index = match.index
  // push text token
  if (index &gt; lastIndex) {
  // 先把'{{'前面的文本放入tokens中
      rawTokens.push(tokenValue = text.slice(lastIndex, index))
      tokens.push(JSON.stringify(tokenValue))
    }
    // tag token
    // 取出'{{ }}'中间的变量 exp
  const exp = parseFilters(match[1].trim())
  // 把变量 exp 改成\_s(exp)形式也放入 tokens 中
  tokens.push(`_s(${exp})`)
  rawTokens.push({ '@binding': exp })
  // 设置 lastIndex 以保证下一轮循环时，只从'}}'后面再开始匹配正则
  lastIndex = index + match[0].length
  }
  // 当剩下的 text 不再被正则匹配上时，表示所有变量已经处理完毕
  // 此时如果 lastIndex &lt; text.length，表示在最后一个变量后面还有文本
  // 最后将后面的文本再加入到 tokens 中
  if (lastIndex &lt; text.length) {
  rawTokens.push(tokenValue = text.slice(lastIndex))
  tokens.push(JSON.stringify(tokenValue))
  }

// 最后把数组 tokens 中的所有元素用'+'拼接起来
return {
expression: tokens.join('+'),
tokens: rawTokens
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><p>我们看到，除开我们自己加的注释，代码其实不复杂，我们逐行分析。</p> <p><code>parseText</code>函数接收两个参数，一个是传入的待解析的文本内容<code>text</code>，一个包裹变量的符号<code>delimiters</code>。第一个参数好理解，那第二个参数是干什么的呢？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>函数体内首先定义了变量<code>tagRE</code>，表示一个正则表达式。这个正则表达式是用来检查广西是否包含变量的。我们知道，通常我们在模板中写变量时是这样写的：hello。这里用<code>{{}}</code>包裹的内容就是变量。所以我们就知道，<code>tagRE</code>是用来检测文本内是否有<code>{{}}</code>。而 <code>tagRE</code> 又是可变的，它是根据是否传入了 <code>delimiters</code> 参数从而又不同的值，也就是说如果没有传入 <code>delimiters</code> 参数，则是检测文本是否包含<code>{{}}</code>，如果传入了值，就会检测文本是否包含传入的值。换句话说在开发 Vue 项目中，用户可以自定义文本内包含变量所使用的符号，例如你可以使用<code>%</code>包裹变量如：<code>hello %name%</code>。</p> <p>接下来用<code>tagRE</code>去匹配传入的文本内容，判断是否包含变量，若不包含，则直接返回，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!tagRE.test(text)) {
    return
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果包含变量，那就继续往下看：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const tokens = []
const rawTokens = []
let lastIndex = tagRE.lastIndex = 0
let match, index, tokenValue
while ((match = tagRE.exec(text))) {

}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>接下来会开启一个<code>while</code>循环，循环结束条件是<code>tagRE.exec(text)</code>的结果<code>match</code>是否为<code>null</code>，<code>exec()</code>方法是在一个字符串中执行切匹配检索，如果它没有找到任何切尔西就返回<code>null</code>，但如果它找到了一个匹配就返回一个数组，例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>tagRE.exec(&quot;hello {{name}}，I am {{age}}&quot;)
//返回：[&quot;{{name}}&quot;, &quot;name&quot;, index: 6, input: &quot;hello {{name}}，I am {{age}}&quot;, groups: undefined]
tagRE.exec(&quot;hello&quot;)
//返回：null
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当匹配上时，匹配结果的第一个元素是字符串中第一个完整的带有包裹的变量，第二个元素是第一个被包裹的变量名，第三个元素是第一个变量字符串中的起始位置。</p> <p>接着往下循环体内：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>while ((match = tagRE.exec(text))) {
    index = match.index
    if (index &gt; lastIndex) {
      // 先把'{{'前面的文本放入tokens中
      rawTokens.push(tokenValue = text.slice(lastIndex, index))
      tokens.push(JSON.stringify(tokenValue))
    }
    // tag token
    // 取出'{{ }}'中间的变量exp
    const exp = match[1].trim()
    // 把变量exp改成_s(exp)形式也放入tokens中
    tokens.push(`_s(${exp})`)
    rawTokens.push({ '@binding': exp })
    // 设置lastIndex 以保证下一轮循环时，只从'}}'后面再开始匹配正则
    lastIndex = index + match[0].length
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>首先取得字符串中第一个变量在字符串中的起始位置赋给<code>index</code>，然后比较<code>index</code>和<code>lastIndex</code>的大小，此时你可能有疑问了，这个<code>lastIndex</code>是什么呢？在上面定义变量中，定义了 <code>let lastIndex = tagRE.lastIndex = 0</code>,所以 <code>lastIndex</code> 就是 <code>tagRE.lastIndex</code>，而 <code>tagRE.lastIndex</code> 又是什么呢？当调用 <code>exec( )</code>的正则表达式对象具有修饰符 <code>g</code> 时，它将把当前正则表达式对象的 <code>lastIndex</code> 属性设置为紧挨着匹配子串的字符位置，当同一个正则表达式第二次调用 <code>exec( )</code>，它会将从 <code>lastIndex</code> 属性所指示的字符串处开始检索，如果 <code>exec( )</code>没有发现任何匹配结果，它会将 <code>lastIndex</code> 重置为 0。示例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const tagRE = /\{\{((?:.|\n)+?)\}\}/g
tagRE.exec(&quot;hello {{name}}，I am {{age}}&quot;)
tagRE.lastIndex   // 14
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>tagRE.lastIndex</code>就是第一个包裹变量最后一个<code>}</code>所在字符串中的位置。<code>lastIndex</code> 初始值为 0。</p> <p>当<code>index&gt;lastIndex</code>时，表示变量前面有纯文本，那么就把这段纯文本截取出来，存入<code>rawTokens</code>中，同时再调用<code>JSON.stringify</code>给这段文本包裹上双引号，存入<code>tokens</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (index &gt; lastIndex) {
    // 先把'{{'前面的文本放入tokens中
    rawTokens.push(tokenValue = text.slice(lastIndex, index))
    tokens.push(JSON.stringify(tokenValue))
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果<code>index</code>不大于<code>lastIndex</code>，那说明<code>index</code>也为 0，即该文本一开始就是变量，例如：<code>hello</code>。那么此时变量前面没有纯文本，那就不用截取，直接取出匹配结果的第一个元素变量名，将其用<code>_s()</code>包裹存入<code>tokens</code>中，同时再把变量名构造成<code>{'@binding': exp}</code>存入 <code>rawTokens</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 取出'{{ }}'中间的变量exp
const exp = match[1].trim()
// 把变量exp改成_s(exp)形式也放入tokens中
tokens.push(`_s(${exp})`)
rawTokens.push({ '@binding': exp })
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接着，更新 <code>lastIndex</code> 以保证下一轮循环时，只从<code>}}</code>后面再开始匹配正则，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>lastIndex = index + match[0].length
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着，当<code>while</code>循环完毕时，表明文本中所有变量已经被解析完毕，如果此时<code>lastIndex &lt; text.length</code>，那就说明最后一个变量的后面还有纯文本，那就将其再存入<code>tokens</code>和<code>rawTokens</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 当剩下的text不再被正则匹配上时，表示所有变量已经处理完毕
// 此时如果lastIndex &lt; text.length，表示在最后一个变量后面还有文本
// 最后将后面的文本再加入到tokens中
if (lastIndex &lt; text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex))
    tokens.push(JSON.stringify(tokenValue))
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>最后，把<code>tokens</code>数组里的元素用<code>+</code>连接，和<code>rawTokens</code>一并返回，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>return {
    expression: tokens.join('+'),
    tokens: rawTokens
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>总结</strong></p> <p>文本解析器的作用就是将<code>HTML</code>解析器解析得到的文本内容进行二次解析，解析文本内容中是否包含变量，如果包含变量，则将变量提取出进行加工，为后续生产<code>render</code>函数做准备。</p> <h4 id="_4-5-优化阶段"><a href="#_4-5-优化阶段" aria-hidden="true" class="header-anchor">#</a> 4.5 优化阶段</h4> <p>模板编译的最终目的是用模板生成一个<code>render</code>函数，而用<code>render</code>函数就可以生成与模板对应的<code>VNode</code>，之后再进行<code>patch</code>算法，最后完成视图渲染。这中间的<code>patch</code>算法又是用来对比新旧<code>VNode</code>之间存在的差异。静态节点不管状态怎么变化它是不会变的，基于此，在<code>patch</code>过程中不用去对比这些静态节点了。</p> <p>我们在模板编译的时候就先找出模板中所有的静态节点和静态根节点，然后给它们打上标记，用于告诉后面<code>patch</code>过程打了标记的这些节点是不需要对比的，你只要把它们克隆一份去用就好啦。这就是优化阶段存在的意义。</p> <p>优化阶段其实干了两件事：</p> <ol><li>在<code>AST</code>中找出所有静态节点并打上标记；</li> <li>在<code>AST</code>中找出所有表态根节点并打上标记；</li></ol> <p>优化阶段的源码位于<code>src/compiler/optimizer.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function optimize (root: ?ASTElement, options: CompilerOptions) {
if (!root) return
isStaticKey = genStaticKeysCached(options.staticKeys || '')
isPlatformReservedTag = options.isReservedTag || no
// 标记静态节点
markStatic(root)
// 标记静态根节点
markStaticRoots(root, false)
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>标记静态节点</strong></p> <p>从<code>AST</code>中找出所有静态节点并标记其实不难，我们只需从根节点开始，先标记点是否静态节点，然后看根节点如果是元素节点，那么就向下递归它的子节点，子节点如果还有子节点那就继续向下递归，直到标记完所有节点。代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function markStatic (node: ASTNode) {
node.static = isStatic(node)
if (node.type === 1) {
// do not make component slot content static. this avoids
// 1. components not able to mutate slot nodes
// 2. static slot content fails for hot-reloading
if (
!isPlatformReservedTag(node.tag) &amp;&amp;
node.tag !== 'slot' &amp;&amp;
node.attrsMap['inline-template'] == null
) {
return
}
for (let i = 0, l = node.children.length; i &lt; l; i++) {
const child = node.children[i]
markStatic(child)
if (!child.static) {
node.static = false
}
}
if (node.ifConditions) {
for (let i = 1, l = node.ifConditions.length; i &lt; l; i++) {
const block = node.ifConditions[i].block
markStatic(block)
if (!block.static) {
node.static = false
}
}
}
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>上面代码中，首先调用<code>isStatic</code>函数标记节点是否为静态节点，该函数若返回<code>true</code>表示该节点是静态节点，若返回<code>false</code>表示该节点不是静态节点，函数实现如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function isStatic (node: ASTNode): boolean {
if (node.type === 2) { // 包含变量的动态文本节点
return false
}
if (node.type === 3) { // 不包含变量的纯文本节点
return true
}
return !!(node.pre || (
!node.hasBindings &amp;&amp; // no dynamic bindings
!node.if &amp;&amp; !node.for &amp;&amp; // not v-if or v-for or v-else
!isBuiltInTag(node.tag) &amp;&amp; // not a built-in
isPlatformReservedTag(node.tag) &amp;&amp; // not a component
!isDirectChildOfTemplateFor(node) &amp;&amp;
Object.keys(node).every(isStaticKey)
))
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>该函数的实现过程其实也说明了如何判断一个节点是否为静态节点。还记得在<code>HTML</code>解析器在调用钩子函数创建<code>AST</code>节点时会根据节点类型的不同为节点加上不同的<code>type</code>属性，用<code>type</code>属性来标记<code>AST</code>节点的节点类型，其对应关系如下：</p> <table><thead><tr><th>type 取值</th> <th>对应的 AST 节点类型</th></tr></thead> <tbody><tr><td>1</td> <td>元素节点</td></tr> <tr><td>2</td> <td>包含变量的动态文本节点</td></tr> <tr><td>3</td> <td>不包含变量的纯文本节点</td></tr></tbody></table> <p>在判断一个节点是否为静态节点时首先会根据<code>type</code>值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果<code>type</code>值为 2，</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (node.type === 3) { // 不包含变量的纯文本节点
    return true
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果<code>type</code>值为 1</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>node.pre ||
(
    !node.hasBindings &amp;&amp; // no dynamic bindings
    !node.if &amp;&amp; !node.for &amp;&amp; // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) &amp;&amp; // not a built-in
    isPlatformReservedTag(node.tag) &amp;&amp; // not a component
    !isDirectChildOfTemplateFor(node) &amp;&amp;
    Object.keys(node).every(isStaticKey)
)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如果元素节点是静态节点，那就必须满足以下几点要求：</p> <ul><li>如果节点使用<code>v-pre</code>指令，那就断定它是静态节点；</li> <li>如果节点没有使用<code>v-pre</code>指令，那它要成为静态节点必须满足：
<ul><li>不能使用动态绑定语法，即标签上不能有<code>v-</code>、<code>@</code>、<code>:</code>开头的属性；</li> <li>不能使用<code>v-if</code>、<code>v-else</code>、<code>v-for</code> 指令；</li> <li>不能是内置组件，即标签名不能是<code>slot</code>和<code>component</code>;</li> <li>标签名必须是平台保留标签，即不能是组件；</li> <li>当前节点的父节点不能是带有<code>v-for</code>和<code>template</code>标签；</li> <li>节点的所有属性的<code>key</code>都必须是静态节点才有的<code>key</code>，注：静态节点的<code>key</code>是有限的，它只能是<code>type</code>、<code>tag</code>、<code>attrsList</code>、<code>attrsMap</code>、<code>plain</code>、<code>parent</code>、<code>children</code>、<code>attrs</code>之一；</li></ul></li></ul> <p>标记完当前节点是否为静态节点之后，如果该节点是元素节点，那么还要继续去递归判断它的子节点，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (let i = 0, l = node.children.length; i &lt; l; i++) {
    const child = node.children[i]
    markStatic(child)
    if (!child.static) {
    node.static = false
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>新增了一个判断：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!child.static) {
    node.static = false
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果当前节点的子节点有一个不是静态节点，那就把当前节点也标记为非静态节点。我们在判断的时候是从上往下判断的，也就是说先判断当前节点，再判断当前节点的子节点，如果当前在一开始被标记为了静态节点，但是通过判断子节点的时候发现有一个子节点却不是静态节点，这就有问题了，我们之前说过一旦标记为静态节点，就说明这个节点首次渲染之后不会再发生任何变化，但是它的一个子节点却又是可以变化的，就出现了自相矛盾，所以我们需要当发现它的子节点中有一个不是静态节点的时候，就得把当前节点重新设置为非静态节点。</p> <p>循环<code>node.children</code>后还不算把所有子节点都遍历完，因为如果当前节点的子节点中有标签带有<code>v-if</code>、<code>v-else-if</code>、<code>v-else</code>等指令时，这些子节点在每次渲染时都只渲染一个，所以其余没有被渲染的肯定不在<code>node.children</code>中，而是存在于<code>node.ifConditions</code>，所以我们还要把<code>node.ifConditions</code>循环一遍，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (node.ifConditions) {
    for (let i = 1, l = node.ifConditions.length; i &lt; l; i++) {
        const block = node.ifConditions[i].block
        markStatic(block)
        if (!block.static) {
            node.static = false
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>同理，如果当前节点的<code>node.ifConditions</code>中有一个子节点不是静态节点也要将当前节点设置为非静态节点。</p> <p><strong>标记静态根节点</strong></p> <p>寻找表态根节点找静态节点的逻辑类似，都是从<code>AST</code>根节点递归向上遍历寻找，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function markStaticRoots (node: ASTNode, isInFor: boolean) {
if (node.type === 1) {
if (node.static || node.once) {
node.staticInFor = isInFor
}
// For a node to qualify as a static root, it should have children that
// are not just static text. Otherwise the cost of hoisting out will
// outweigh the benefits and it's better off to just always render it fresh.
if (node.static &amp;&amp; node.children.length &amp;&amp; !(
node.children.length === 1 &amp;&amp;
node.children[0].type === 3
)) {
node.staticRoot = true
return
} else {
node.staticRoot = false
}
if (node.children) {
for (let i = 0, l = node.children.length; i &lt; l; i++) {
markStaticRoots(node.children[i], isInFor || !!node.for)
}
}
if (node.ifConditions) {
for (let i = 1, l = node.ifConditions.length; i &lt; l; i++) {
markStaticRoots(node.ifConditions[i].block, isInFor)
}
}
}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p><code>markStaticRoots</code>第二个参数是<code>isInFor</code>，对于已经是<code>static</code>的节点或者是<code>v-once</code>指令的节点，<code>node.staicInFor = isInFor</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (node.static || node.once) {
    node.staticInFor = isInFor
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>接着判断该节点是否为静态根节点，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (node.static &amp;&amp; node.children.length &amp;&amp; !(
    node.children.length === 1 &amp;&amp;
    node.children[0].type === 3
)) {
    node.staticRoot = true
    return
} else {
    node.staticRoot = false
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>一个节点要想成为表态根节点，它必须满足以下要求：</p> <ul><li>节点本身必须是静态节点；</li> <li>必须拥有子节点<code>children</code>；</li> <li>子节点不能只是只有一个</li></ul> <p>否则的话，对它的优化成本将大于优化后带来的收益。</p> <p>如果当前节点不是静态根节点，那就继续递归遍历它的子节点<code>node.children和node.ifConditions</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (node.children) {
    for (let i = 0, l = node.children.length; i &lt; l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for)
    }
}
if (node.ifConditions) {
    for (let i = 1, l = node.ifConditions.length; i &lt; l; i++) {
        markStaticRoots(node.ifConditions[i].block, isInFor)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>总结</strong></p> <p>首先，介绍了为什么要有优化阶段，是为了提高虚拟<code>DOM</code>中<code>patch</code>过程的性能。在优化阶段将所有表态节点都打上标记，这样在<code>patch</code>过程中就可以跳过对比这些节点。</p> <p>接着，介绍了优化阶段主要干了两件事件，分别是从构建出的<code>AST</code>中找出并标记所有静态节点和所有表态根节点。</p> <h4 id="_4-6-代码生成阶段"><a href="#_4-6-代码生成阶段" aria-hidden="true" class="header-anchor">#</a> 4.6 代码生成阶段</h4> <p><code>Vue</code>实例在挂载的时候会调用其自身的<code>render</code>函数来生成实例上的<code>template</code>选项所对应的<code>VNode</code>，简单的来说就是<code>Vue</code>只要调用了<code>render</code>函数，就可以把模板转换成对应的虚拟<code>DOM</code>。那么<code>Vue</code>要想调用<code>render</code>函数，那必须先有这个<code>render</code>函数，那这个<code>render</code>函数又是从哪来的呢？是用户手写的还是<code>Vue</code>自己生成的？答案是都有可能。我们在日常开发中是可以在<code>Vue</code>组件选项中手写一个<code>render</code>选项，其值对应一个函数，那这个函数就是<code>render</code>函数，当用户手写了<code>render</code>函数时，那么<code>Vue</code>在挂载该组件的时候就会调用用户手写的这个<code>render</code>函数。那如果用户没有写呢？那这个时候<code>Vue</code>就要自己根据模板内容生成一个<code>render</code>函数供组件挂载的时候调用。</p> <p><strong>如何根据 AST 生成 render 函数</strong></p> <p>代码生成阶段主要的工作就是根据已有的<code>AST</code>生成对应的<code>render</code>函数供组件挂载时调用，组件只要调用的这个<code>render</code>函数就可以得到<code>AST</code>对应的虚拟<code>DOM</code>的<code>VNode</code>。那么如何根据<code>AST</code>生成<code>render</code>函数呢？</p> <p>假设现有如下模板：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div id=&quot;NLRX&quot;&gt;&lt;p&gt;Hello {{name}}&lt;/p&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>该模板经过解析并优化后对应的<code>AST</code>如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ast = {
    'type':1,
    'tag':'div',
    'attrsList':[
        {
            'name':'id',
            'value':'NLRX'
        }
    ],
    'attrsMap':{
        'id':'NLRX'
    },
    'static':false,
    'parent':undefined,
    'plain':false,
    'children':[{
        'type':1,
        'tag':'p',
        'plain':false,
        'static':false,
        'children':[
            {
                'type': 2,
                'expression': '&quot;Hello &quot;+_s(name)',
                'text': 'Hello {{name}}',
                'static':false,
            }
        ]
    }]
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>根据已有的这个<code>AST</code>来生成对应的<code>render</code>函数。生成<code>render</code>函数的过程其实就是一个递归的过程，从顶向下依次递归<code>AST</code>中的每一个节点，根据不同的<code>AST</code>节点类型创建不同的<code>VNode</code>类型。接下来我们就来照已有的模板和<code>AST</code>实际演示了一下生成<code>render</code>函数的过程。</p> <ol><li>首先，根节点<code>div</code>是一个元素型<code>AST</code>节点，那么我们就要创建一个元素型<code>VNode</code>，我们把创建元素型<code>VNode</code>的方法叫做<code>_c(tagName,data,children)</code>。我们暂且不管<code>_c()</code>是什么，只需知道调用<code>_c()</code>就可以创建一个元素型<code>VNode</code>。那么就可以生成如下代码：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>_c('div',{attrs:{&quot;id&quot;:&quot;NLRX&quot;}},[/*子节点列表*/])
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="2"><li>根节点<code>div</code>有子节点，那么我们进入子节点列表<code>children</code>里遍历子节点，发现子节点<code>p</code>也是元素型的，那就继续创建元素型<code>VNode</code>并将其放入上述代码中根节点的子节点列表中，如下：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>_c('div',{attrs:{&quot;id&quot;:&quot;NLRX&quot;}},[_c('p',{attrs:{}},[/*子节点列表*/])])
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="3"><li>同理，继续遍历<code>p</code>节点的子节点，发现是一个文本型节点，那就创建一个文本型<code>VNode</code>并将其插入到<code>p</code>节点的子节点列表中，同理，创建文本型<code>VNode</code>我们调用<code>_v()</code>方法，如下：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>_c('div',{attrs:{&quot;id&quot;:&quot;NLRX&quot;}},[_c('p',{attrs:{}},[_v(&quot;Hello &quot;+_s(name))])])
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="4"><li>到此，整个<code>AST</code>就遍历完毕了，我们将得到的代码再包装一下，如下：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code> with(this){
   reurn _c(
     'div',
     {
       attrs:{&quot;id&quot;:&quot;NLRX&quot;},
     },
     [
       _c(
         'p',
         {
           attrs:{}
         },
         [
           _v(&quot;Hello &quot;+_s(name))
         ]
       )
     ]
   )
 }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><ol start="5"><li>最后，我们将上面得到的这个函数字符串传递给<code>createFunction</code>函数，<code>createFunction</code>函数会帮我们把得到的函数字符串转换成真正的函数，赋给组件中的<code>render</code>选项，从而就是<code>render</code>选项，从而就是<code>render</code>函数了。如下：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>res.render = createFunction(compiled.render, fnGenErrors)

function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err, code })
    return noop
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>源码分析</strong></p> <p>代码生成阶段的源码位于<code>src/compiler/codegen/index.js</code>中，源码虽然很长，但是逻辑不复杂，核心逻辑如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function generate (ast,option) {
  const state = new CodegenState(options)
  const code = ast ? genElement(ast, state) : '_c(&quot;div&quot;)'
  return {
    render: `with(this){return ${code}}`,
    staticRenderFns: state.staticRenderFns
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>调用<code>generate</code>函数并传入优化后得到的<code>ast</code>，在<code>generate</code>函数内部先判断<code>ast</code>是否为空，不为空则调用<code>genElement(ast, state)</code>函数创建<code>VNode</code>，为空则创建一上空的元素型<code>div</code>的<code>VNode</code>。然后将得到的结果用<code>with(this){return ${code}}</code>包裹返回。可以看出，真正起作用的是<code>genElement</code>函数。</p> <p><code>genElement</code>函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function genElement (el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre
  }

  if (el.staticRoot &amp;&amp; !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once &amp;&amp; !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for &amp;&amp; !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if &amp;&amp; !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    let code
    if (el.component) {
      code = genComponent(el.component, el, state)
    } else {
      let data
      if (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) {
        data = genData(el, state)
      }

      const children = el.inlineTemplate ? null : genChildren(el, state, true)
      code = `_c('${el.tag}'${
        data ? `,${data}` : '' // data
      }${
        children ? `,${children}` : '' // children
      })`
    }
    // module transforms
    for (let i = 0; i &lt; state.transforms.length; i++) {
      code = state.transforms[i](el, code)
    }
    return code
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p><code>genElement</code>函数逻辑很清晰，就是根据当前<code>AST</code>元素节点属性不同从而执行不同的代码生成函数。虽然元素节点属性的情况有很多种，但是最后真正创建出来的<code>VNode</code>无非就三种，分别是元素节点，文本节点，注释节点。</p> <p><strong>元素节点</strong></p> <p>生成元素型节点的<code>render</code>函数代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const data = el.plain ? undefined : genData(el, state)

const children = el.inlineTemplate ? null : genChildren(el, state, true)
code = `_c('${el.tag}'${
data ? `,${data}` : '' // data
}${
children ? `,${children}` : '' // children
})`
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>生成元素节点的<code>render</code>函数就是生成一个<code>_c()</code>函数调用的字符串，上文提到了<code>_c()</code>函数接收三个参数，分别是节点的标签名<code>tagName</code>，节点属性<code>data</code>，节点的子节点列表<code>children</code>。我们只需将这三部分都填进去即可。</p> <ol><li>获取节点属性 data</li></ol> <p>首先判断<code>plain</code>属性是否为<code>true</code>，若为<code>true</code>则表示节点没有属性，将<code>data</code>赋值为<code>undefined</code>；如果不为<code>true</code>则调用<code>genData</code>函数获取节点属性<code>data</code>数据。<code>genData</code>函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function genData (el: ASTElement, state: CodegenState): string {
  let data = '{'
  const dirs = genDirectives(el, state)
  if (dirs) data += dirs + ','

    // key
    if (el.key) {
        data += `key:${el.key},`
    }
    // ref
    if (el.ref) {
        data += `ref:${el.ref},`
    }
    if (el.refInFor) {
        data += `refInFor:true,`
    }
    // pre
    if (el.pre) {
        data += `pre:true,`
    }
    // 篇幅所限，省略其他情况的判断
    data = data.replace(/,$/, '') + '}'
    return data
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>源码中<code>genData</code>虽然很长，但是其逻辑非常简单，就是在拼接字符串,先给<code>data</code>赋值为一个<code>{</code>，然后判断存在哪些属性数据，就将这些数据拼接到<code>data</code>中，最后再加一个<code>}</code>，最终得到节点全部属性<code>data</code>。</p> <ol start="2"><li>获取子节点列表 children</li></ol> <p>获取子节点列表<code>children</code>其实就是遍历<code>AST</code>的<code>children</code>属性中的元素，然后根据元素属性的不同生成不同的<code>VNode</code>创建函数调用字符串，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function genChildren (el):  {
    if (children.length) {
        return `[${children.map(c =&gt; genNode(c, state)).join(',')}]`
    }
}
function genNode (node: ASTNode, state: CodegenState): string {
  if (node.type === 1) {
    return genElement(node, state)
  } if (node.type === 3 &amp;&amp; node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ol start="3"><li>上面两步完成之后，生成<code>_c()</code>函数调用字符串，如下：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>code = `_c('${el.tag}'${
    data ? `,${data}` : '' // data
}${
    children ? `,${children}` : '' // children
})`
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>文本节点</strong></p> <p>文本型的<code>VNode</code>可以调用<code>_v(text)</code>函数来创建，所以生成文本节点的<code>render</code>函数就是生成一个<code>_v(text)</code>函数调用的字符串。<code>_v()</code>函数接收文本内容作为参数，如果文本是动态文本，则使用动态文本<code>AST</code>节点的<code>expression</code>属性，如果是纯静态文本，则使用<code>text</code>属性，其生成代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function genText (text: ASTText | ASTExpression): string {
  return `_v(${text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))
  })`
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>注释节点</strong></p> <p>注释型的<code>VNode</code>可以调用<code>_e(text)</code>函数来创建，所以生成注释节点的<code>render</code>函数就是生成一个<code>_e(text)</code>函数调用的字符串。<code>_e()</code>函数接收注释内容作为参数，其生成代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function genComment (comment: ASTText): string {
  return `_e(${JSON.stringify(comment.text)})`
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>总结</strong></p> <p>首先，介绍了为什么要有代码生成阶段以及代码生成阶段主要干什么。我们知道了，代码生成其实就是根据模板对应的抽象语法树<code>AST</code>生成一个函数供组件挂载时调用，通过调用这个函数就可以得到模板对应的虚拟<code>DOM</code>。</p> <p>接着，我们通过一个简单的模板演示了把模板经过递归遍历最后生成<code>render</code>函数的过程。</p> <p>最后，我们回归源码，通过分析源码了解了生成<code>render</code>函数的具体实现过程。</p> <h4 id="_4-7-整体流程"><a href="#_4-7-整体流程" aria-hidden="true" class="header-anchor">#</a> 4.7 整体流程</h4> <p>模板编译就是把模板转化成供<code>Vue</code>实例在挂载时可以调用的<code>render</code>函数。那么我们就从<code>Vue</code>实例挂载时入手，一步一步从后往前推。<code>Vue</code>实例在挂载时会调用全局实例方法——<code>$mount</code>方法。<code>$mount</code>方法，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$mount = function(el) {
  const options = this.$options;
  // 如果用户没有手写render函数
  if (!options.render) {
    // 获取模板，先尝试获取内部模板，如果获取不到则获取外部模板
    let template = options.template;
    if (template) {
    } else {
      template = getOuterHTML(el);
    }
    const { render, staticRenderFns } = compileToFunctions(
      template,
      {
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      },
      this
    );
    options.render = render;
    options.staticRenderFns = staticRenderFns;
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>首先从<code>Vue</code>实例的属性选项中获取<code>render</code>选项，如果没有获取到，说明用户没有手写<code>render</code>函数，那么此时，需要<code>Vue</code>自己将模板转化成<code>render</code>函数。接着获取模板，先尝试获取内部模板，如果获取不到则获取外部模板。最后，调用<code>compileToFunctions</code>函数将模板转化成 <code>render</code> 函数，再将 <code>render</code> 函数赋值给 <code>options.render</code>。</p> <p>核心部分是调用 <code>compileToFunctions</code> 函数生成 <code>render</code> 函数的部分，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const { render, staticRenderFns } = compileToFunctions(
  template,
  {
    shouldDecodeNewlines,
    shouldDecodeNewlinesForHref,
    delimiters: options.delimiters,
    comments: options.comments
  },
  this
);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>将模板<code>template</code>传给<code>compileToFunctions</code>函数就可以得到<code>render</code>函数，那这个<code>compileToFunctions</code>函数是怎么来的呢？</p> <p>通过代码跳转发现<code>compileToFunctions</code>函数的出处如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const { compile, compileToFunctions } = createCompiler(baseOptions);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>compileToFunctions</code>函数是<code>createCompiler</code>函数的返回值对象中的其中一个，<code>createCompiler</code>函数顾名思义他的作用就是创建一个编译器。</p> <p><code>createCompiler</code>函数出处位于源码的<code>src/complier/index.js</code>文件中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export const createCompiler = createCompilerCreator(function baseCompile(
  template: string,
  options: CompilerOptions
): CompiledResult {
  // 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST
  const ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    // 优化阶段：遍历AST，找出其中的静态节点，并打上标记；
    optimize(ast, options);
  }
  // 代码生成阶段：将AST转换成渲染函数；
  const code = generate(ast, options);
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><code>createCompiler</code>函数是又调用<code>createCompilerCreator</code>函数返回得到的，<code>createCompilerCreator</code>函数接收一个<code>baseCompile</code>函数作为参数。这个<code>baseCompile</code>函数，这个函数就是我们据说的模板编译三大阶段的主函数。这个函数传给<code>createCompilerCreator</code>函数就可以得到<code>createCompiler</code>函数，那么我们再往前推，看一下<code>createCompilerCreator</code>函数又是怎么定义的。</p> <p><code>createCompilerCreator</code>函数的定义位于源码的<code>src/complier/create-compiler.js</code>文件中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {};
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>调用<code>createCompilerCreator</code>函数会返回<code>createCompiler</code>函数，可以看到<code>createCompiler</code>函数的定义，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function createCompiler(baseOptions) {
  function compile() {}
  return {
    compile,
    compileToFunctions: createCompileToFunctionFn(compile)
  };
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在<code>createCompiler</code>函数的内部定义了一个子函数<code>compile</code>，同时返回一个对象，其中这个对象的第二个属性就是我们在开头看到的<code>compileToFunctions</code>，其值对应的是<code>createCompileToFunctionFn(compile)</code>函数的返回值。</p> <p><code>createCompileToFunctionFn(compile)</code>函数的出处位于源码的<code>src/complier/to-function.js</code>文件中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function createCompileToFunctionFn(compile) {
  return function compileToFunctions() {
    // compile
    const res = {};
    const compiled = compile(template, options);
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(code =&gt; {
      return createFunction(code, fnGenErrors);
    });
    return res;
  };
}

function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({ err, code });
    return noop;
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>调用<code>createCompileToFunctionFn</code>函数就可以得到</p> <p><code>compileToFunctions</code>函数内部会调用传入的<code>compile</code>函数，而这个<code>compile</code>函数是<code>createCompiler</code>函数内部定义的子函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function compile(template, options) {
  const compiled = baseCompile(template, finalOptions);
  compiled.errors = errors;
  compiled.tips = tips;
  return compiled;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在<code>compile</code>函数内部又会调用传入的<code>baseCompile</code>函数，而这个<code>baseCompile</code>函数就是我们所说的模板编译三大阶段的主线函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  // 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    // 优化阶段：遍历AST，找出其中的静态节点，并打上标记；
    optimize(ast, options)
  }
  // 代码生成阶段：将AST转换成渲染函数；
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>最开始调用的<code>compileToFunctions</code>函数内部调用了<code>compile</code>函数，在<code>compile</code>函数内部又调用了<code>baseCompile</code>函数，而<code>baseCompile</code>函数返回的是代码生成阶段生成好的<code>render</code> 函数字符串。所以在<code>compileToFunctions</code>函数内部调用<code>compile</code>函数就可以拿到生成好的<code>render</code>函数字符串，然后在<code>compileToFunctions</code>函数内部将<code>render</code>函数字符串传给<code>createFunction</code>函数从而变成真正的<code>render</code>函数返回出去，最后将其赋值给<code>options.render</code>。画出其上述过程的流程图。如下：</p> <p><img src="vue18.jpg" alt="images"></p> <p>模板编译的整体流程。</p> <p><strong>整体导图</strong></p> <p><img src="vue19.jpg" alt="images"></p> <h3 id="五、生命周期篇"><a href="#五、生命周期篇" aria-hidden="true" class="header-anchor">#</a> 五、生命周期篇</h3> <ul><li><a href="#_5-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5">初始化阶段</a></li> <li><a href="#_5-2-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">模板编译阶段</a></li> <li><a href="#_5-3-%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5">挂载阶段</a></li> <li><a href="#_5-4-%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5">销毁阶段</a></li></ul> <p><code>Vue</code>实例的生命周期大致可分为 4 个阶段：</p> <ul><li>初始化阶段：为<code>Vue</code>实例上初始化一些属性，事件以及响应式数据；</li> <li>模板编译阶段：将模板编译成渲染函数；</li> <li>挂载阶段：将实例挂载到指定的<code>DOM</code>上，即将模板渲染到真实<code>DOM</code>中；</li> <li>销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；</li></ul> <h4 id="_5-1-初始化阶段"><a href="#_5-1-初始化阶段" aria-hidden="true" class="header-anchor">#</a> 5.1 初始化阶段</h4> <ul><li><code>new Vue</code></li> <li><code>initLifecycle</code></li> <li><code>initEvents</code></li> <li><code>initInjections</code></li> <li><code>initState</code></li></ul> <p><strong>new Vue 都干了什么</strong></p> <p>初始化阶段所做的第一件事就是<code>new Vue()</code>创建一个<code>Vue</code>实例，那么<code>new Vue()</code>的内部都干了什么呢？我们知道，<code>new</code>关键字在<code>JS</code>中表示从一个类中实例化出一个对象来，由此可见，<code>Vue</code>实际上是一个类。所以<code>new Vue()</code>实际上是执行了<code>Vue</code>类的构造函数，<code>Vue</code>类的定义是在源码的<code>src/core/instance/index.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function Vue (options) {
if (process.env.NODE_ENV !== 'production' &amp;&amp;
!(this instanceof Vue)
) {
warn('Vue is a constructor and should be called with the `new` keyword')
}
this._init(options)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>可以看到，<code>Vue</code>类的定义非常简单，其构造函数核心就一行代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>this._init(options)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>调用原型上的<code>_init(options)</code>方法并把用户所写的选项<code>options</code>传入。在<code>Vue</code>类定义的下面还有几行代码，其中之一就是：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>initMixin(Vue)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这一行代码执行了<code>initMixin</code>函数，那<code>initMixin</code>函数又是从哪儿来的呢？该函数定义位于源码的``中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    const vm = this
    vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
    )
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>在<code>initMixin</code>函数内部就只干了一件事，那就是给<code>Vue</code>类的原型上绑定<code>_init</code>方法，同时<code>_init</code> 方法的定义也在该函数内部。<code>new Vue()</code> 会执行<code>Vue</code>类的构造函数，构造函数内部会执行<code>_init</code>方法，所以<code>new Vue()</code>所干的事情其实就是<code>_init</code>方法所干的事情。</p> <p>首先，把<code>Vue</code>实例赋值给变量<code>vm</code>，并且把用户传递的<code>options</code>选项与当前构造函数的<code>options</code>属性及其父级构造函数的<code>options</code>属性进行合并，得到一个新的<code>options</code>选项赋值给$options 属性，并将<code>$options</code>属性挂载到<code>Vue</code>实例上，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$options = mergeOptions(
    resolveConstructorOptions(vm.constructor),
    options || {},
    vm
)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接着，通过调用一些初始化函数来为<code>Vue</code>实例初始化一些属性，事件，响应式数据等，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>initLifecycle(vm)       // 初始化生命周期
initEvents(vm)        // 初始化事件
initRender(vm)         // 初始化渲染
callHook(vm, 'beforeCreate')  // 调用生命周期钩子函数
initInjections(vm)   //初始化injections
initState(vm)    // 初始化props,methods,data,computed,watch
initProvide(vm) // 初始化 provide
callHook(vm, 'created')  // 调用生命周期钩子函数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>可以看到，除了调用初始化函数来进行相关数据的初始化之外，还在合适的时机调用了<code>callHook</code>函数来触发生命周期的钩子，关于<code>callHook</code>函数是如何触发生命周期的钩子会在下面介绍，我们先继续往下看：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (vm.$options.el) {
    vm.$mount(vm.$options.el)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在所有的初始化工作都完成以后，最后，会判断用户是否传入了<code>el</code>选项，如果传入了则调用<code>$mount</code>函数进入模板编译与挂载阶段，如果没有传入 el 选项，则不进入下一个生命周期阶段，需要用户手动执行<code>vm.$mount</code>方法才进入下一个生命周期阶段。</p> <p>以上就是<code>new Vue()</code>所做的所有事情，可以看到，整个初始化阶段都是在<code>new Vue()</code>里完成的，关于<code>new Vue()</code>里调用的一些初始化函数具体是如何进行初始化的，我们将在接下来的几篇文章里逐一介绍。下面我们先来看看上文中遗留的属性合并及<code>callHook</code>函数是如何触发生命周期的钩子的问题。</p> <p><strong>合并属性</strong></p> <p>在上文中，<code>_init</code>方法里首先会调用<code>mergeOptions</code>函数来进行属性合并，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$options = mergeOptions(
resolveConstructorOptions(vm.constructor),
options || {},
vm
)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>它实际上就是把 <code>resolveConstructorOptions(vm.constructor)</code> 的返回值和 <code>options</code> 做合并，返回<code>vm.constructor.options</code>，相当于<code>Vue.options</code>，那么这个<code>Vue.options</code>又是什么呢，其实在<code>initGlobalAPI(Vue)</code>的时候定义了这个值，代码在<code>src/core/global-api/index.js</code>中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function initGlobalAPI (Vue: GlobalAPI) {
// ...
Vue.options = Object.create(null)
ASSET_TYPES.forEach(type =&gt; {
Vue.options[type + 's'] = Object.create(null)
})

extend(Vue.options.components, builtInComponents)
// ...
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>首先通过<code>Vue.options = Object.create(null)</code>创建一个空对象，然后遍历<code>ASSET_TYPES</code>，<code>ASSET_TYPES</code>的定义在<code>src/shared/contstants.js</code>中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export const ASSET_TYPES = [
'component',
'directive',
'filter'
]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上面遍历<code>ASSET_TYPES</code>后代码相当于：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.options.components = {}
Vue.options.directives = {}
Vue.options.filters = {}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>最后通过<code>extend(Vue.options.components,builtInCompontents)</code>把一些内置组件扩展到<code>Vue.options.components</code>上，<code>Vue</code>的内置组件目前有<code>&lt;keep-alive&gt;</code>、<code>&lt;transition&gt;</code>和<code>&lt;transition-group&gt;</code>组件，这也就是为什么我们在其它组件中使用这些组件不需要注册的原因。</p> <p><code>mergeOptions</code>这个函数，它的定义在<code>src/core/util/options.js</code>中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  export function mergeOptions (
  parent: Object,
  child: Object,
  vm?: Component
  ): Object {
  if (process.env.NODE_ENV !== 'production') {
  checkComponents(child)
  }

    if (typeof child === 'function') {
    child = child.options
    }

normalizeProps(child, vm)
normalizeInject(child, vm)
normalizeDirectives(child)

// Apply extends and mixins on the child options,
// but only if it is a raw options object that isn't
// the result of another mergeOptions call.
// Only merged options has the \_base property.
if (!child.\_base) {
if (child.extends) {
parent = mergeOptions(parent, child.extends, vm)
}
if (child.mixins) {
for (let i = 0, l = child.mixins.length; i &lt; l; i++) {
parent = mergeOptions(parent, child.mixins[i], vm)
}
}
}

const options = {}
let key
for (key in parent) {
mergeField(key)
}
for (key in child) {
if (!hasOwn(parent, key)) {
mergeField(key)
}
}
function mergeField (key) {
const strat = strats[key] || defaultStrat
options[key] = strat(parent[key], child[key], vm, key)
}
return options
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><p>可以看出，<code>mergeOptions</code>函数的主要功能是把<code>parent</code>和<code>child</code>这两个对象根据一些合并策略，合并成一个新对象并返回。首先递归把<code>extends</code>和<code>mixins</code>合并到<code>parent</code>上</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> const extendsFrom = child.extends
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm)
  }
  if (child.mixins) {
    for (let i = 0, l = child.mixins.length; i &lt; l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm)
    }
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>然后创建一个空对象<code>options</code>，遍历<code>parent</code>，把<code>parent</code>中的每一项通过调用<code>mergeField</code>函数合并到空对象<code>options</code>里</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const options = {}
let key
for (key in parent) {
    mergeField(key)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接着再遍历<code>child</code>，把存在于<code>child</code>里但又不在<code>parent</code>中的属性继续调用<code>mergeField</code>函数合并到空对象<code>options</code>里。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (key in child) {
    if (!hasOwn(parent, key)) {
        mergeField(key)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>options</code>就是最终合并后得到的结果，将其返回。</p> <p>值得一提的是<code>mergeField</code>函数，它不是简单的把属性从一个对象里复制到另外一个对象里，而是根据被合并的不同的选项有着不同的合并策略。</p> <p>生命周期钩子函数的合并策略如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function mergeHook(parentVal,childVal){
    return childVal? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal
}

LIFECYCLE_HOOKS.forEach(hook =&gt; {
    strats[hook] = mergeHook
})

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这其中的<code>LIFECYCLE_HOOKS</code>的定义在<code>src/shared/constants.js</code>中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export const LIFECYCLE_HOOKS = [
'beforeCreate',
'created',
'beforeMount',
'mounted',
'beforeUpdate',
'updated',
'beforeDestroy',
'destroyed',
'activated',
'deactivated',
'errorCaptured'
]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这里定义了所有钩子函数名称，所以对于钩子函数的合并策略都是<code>mergeHook</code>函数。<code>mergeHook</code>函数的实现了一个多层嵌套的三元运算符，如果嵌套太不好理解的话我们可以将其展开，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function mergeHook (parentVal,childVal):  {
 if (childVal) {
   if (parentVal) {
     return parentVal.concat(childVal)
   } else {
     if (Array.isArray(childVal)) {
       return childVal
     } else {
       return [childVal]
     }
   }
 } else {
   return parentVal
 }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>它的合并策略是这样子的：如果<code>childVal</code>不存在，就返回<code>parentVal</code>；否则再判断是否存在<code>parentVal</code>，如果存在就把<code>childVal</code> 添加到 <code>parentVal</code> 后返回新数组；否则返回 <code>childVal</code> 的数组。所以回到 <code>mergeOptions</code> 函数，一旦 <code>parent</code>和 <code>child</code> 都定义了相同的钩子函数，那么它们会把 2 个钩子函数合并成一个数组。</p> <p><strong>callHook 函数如何触发钩子函数</strong></p> <p>关于<code>callHook</code>函数如何触发钩子函数的问题，我们只需看一下该函数的实现源码即可，该函数的源码位于<code>src/core/instance/lifecycle.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function callHook(vm,hook){
const handlers = vm.\$options[hook]
if(handlers){
for(let i = 0,j = handlers.length;i&lt;j;i++){
try{
hanlders[i].call(vm)
}catch(e){
handleError(e,vm,`${hook} hook`)
}
}
}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>可以看到，<code>callHook</code>函数逻辑非常简单。首先从实例的<code>$options</code>中获取到需要触发的钩子名称所对应的钩子函数数组<code>handlers</code>，每个生命周期钩子名称都对应一个钩子函数数组。然后遍历该数组，将数组中的每个钩子函数都执行一遍。</p> <p><strong>总结</strong></p> <p>首先，分析了<code>new Vue()</code>时其内部都干了些什么。其主要逻辑就是：合并配置，调用一些初始化函数，触发生命周期钩子函数，调用<code>$mount</code>开启下一个阶段。</p> <p>接着，就合并属性进行了详细介绍，知道了对于不同的选项有着不同的合并策略，并挑出钩子函数的合并特事特办进行了分析。</p> <p>最后，分析了<code>callHook</code>函数的源码，知道了<code>callHook</code>函数如何触发钩子函数的。</p> <p><strong>initLifecycle 函数分析</strong></p> <p><code>initLifecycle</code>函数的定义的位于源码的<code>src/core/instance/lifecycle.js</code>中，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function initLifecycle (vm: Component) {
const options = vm.$options

// locate first non-abstract parent
let parent = options.parent
if (parent &amp;&amp; !options.abstract) {
while (parent.$options.abstract &amp;&amp; parent.$parent) {
parent = parent.$parent
    }
    parent.$children.push(vm)
}

vm.$parent = parent
  vm.$root = parent ? parent.\$root : vm

vm.$children = []
  vm.$refs = {}

vm._watcher = null
vm._inactive = null
vm._directInactive = false
vm._isMounted = false
vm._isDestroyed = false
vm._isBeingDestroyed = false
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p><code>initLifecycle</code>函数主要是给<code>Vue</code>实例上挂载了一 hxxf 属性并设置了默认值，值得一提的是挂载<code>$parent</code>属性和<code>$root</code>属性。</p> <p>首先给实例上挂载<code>$parent</code>属性，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let parent = options.parent
if (parent &amp;&amp; !options.abstract) {
  while (parent.$options.abstract &amp;&amp; parent.$parent) {
    parent = parent.$parent
  }
  parent.$children.push(vm)
}

vm.$parent = parent
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如果当前组件不是抽象组件并且存在父级，那么就通过<code>while</code>循环来向上循环，如果当前组件的父级是抽象组件并且也存在父级，那那就继续向上查找当前组件父级的父级，直到找到第一个不是抽象类型的父级时，将其赋值<code>vm.$parent</code>，同时把该实例自身添加进找到的父级的<code>$children</code>属性中。这样就确保了在子组件的<code>$parent</code>属性上能访问到父组件实例，在父组件的<code>$children</code>属性上也能访问子组件的实例。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$root = parent ? parent.$root : vm
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>实例的<code>$root</code>属性表示当前实例的根实例，挂载该属性时，首先会判断如果当前实例存在父级，那么当前实例的根实例<code>$root</code>属性就是其父级的根实例<code>$root</code>属性，如果不存在，那么根实例<code>$root</code>属性就是它自己。这很好理解，举个例子：假如有一个人，他如果有父亲，那么他父亲的祖先肯定也是他的祖先，同理，他的儿子的祖先也肯定是他的祖先，我们不需要真正的一层一层的向上递归查找到他祖先本人，只需要知道他父亲的祖先是谁然后告诉他即可。如果他没有父亲，那说明他自己就是祖先，那么他后面的儿子、孙子的<code>$root</code>属性就是他自己了。</p> <p>这就是一个自上到下将根实例的<code>$root</code>属性依次传递给每一个子实例的过程。</p> <p>最后，再初始化了一些其它属性，因为都是简单的赋初始值，这里就不再一一介绍，等后面内容涉及到的时候再介绍。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$children = []
vm.$refs = {}

vm._watcher = null
vm._inactive = null
vm._directInactive = false
vm._isMounted = false
vm._isDestroyed = false
vm._isBeingDestroyed = false
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>总结</strong></p> <p><code>initLifecycle</code>函数，就是给实例初始化了一些属性，包括以<code>$</code>开头的供用户使用的外部属性，也包括以<code>_</code>开头的供内部使用的内部属性。</p> <p><strong>解析事件</strong></p> <p>在<code>Vue</code>中，当我们在父组件中使用子组件时可以给子组件上注册一些事件，这些事件包括使用<code>v-on</code>或<code>@</code>注册的自定义事件，也包括注册的浏览器原生事件，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;child @select=&quot;selectHandler&quot; @click.native=&quot;clickHandler&quot;&gt;&lt;/child&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>上面代码，我们先从解析事件开始说起，当遇到开始标签的时候，除了会解析开始标签，还会调用<code>processAttrs</code>方法解析标签中的属性，<code>processAttrs</code>方法位于源码的<code>src/compiler/parser/index.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export const onRE = /^@|^v-on:/
export const dirRE = /^v-|^@|^:/

function processAttrs (el) {
  const list = el.attrsList
  let i, l, name, value, modifiers
  for (i = 0, l = list.length; i &lt; l; i++) {
    name  = list[i].name
    value = list[i].value
    if (dirRE.test(name)) {
      // 解析修饰符
      modifiers = parseModifiers(name)
      if (modifiers) {
        name = name.replace(modifierRE, '')
      }
      if (onRE.test(name)) { // v-on
        name = name.replace(onRE, '')
        addHandler(el, name, value, modifiers, false, warn)
      }
    }
  }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>在对标签属性进行解析时，判断如果属性是指令，首先通过<code>parseModifiers</code>解析出属性的修饰符，然后判断如果是事件的指令，则执行<code>addHandler(el, name, value, modifiers, false, warn)</code>方法，该方法在<code>src/compiler/helpers.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function addHandler (el,name,value,modifiers) {
  modifiers = modifiers || emptyObject

  // check capture modifier 判断是否有capture修饰符
  if (modifiers.capture) {
    delete modifiers.capture
    name = '!' + name // 给事件名前加'!'用以标记capture修饰符
  }
  // 判断是否有once修饰符
  if (modifiers.once) {
    delete modifiers.once
    name = '~' + name // 给事件名前加'~'用以标记once修饰符
  }
  // 判断是否有passive修饰符
  if (modifiers.passive) {
    delete modifiers.passive
    name = '&amp;' + name // 给事件名前加'&amp;'用以标记passive修饰符
  }

  let events
  if (modifiers.native) {
    delete modifiers.native
    events = el.nativeEvents || (el.nativeEvents = {})
  } else {
    events = el.events || (el.events = {})
  }

  const newHandler: any = {
    value: value.trim()
  }
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers
  }

  const handlers = events[name]
  if (Array.isArray(handlers)) {
    handlers.push(newHandler)
  } else if (handlers) {
    events[name] = [handlers, newHandler]
  } else {
    events[name] = newHandler
  }

  el.plain = false
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><p>在<code>addHandler</code>函数里做了 3 件事件，首先根据<code>modifier</code>修饰符对事件名<code>name</code>做处理，接着根据<code>modifier.native</code>判断事件是一件浏览器原生事件还是自定义事件，分别对应<code>el.nativeEvents</code>和<code>el.events</code>，最后按照<code>name</code>对事件做归类，并把回调函数的字符串保留到对应的事件中。</p> <p>父组件的<code>child</code> 节点生成的 <code>el.events</code> 和 <code>el.nativeEvents</code> 如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>el.events = {
  select: {
    value: 'selectHandler'
  }
}

el.nativeEvents = {
  click: {
    value: 'clickHandler'
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>然后在模板编译的代码生成阶段，会在<code>genData</code>函数中根据<code>AST</code>元素节点上的<code>events</code>和<code>naitveEvents</code>生成<code>_c(tagName,data,children)</code>函数中所需要的<code>data</code>数据，它的定义在 <code>src/compiler/codegen/index.js</code> 中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function genData (el state) {
  let data = '{'
  // ...
  if (el.events) {
    data += `${genHandlers(el.events, false,state.warn)},`
  }
  if (el.nativeEvents) {
    data += `${genHandlers(el.nativeEvents, true, state.warn)},`
  }
  // ...
  return data
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>生成的<code>data</code>数据如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
  // ...
  on: {&quot;select&quot;: selectHandler},
  nativeOn: {&quot;click&quot;: function($event) {
      return clickHandler($event)
    }
  }
  // ...
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>最开始的模板中标签上注册的事件最终会被解析成用于创建元素型<code>VNode</code>的<code>_c(tagName,data,children)</code>函数中<code>data</code>数据中的两个对象，自定义事件对象<code>on</code>，浏览器原生事件<code>nativeOn</code>。</p> <p>模板编译的最终目的是创建<code>render</code>函数供挂载的时候调用生成虚拟<code>DOM</code>，那么在挂载阶段，如果被挂载的节点是一个组件节点，则通过<code>createComponent</code>函数创建一个组件<code>vnode</code>，该函数位于源码的 <code>src/core/vdom/create-component.js</code> 中， 如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function createComponent (
  Ctor: Class&lt;Component&gt; | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array&lt;VNode&gt;,
  tag?: string
): VNode | Array&lt;VNode&gt; | void {
  // ...
  const listeners = data.on

  data.on = data.nativeOn

  // ...
  const name = Ctor.options.name || tag
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  )

  return vnode
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>把自定义事件<code>data.on</code>赋值给了<code>listeners</code>，把浏览器原生事件<code>data.nativeOn</code>赋值给了<code>data.on</code>，这说明所有的原生浏览器事件处理是在当前父组件环境中处理的。而对于自定义事件，会把<code>listeners</code> 作为<code>vnode</code> 的 <code>componentOptions</code> 传入，放在子组件初始化阶段中处理， 在子组件的初始化的时候， 拿到了父组件传入的<code>listeners</code>，然后在执行 <code>initEvents</code> 的过程中，会处理这个 <code>listeners</code>。</p> <p>父组件给子组件的注册事件中，把自定义事件传给子组件，在子组件实例化的时候进行初始化；而</p> <p>换句话说：实例初始化阶段调用的初始化事件函数 initEvents 实际上初始化的是父组件在模板中使用<code>v-on</code> 或<code>@</code>注册的监听子组件内触发的事件</p> <p><strong>initEvents 函数分析</strong></p> <p>了解了以上过程之后，开始分析<code>initEvents</code>函数，该函数位于源码的<code>src/instance/events.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initEvents (vm: Component) {
    vm._events = Object.create(null)
    vm._hasHookEvent = false
    const listeners = vm.$options._parentListeners
    if (listeners) {
        updateComponentListeners(vm, listeners)
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>initEvents</code>函数首先在<code>vm</code>上新增<code>_events</code>属性并将其赋值为空对象，用来存储事件。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm._events = Object.create(null)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着，获取父组件注册的事件赋给<code>listeners</code>，如果<code>listeners</code>不为空，则调用<code>updateComponentListeners</code>函数，将父组件向子组件注册的事件到子组件的实例中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const listeners = vm.$options._parentListeners
if (listeners) {
  updateComponentListeners(vm, listeners)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这个<code>updateComponentListeners</code>函数是什么呢？该函数定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function updateComponentListeners (
vm: Component,
listeners: Object,
oldListeners: ?Object
) {
target = vm
updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler, vm)
target = undefined
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>可以看到，<code>updateComponentListeners</code>其实也没有干什么，只是调用了<code>updateListeners</code>函数并把<code>listeners</code>以及<code>add</code>和<code>remove</code>这两个函数传入，<code>updateListeners</code>函数位于源码的<code>src/vdom/helpers/update-listeners.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function updateListeners (
  on: Object,
  oldOn: Object,
  add: Function,
  remove: Function,
  vm: Component
) {
  let name, def, cur, old, event
  for (name in on) {
    def = cur = on[name]
    old = oldOn[name]
    event = normalizeEvent(name)
    if (isUndef(cur)) {
      process.env.NODE_ENV !== 'production' &amp;&amp; warn(
        `Invalid handler for event &quot;${event.name}&quot;: got ` + String(cur),
        vm
      )
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur)
      }
      add(event.name, cur, event.once, event.capture, event.passive, event.params)
    } else if (cur !== old) {
      old.fns = cur
      on[name] = old
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name)
      remove(event.name, oldOn[name], event.capture)
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>该函数的作用是对比<code>listeners</code> 和 <code>oldListeners</code>的不同，并调用参数中提供的<code>add</code> 和<code>remove</code>进行相应的注册事件和卸载事件。其思想是：如果<code>listeners</code>对象中存在某个<code>key</code>（即事件名）而<code>oldListeners</code>中不存在，则说明这个事件是需要新增的；反之，如果<code>oldListeners</code>对象中存在某个<code>key</code>（即事件名）而<code>listeners</code>中不存在，则说明这个事件是需要从事件系统中卸载的；</p> <p>该函数接收 5 个参数，分别是<code>on</code>、<code>oldOn</code>、<code>add</code>、<code>remove</code>、<code>vm</code>，其中<code>on</code>对应<code>listeners</code>，<code>oldOn</code>对应<code>oldListeners</code>。</p> <p>首先对<code>on</code>进行遍历，获得每一个事件名，然后调用<code>normalizeEvent</code>函数处理，处理完事件名后，判断事件就把值是否存在，如果不存在则抛出警告，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (name in on) {
  def = cur = on[name]
  old = oldOn[name]
  event = normalizeEvent(name)
  if (isUndef(cur)) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      `Invalid handler for event &quot;${event.name}&quot;: got ` + String(cur),
      vm
    )
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果存在，则继续判断该事件名在<code>oldOn</code>中是否存在，如果不存在，则调用<code>add</code>注册事件，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (isUndef(old)) {
  if (isUndef(cur.fns)) {
    cur = on[name] = createFnInvoker(cur)
  }
  add(event.name, cur, event.once, event.capture, event.passive, event.params)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这里定义了<code>createFnInvoker</code>方法并返回<code>invoker</code>函数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function createFnInvoker (fns) {
  function invoker () {
    const fns = invoker.fns
    if (Array.isArray(fns)) {
      const cloned = fns.slice()
      for (let i = 0; i &lt; cloned.length; i++) {
        cloned[i].apply(null, arguments)
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns
  return invoker
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>由于一个事件可能会对应多个回调函数，所以这里做了数组的判断，</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (cur !== old) {
  old.fns = cur
  on[name] = old
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>最后遍历<code>oldOn</code>，获得每一个事件名，判断如果事件名在<code>on</code>中不存在，则表示该事件是需要从事件系统中卸载事件，则调用<code>remove</code>方法卸载该事件。</p> <p><code>updateListeners</code>函数遗留了一个<code>normalizeEvent</code>函数是干什么用的？我们在解析事件的时候，当事件上有修饰符的时候，我们会根据不同的修饰符给事件名前面添加不同的符号以作标识，其实这个<code>normalizeEvent</code>函数就是个反向操作，根据事件名前面的不同标识反向解析出该事件所带的何种修饰符，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const normalizeEvent = cached((name: string): {
  name: string,
  once: boolean,
  capture: boolean,
  passive: boolean,
  handler?: Function,
  params?: Array&lt;any&gt;
} =&gt; {
  const passive = name.charAt(0) === '&amp;'
  name = passive ? name.slice(1) : name
  const once = name.charAt(0) === '~'
  name = once ? name.slice(1) : name
  const capture = name.charAt(0) === '!'
  name = capture ? name.slice(1) : name
  return {
    name,
    once,
    capture,
    passive
  }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>判断事件名的第一个字符是何种标识进而判断出事件带有何种修饰符，最终将真实事件名及所带的修饰符返回。</p> <p><strong>总结</strong></p> <p>首先从模板编译时对组件标签上的事件解析入手分析，父组件既可以给既可以给子组件上绑定自定义事件，也可以绑定浏览器原生事件。这两种事件有着不同的处理时机，浏览器原生事件是由父组件处理，而自定义事件是在子组件初始化时候由父组件父给子组件，再由子组件注册到实例的事件系统中。</p> <p>初始化事件函数<code>initEvents</code>实际上初始化的是父组件在模板中使用<code>v-on</code>或<code>@</code>注册的监听子组件内触发的事件。</p> <p>最后分析了<code>initEvents</code>函数的具体实现过程，该函数内部首先在实例上新增了<code>_events</code>属性并将其赋值为空对象，用来存储事件。接着通过调用<code>updateComponentListeners</code>函数，将父组件向子组件注册的事件注册到子组件实例中的<code>_events</code>对象里。</p> <p><strong>initInjections 函数分析</strong></p> <p>从函数名字上来看，该函数是用来初始化实例中的<code>inject</code>选项的。说到<code>inject</code>选项，那必然离不开<code>provide</code>选项，这两个选项都是成对出现的，它们的作用是：鸡毛一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间始终生效。</p> <p><code>provide</code>选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES 2015 Symbols 作为 key，但是只在原生支持<code>Symbol</code>和<code>Reflect.ownKeys</code>的环境下可工作。</p> <p><code>inject</code>选项应该是：</p> <ul><li>一个字符串数组或</li> <li>一个对象，对象的 key 是本地的绑定名，value 是：
<ul><li>在可用的注入内容中搜索用的 key，或</li> <li>一个对象，该对象的：
<ul><li><code>from</code>属性是在可用的注入</li> <li><code>default</code>属性是降级情况下使用的 value</li></ul></li></ul></li></ul> <p>官方文档使用示例，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/ 父级组件提供 'foo'
var Parent = {
  provide: {
    foo: 'bar'
  },
  // ...
}

// 子组件注入 'foo'
var Child = {
  inject: ['foo'],
  created () {
    console.log(this.foo) // =&gt; &quot;bar&quot;
  }
  // ...
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>利用 ES2015 Symbols、函数<code>provide</code>和对象<code>inject</code>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const s = Symbol()

const Provider = {
  provide () {
    return {
      [s]: 'foo'
    }
  }
}

const Child = {
  inject: { s },
  // ...
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>使用一个注入的值作为一个属性的默认值：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const Child = {
  inject: ['foo'],
  props: {
    bar: {
      default () {
        return this.foo
      }
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>使用一个注入的值作为数据入口：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const Child = {
  inject: ['foo'],
  data () {
    return {
      bar: this.foo
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>在 2.5.0+ 的注入可以通过设置默认值使其变成可选项：</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>const Child = {
  inject: {
    foo: { default: 'foo' }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果它需要从一个不同名字的属性注入，则使用 from 来表示其源属性：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const Child = {
  inject: {
    foo: {
      from: 'bar',
      default: 'foo'
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>与 prop 的默认值类似，你需要对非原始值使用一个工厂方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const Child = {
  inject: {
    foo: {
      from: 'bar',
      default: () =&gt; [1, 2, 3]
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>父组件可以使用<code>provide</code>选项给自己的下游子孙组件内注入一些数据，在下游子孙组件中可以使用<code>inject</code>选项来接收这些数据以便为自己所用。</p> <p>需要注意：<code>provide</code> 和 <code>inject</code> 选项绑定的数据不是响应式的。</p> <p><strong>initInjections 函数分析</strong></p> <p><code>provide</code>选项注入的值作为数据入口，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const Child = {
  inject: ['foo'],
  data () {
    return {
      bar: this.foo
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>数据就是我们通常所写<code>data</code>、<code>props</code>、<code>watch</code>、<code>computed</code>及<code>method</code>，所以<code>inject</code>选项接收到注入的值有可能被以上这些数据所使用到，所以在初始化完<code>inject</code>后需要先初始化这些数据，然后才能再初始化<code>provide</code>，所以在调用<code>initInjections</code>函数对<code>inject</code>初始化完之后需要先调用<code>initState</code>函数对数据进行初始化，最后再调用<code>initProvide</code>函数对<code>provide</code>进行初始化。</p> <p><code>initInjections</code>函数的具体原理，该函数定义在位于源码的<code>src/core/instance/inject.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function initInjections (vm: Component) {
    const result = resolveInject(vm.\$options.inject, vm)
    if (result) {
        toggleObserving(false)
        Object.keys(result).forEach(key =&gt; {
            /\* istanbul ignore else \*/
            if (process.env.NODE_ENV !== 'production') {
                defineReactive(vm, key, result[key], () =&gt; {
                    warn(
                    `Avoid mutating an injected value directly since the changes will be` +
                    `overwritten whenever the provided component re-renders.` +
                    `injection being mutated: &quot;${key}&quot;`,
                    vm
                    )
                })
            } else {
            defineReactive(vm, key, result[key])
            }
        })
        toggleObserving(true)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><code>initInjections</code>函数首先调用<code>resolveInject</code>把<code>inject</code>选项中的数据转化成键值对的形式赋给<code>result</code>，<code>result</code>样子如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 父级组件提供 'foo'
var Parent = {
  provide: {
    foo: 'bar'
  }
}

// 子组件注入 'foo'
var Child = {
  inject: ['foo'],
}

// result
result = {
    'foo':'bar'
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>然后遍历<code>result</code>中的每一对键值，调用<code>defineReactive</code>函数将其添加当前实例上，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (result) {
    toggleObserving(false)
    Object.keys(result).forEach(key =&gt; {
        defineReactive(vm, key, result[key])
    }
    toggleObserving(true)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在把<code>result</code>中的键值添加到当前实例上之前，会先调用<code>toggleObserving(false)</code>，而这个函数内部是把<code>shouldObserve = false</code>，这是为了告诉<code>defineReactive</code>函数仅仅是把键值添加到当前实例上而不需要将其转换成响应式。</p> <p><strong>resolveInject 函数分析</strong></p> <p><code>inject</code>选项中的每一个数据<code>key</code> 都是由其上游父级组件提供的，所以我们应该把每一个数据<code>key</code>从当前组件起，不断的向上游父级组件中查找该数据<code>key</code>对应的值，直到找到为止。如果在上游所有父级组件中没找到，那么就看在<code>inject</code>选项是否为该数据<code>key</code>设置了默认值，如果设置了就使用默认值，如果没有设置，则抛出异常。</p> <p><code>resolveInject</code>函数的源码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function resolveInject (inject: any, vm: Component): ?Object {
  if (inject) {
    const result = Object.create(null)
    const keys =  Object.keys(inject)

    for (let i = 0; i &lt; keys.length; i++) {
      const key = keys[i]
      const provideKey = inject[key].from
      let source = vm
      while (source) {
        if (source._provided &amp;&amp; hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey]
          break
        }
        source = source.$parent
      }
      if (!source) {
        if ('default' in inject[key]) {
          const provideDefault = inject[key].default
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault
        } else if (process.env.NODE_ENV !== 'production') {
          warn(`Injection &quot;${key}&quot; not found`, vm)
        }
      }
    }
    return result
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>在分析函数源码之前，我们对照着官网给出的示例，这样会比较好理解一些。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var Parent = {
  provide: {
    foo: 'bar'
  },
  // ...
}
const Child = {
  inject: {
    foo: {
      from: 'bar',
      default: () =&gt; [1, 2, 3]
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>首先创建一个空对象<code>result</code>，用来存储<code>inject</code>选项中的数据<code>key</code>及其对应的值，作为最后的返回结果。</p> <p>然后获取当前<code>inject</code>选项中的所有<code>key</code>，然后遍历每一个<code>key</code>，拿到每一个<code>key</code>的<code>from</code>属性记作<code>provideKey</code>，<code>provideKey</code>就是上游父组件提供的源属性，然后开启一个<code>while</code>循环，从当前组件起，不断的向上游父组件的<code>_provided</code>属性中查找，直到查找到源属性的对应的值，将其存入<code>result</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (let i = 0; i &lt; keys.length; i++) {
  const key = keys[i]
  const provideKey = inject[key].from
  let source = vm
  while (source) {
    if (source._provided &amp;&amp; hasOwn(source._provided, provideKey)) {
      result[key] = source._provided[provideKey]
      break
    }
    source = source.$parent
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如果没有找到，那么就看<code>inject</code>选项中当前的数据<code>key</code>是否设置了默认值，即是否有<code>default</code>属性，如果有的话，则拿到这个默认值，默认值可以为一个工厂函数，所以当默认值是函数的时候，就去该函数的时候，就去该函数的返回值，否则就取默认值本身。如果没有设置默认值，则抛出异常。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!source) {
  if ('default' in inject[key]) {
    const provideDefault = inject[key].default
    result[key] = typeof provideDefault === 'function'
        ? provideDefault.call(vm)
    : provideDefault
  } else if (process.env.NODE_ENV !== 'production') {
    warn(`Injection &quot;${key}&quot; not found`, vm)
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>最后将<code>result</code>返回。</p> <p>其实在初始化阶段<code>_init</code>函数在合并属性的时候还调用了一个将<code>inject</code>选项数据规范化的函数<code>normalizeInject</code>，该函数的作用是将以下这三种写法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 写法一
var Child = {
  inject: ['foo']
}

// 写法二
const Child = {
  inject: {
    foo: { default: 'xxx' }
  }
}

// 写法三
const Child = {
  inject: {
    foo
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>统统转换成以下规范化格式：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const Child = {
  inject: {
    foo: {
      from: 'foo',
      default: 'xxx'  //如果有默认的值就有default属性
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>不管用户使用了何种写法，统统将其转化成一种便于集中处理的写法。</p> <p>该函数的定义位于源码的<code>src/core/util/options.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function normalizeInject (options: Object, vm: ?Component) {
  const inject = options.inject
  if (!inject) return
  const normalized = options.inject = {}
  if (Array.isArray(inject)) {
    for (let i = 0; i &lt; inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] }
    }
  } else if (isPlainObject(inject)) {
    for (const key in inject) {
      const val = inject[key]
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val }
    }
  } else if (process.env.NODE_ENV !== 'production') {
    warn(
      `Invalid value for option &quot;inject&quot;: expected an Array or an Object, ` +
      `but got ${toRawType(inject)}.`,
      vm
    )
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>该函数的逻辑并不复杂，如果用户的<code>inject</code>选项传入的是一个字符串数组，那么就遍历该数组，把数组的每一项变成</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>inject:{
  foo:{
    from:'foo'
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果给<code>inject</code>选项传入的是一个对象，那就遍历对象中的每一个<code>key</code>，给写法二形式的<code>key</code>对应的值扩展<code>{from:key}</code>，变成：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>inject:{
  foo:{
    from: 'foo',
    default: 'xxx'
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>将写法三形式的<code>key</code>对应的值变成：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>inject:{
  foo:{
    from: 'foo'
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>总结</strong></p> <p>首先我们先根据官方文档回顾了该选项的作用及使用方法。</p> <p>接着，我们分析了<code>initInjections</code>函数的内部实现原理，分析了是根据<code>inject</code>选项中的数据<code>key</code>是如何自底向上查找上游父级组件所注入的对应的值。</p> <p><strong>initState 函数分析</strong></p> <p>这个函数是用来初始化实例状态的，主要包括<code>props</code>、<code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code>，我们把这些选项称为实例的状态选项。也就是说，<code>initState</code>函数就是用来初始化这些状态的。</p> <p>首先我们先来分析<code>initState</code>函数，该函数的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
export function initState (vm: Component) {
    vm._watchers = []
    const opts = vm.$options
    if (opts.props) initProps(vm, opts.props)
    if (opts.methods) initMethods(vm, opts.methods)
    if (opts.data) {
        initData(vm)
    } else {
        observe(vm._data = {}, true)
    }
    if (opts.computed) initComputed(vm, opts.computed)
    if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch)
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>首先，给实例上新增了一个属性<code>_watchers</code>，用来存储当前实例中所有的<code>watcher</code>实例，无论是使用<code>vm.$watch</code>注册的<code>watcher</code>实例还是使用<code>watch</code>选项注册的<code>watcher</code>实例，都会被保存到该属性中。</p> <p><code>Vue</code>中对数据变化的侦测是使用属性拦截的方式实现的，但是<code>Vue</code>并不是对所有数据使用属性拦截的方式侦测变化，这是因为数据越多，数据上所绑定的依赖就会多，从而造成依赖追踪的内存开销就会很大，所以从<code>Vue 2.0</code>版本起，<code>Vue</code>不再对所有数据都进行侦测，而是将侦测粒度提高到组件层面，对每个组件进行侦测，所以在每个组件上新增了<code>vm._watchers</code>属性，用来存放这个组件内用到的所有状态的依赖，当其中一个状态发生变化时，就会通知到组件，然后由组件内部使用虚拟<code>DOM</code>进行数据比对，从而降低内存开销，提高性能。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (opts.props) initProps(vm, opts.props)
if (opts.methods) initMethods(vm, opts.methods)
if (opts.data) {
    initData(vm)
} else {
    observe(vm._data = {}, true /* asRootData */)
}
if (opts.computed) initComputed(vm, opts.computed)
if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>先判断实例中是否有<code>props</code>选项，如果有，就调用<code>props</code>选项初始化函数<code>initProps</code>去初始<code>props</code>选项；</p> <p>再判断实例中是否有<code>methods</code>选项，如果有，就调用<code>methods</code>选项初始函数<code>initMethods</code>去初始化<code>methods</code>选项；</p> <p>接着再判断实例中是否有<code>data</code>选项，如果有，就调用<code>data</code>选项寝化函数<code>initData</code>去初始化<code>data</code>选项；如果没有，就把<code>data</code>当作空对象并将其转换成响应式；</p> <p>接着再判断实例中是否有<code>computed</code>选项，如果有，就调用<code>computed</code>选项初始化函数<code>initComputed</code>去初始化<code>computed</code>选项；</p> <p>最后判断实例中是否有<code>watch</code>选项，如果有，就调用<code>watch</code>选项初始化函数<code>initWatch</code>去初始化<code>watch</code>选项；</p> <p><code>iniState</code>函数的所有逻辑，其实你会发现，在函数内部初始人这 5 个选项的时候它的顺序是有意安排的，不是毫无章法的。如果你在开发中有注意到我们在<code>data</code>中可以使用<code>props</code>，在<code>watch</code>中可以观察<code>data</code>和<code>props</code>，之所以可以这样做，就是因为在初始化的时候遵循了这种顺序，先初始化<code>props</code>，接着初始化<code>data</code>，最后初始化<code>watch</code>。</p> <p><strong>初始化 props</strong></p> <p><code>props</code>选项通常是由当前组件的父级组件传入的，当父组件在调用子组件的时候，通常会把<code>props</code>属性值作为标签属性添加在子组件的标签上，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;Child prop1=&quot;xxx&quot; prop2=&quot;yyy&quot;&gt;&lt;/Child&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在模板编译的时候，当解析到组件标签时会将所有的标签属性都解析出来然后在子组件实例化的时候传给子组件。</p> <p>在子组件内部，通过<code>props</code>选项来接收父组件传来的数据，在接收的时候可以这样写：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 写法一
props: ['name']

// 写法二
props: {
    name: String, // [String, Number]
}

// 写法三
props: {
    name:{
		type: String
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><code>Vue</code>给用户提供了<code>props</code>选项写法非常自由，根据<code>Vue</code>的惯例，写法虽多但最终处理的时候肯定只处理一种写法，此时你肯定会想到，处理之前先对数据进行规范化，将所有写法都转化成一种写法。</p> <p><strong>规范化数据</strong></p> <p><code>props</code>数据规范化函数的定义位于源码的<code>src/core/util/options.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function normalizeProps (options: Object, vm: ?Component) {
  const props = options.props
  if (!props) return
  const res = {}
  let i, val, name
  if (Array.isArray(props)) {
    i = props.length
    while (i--) {
      val = props[i]
      if (typeof val === 'string') {
        name = camelize(val)
        res[name] = { type: null }
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.')
      }
    }
  } else if (isPlainObject(props)) {
    for (const key in props) {
      val = props[key]
      name = camelize(key)
      res[name] = isPlainObject(val)
        ? val
        : { type: val }
    }
  } else if (process.env.NODE_ENV !== 'production') {
    warn(
      `Invalid value for option &quot;props&quot;: expected an Array or an Object, ` +
      `but got ${toRawType(props)}.`,
      vm
    )
  }
  options.props = res
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>首先拿到实例中的<code>props</code>选项，如果不存在，则直接返回。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const props = options.props
if (!props) return
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果存在，则定义一个空对象<code>res</code>，用来存储最终的结果。接着判断如果<code>props</code>选项是一个数组（写法一），则遍历该数组中的每一项元素，如果该元素是字符串，那么先将该元素统一转化成驼峰式命名，然后将该元素作为<code>key</code>，将<code>{type:null}</code>作为<code>value</code>存入<code>res</code>中；如果不是字符串，则抛出异常，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (Array.isArray(props)) {
    i = props.length
    while (i--) {
        val = props[i]
        if (typeof val === 'string') {
            name = camelize(val)
            res[name] = { type: null }
        } else if (process.env.NODE_ENV !== 'production') {
            warn('props must be strings when using array syntax.')
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如果<code>props</code>选项不是数组那就判断是不是一个对象，如果是一个对象，那就是遍历对象中的每一对键值，拿到每一对键值后，先将键名统一转化成驼峰式命名，然后判断值是否还是一个对象，如果值是对象（写法三），那么就将该键值对存入<code>res</code>中；如果值不是对象（写法二），那么就将键名作为<code>key</code>，将<code>{type:null}</code>作为<code>value</code>存入<code>res</code>中。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (isPlainObject(props)) {
    for (const key in props) {
        val = props[key]
        name = camelize(key)
        res[name] = isPlainObject(val)
            ? val
        : { type: val }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如果<code>props</code>选项既不是数组也不是对象，那么如果在非生产环境下就抛出异常，最后将<code>res</code>作为规范化后的结果重新赋值给实例的<code>props</code>选项。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (process.env.NODE_ENV !== 'production') {
    warn(
        `Invalid value for option &quot;props&quot;: expected an Array or an Object, ` +
        `but got ${toRawType(props)}.`,
        vm
    )
}
options.props = res
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>无论是三种写法的哪一种，最终都会被转化成如下写法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>props: {
    name:{
        type: xxx
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>initProps 函数分析</strong></p> <p>将<code>props</code>选项规范化完成之后，接下来我们就可以真正的初始化<code>props</code>选项了，<code>initProps</code>函数的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function initProps (vm: Component, propsOptions: Object) {
    const propsData = vm.$options.propsData || {}
    const props = vm._props = {}
    const keys = vm.$options._propKeys = []
    const isRoot = !vm.$parent
    // root instance props should be converted
    if (!isRoot) {
        toggleObserving(false)
    }
for (const key in propsOptions) {
    keys.push(key)
    const value = validateProp(key, propsOptions, propsData, vm)
    if (process.env.NODE_ENV !== 'production') {
        const hyphenatedKey = hyphenate(key)
        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
            warn(`&quot;${hyphenatedKey}&quot; is a reserved attribute and cannot be used as component prop.`,vm)
        }
        defineReactive(props, key, value, () =&gt; {
            if (!isRoot &amp;&amp; !isUpdatingChildComponent) {
            warn(
                `Avoid mutating a prop directly since the value will be` +
                `overwritten whenever the parent component re-renders.` +
                `Instead, use a data or computed property based on the prop's` +
                `value. Prop being mutated: &quot;${key}&quot;`,
                vm
            )
        }
    })
    } else {
    defineReactive(props, key, value)
    }
    if (!(key in vm)) {
        proxy(vm, `_props`, key)
    }
}
    toggleObserving(true)
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>可以看到，该函数接收两个参数：当前<code>Vue</code>实例和当前实例规范化后的<code>props</code>选项。</p> <p>在函数内部首先定义了 4 个变量，分别是：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const propsData = vm.$options.propsData || {}
const props = vm._props = {}
const keys = vm.$options._propKeys = []
const isRoot = !vm.$parent
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>propsData：父组件传入的真实<code>props</code>数据。</li> <li>props：指向<code>vm._props</code>指针，所有设置到<code>props</code>变量中的变量中的属性都会保存到<code>vm._props</code>中。</li> <li>keys：指向<code>vm.$options._propKeys</code>的指针，缓存<code>props</code>对象中的<code>key</code>，将来更新<code>props</code>时只需遍历<code>vm.$options._propKeys</code>数组即可得到所有的<code>props</code>的<code>key</code>。</li> <li>isRoot：当前组件是否为根组件。</li></ul> <p>接着，判断当前组件是否为根组件，如果不是，那么不需要将<code>props</code>数组转换为响应式的，<code>toggleObserving(false)</code>用来控制是否将数据转换成响应式。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!isRoot) {
    toggleObserving(false)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>接着，遍历<code>props</code>选项拿到每一对键值，先将键名添加到<code>keys</code>中，然后调用<code>validateProp</code>函数校验父组件传入的<code>props</code>数据类型是否切尔西并获取到传入的值<code>value</code>，然后将键和值通过<code>defineReactive</code>函数添加到<code>props</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (const key in propsOptions) {
    keys.push(key)
    const value = validateProp(key, propsOptions, propsData, vm)
    if (process.env.NODE_ENV !== 'production') {
      const hyphenatedKey = hyphenate(key)
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          `&quot;${hyphenatedKey}&quot; is a reserved attribute and cannot be used as component prop.`,
          vm
        )
      }
      defineReactive(props, key, value, () =&gt; {
        if (vm.$parent &amp;&amp; !isUpdatingChildComponent) {
          warn(
            `Avoid mutating a prop directly since the value will be ` +
            `overwritten whenever the parent component re-renders. ` +
            `Instead, use a data or computed property based on the prop's ` +
            `value. Prop being mutated: &quot;${key}&quot;`,
            vm
          )
        }
      })
    } else {
      defineReactive(props, key, value)
    }
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>添加完之后再判断这个<code>key</code>在当前实例<code>vm</code>中是否存在，如果不存在，则调用<code>proxy</code>函数在<code>vm</code>上设置一个以<code>key</code>为属性的代码，当使用<code>vm[key]</code>访问数据时，其实访问的是<code>vm._props[key]</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!(key in vm)) {
    proxy(vm, `_props`, key)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>validateProp 函数分析</strong></p> <p><code>validateProp</code>函数的定义位于源码的<code>src/core/util/props.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function validateProp (key,propOptions,propsData,vm) {
  const prop = propOptions[key]
  const absent = !hasOwn(propsData, key)
  let value = propsData[key]
  // boolean casting
  const booleanIndex = getTypeIndex(Boolean, prop.type)
  if (booleanIndex &gt; -1) {
    if (absent &amp;&amp; !hasOwn(prop, 'default')) {
      value = false
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      const stringIndex = getTypeIndex(String, prop.type)
      if (stringIndex &lt; 0 || booleanIndex &lt; stringIndex) {
        value = true
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key)
    // since the default value is a fresh copy,
    // make sure to observe it.
    const prevShouldObserve = shouldObserve
    toggleObserving(true)
    observe(value)
    toggleObserving(prevShouldObserve)
  }
  if (process.env.NODE_ENV !== 'production') {
    assertProp(prop, key, value, vm, absent)
  }
  return value
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>该函数接收 4 个参数，分别是：</p> <ul><li><code>key</code>:遍历<code>propOptions</code>时拿到的每个属性名。</li> <li><code>propOptions</code>：当前实例规范化后的<code>props</code>选项。</li> <li><code>propsData</code>：父组件传入的真实的<code>props</code>数据。</li> <li><code>vm</code>：当前实例</li></ul> <p>在函数内部首先定义了 3 个变量，分别是：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const prop = propOptions[key]
const absent = !hasOwn(propsData, key)
let value = propsData[key]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>prop：当前<code>key</code>在<code>propOptions</code>中对应的值。</li> <li>absent：当前<code>key</code>是否在<code>propsData</code>中存在，即父组件是否传入了该属性。</li> <li>value：当前<code>key</code>在<code>propsData</code>中对应的值，即父组件对于该属性传入的真实值。</li></ul> <p>接着，判断<code>prop</code>的<code>type</code>属性是否是布尔类型（Boolean），<code>getTypeIndex</code>函数用于判断<code>prop</code>的<code>type</code>属性中是否存在某种类型，如果存在，则返回该类型在<code>type</code>属性中的索引（因为<code>type</code>属性可以是数组），如果不存在则返回 -1。</p> <p>如果是布尔类型的话，那么有两种边界情况需要单独处理：</p> <ol><li>如果<code>absent</code>为<code>true</code>，即父组件没有传入该<code>props</code>属性并且该属性也没有默认值的时候，将该属性值设置为<code>false</code>，如下：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (absent &amp;&amp; !hasOwn(prop, 'default')) {
    value = false
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="2"><li>如果父组件传入了该<code>prop</code>属性，那么需要满足以下几点：</li></ol> <ul><li>该属性值为空字符串串或者属性值与属性名相等；</li> <li><code>prop</code>和<code>type</code>属性中不存在<code>String</code>类型；</li> <li>如果<code>prop</code>的<code>type</code>属性中存在<code>String</code>类型，那么<code>Boolean</code>类型在<code>type</code>属性中的索引必须小于<code>String</code>类型的索引，即<code>Boolean</code>类型的优先级更高。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (value === '' || value === hyphenate(key)) {
    const stringIndex = getTypeIndex(String, prop.type)
    if (stringIndex &lt; 0 || booleanIndex &lt; stringIndex) {
        value = true
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>另外，在判断属性值与属性名相等的时候，是先将属性名由驼峰转换成用<code>-</code>连接的字符串，下面的这几种写法，子组件的<code>prop</code>都将被设置为<code>true</code>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;Child name&gt;&lt;/Child&gt;
&lt;Child name=&quot;name&quot;&gt;&lt;/Child&gt;
&lt;Child userName=&quot;user-name&quot;&gt;&lt;/Child&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果不是布尔类型，是其它类型的话，那就只需判断父组件是否传入该属性即可，如果没有传入，则该属性值为<code>undefined</code> ，此时调用<code>getPropDefaultValue</code>函数获取该属性的默认值，并将其转换成响应式，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key)
    // since the default value is a fresh copy,
    // make sure to observe it.
    const prevShouldObserve = shouldObserve
    toggleObserving(true)
    observe(value)
    toggleObserving(prevShouldObserve)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如果父组件传入了该属性并且也有对应的真实值，那么在非生产环境下会调用<code>assertProp</code>函数校验该属性值是否与要求的类型匹配。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (process.env.NODE_ENV !== 'production' ) {
    assertProp(prop, key, value, vm, absent)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>最后将父组件传入的该属性的真实值返回。</p> <p><strong>getPropDefaultValue 函数分析</strong></p> <p><code>getPropDefaultValue</code>函数的定义位于源码的<code>src/core/util/props.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function getPropDefaultValue (vm, prop, key){
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  const def = prop.default
  // warn against non-factory defaults for Object &amp; Array
  if (process.env.NODE_ENV !== 'production' &amp;&amp; isObject(def)) {
    warn(
      'Invalid default value for prop &quot;' + key + '&quot;: ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    )
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm &amp;&amp; vm.$options.propsData &amp;&amp;
    vm.$options.propsData[key] === undefined &amp;&amp;
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' &amp;&amp; getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>该函数接收三个参数，分别是：</p> <ul><li><code>vm</code>：当前实例；</li> <li><code>prop</code>：子组件<code>props</code>选项中的每个<code>key</code>对应的值；</li> <li><code>key</code>：子组件<code>props</code>选项中的每个<code>key</code>;</li></ul> <p>其作用是根据子组件<code>props</code>选项中的<code>key</code>获取其对应的默认值。</p> <p>首先判断<code>prop</code>中是否有<code>default</code>属性，如果没有，则表示没有默认值，直接返回，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!hasOwn(prop, 'default')) {
    return undefined
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果有则取出<code>default</code>属性，赋给变量<code>def</code>。接着判断在非生产环境下<code>def</code>是否一个对象，如果是，则抛出警告：对象或数组默认值必须从一个工厂函数获取。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const def = prop.default
// warn against non-factory defaults for Object &amp; Array
if (process.env.NODE_ENV !== 'production' &amp;&amp; isObject(def)) {
    warn(
        'Invalid default value for prop &quot;' + key + '&quot;: ' +
        'Props with type Object/Array must use a factory function ' +
        'to return the default value.',
        vm
    )
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>接着，再判断如果父组件没有传入该<code>props</code>属性，但是在<code>vm._props</code>中有该属性值，这说明<code>vm._props</code>中的该属性值就是默认值，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (vm &amp;&amp; vm.$options.propsData &amp;&amp;
    vm.$options.propsData[key] === undefined &amp;&amp;
    vm._props[key] !== undefined
   ) {
    return vm._props[key]
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>最后，判断<code>def</code>是否为函数并且<code>prop.type</code>不为<code>Function</code>，如果是的话表明<code>def</code>是一个返回对象或数组的工厂函数，那么将函数的返回值作为默认值返回；如果<code>def</code>不是函数，那么则将<code>def</code>作为默认值返回。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>return typeof def === 'function' &amp;&amp; getType(prop.type) !== 'Function'
    ? def.call(vm)
	: def
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>assertProp 函数分析</strong></p> <p><code>assertProp</code>函数的定义位于源码的<code>src/core/util/props.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function assertProp (prop,name,value,vm,absent) {
  if (prop.required &amp;&amp; absent) {
    warn(
      'Missing required prop: &quot;' + name + '&quot;',
      vm
    )
    return
  }
  if (value == null &amp;&amp; !prop.required) {
    return
  }
  let type = prop.type
  let valid = !type || type === true
  const expectedTypes = []
  if (type) {
    if (!Array.isArray(type)) {
      type = [type]
    }
    for (let i = 0; i &lt; type.length &amp;&amp; !valid; i++) {
      const assertedType = assertType(value, type[i])
      expectedTypes.push(assertedType.expectedType || '')
      valid = assertedType.valid
    }
  }
  if (!valid) {
    warn(
      `Invalid prop: type check failed for prop &quot;${name}&quot;.` +
      ` Expected ${expectedTypes.map(capitalize).join(', ')}` +
      `, got ${toRawType(value)}.`,
      vm
    )
    return
  }
  const validator = prop.validator
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop &quot;' + name + '&quot;.',
        vm
      )
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><p>该函数接收 5 个参数，分别是：</p> <ul><li><code>prop</code>:prop 选项;</li> <li><code>name</code>:props 中 prop 选项的 key;</li> <li><code>value</code>:父组件传入的 propsData 中 key 对应的真实数据；</li> <li><code>vm</code>:当前实例；</li> <li><code>absent</code>:当前 key 是否在 propsData 中存在，即父组件是否传入了该属性。</li></ul> <p>其作用是校验父组件传来的真实值是否与<code>prop</code>的<code>type</code>类型相匹配，如果不切尔西则在非生产环境下抛出警告。</p> <p>函数内部首先判断<code>prop</code>中如果设置了必须项（即<code>prop.required</code>为<code>true</code>）并且父组件又没有传入该属性，此时则抛出警告：提示该项必须。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (prop.required &amp;&amp; absent) {
    warn(
        'Missing required prop: &quot;' + name + '&quot;',
        vm
    )
    return
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>接着判断如果该项不是必填的并且该项的值<code>value</code>不存在，那么此时是合法的，直接返回，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (value == null &amp;&amp; !prop.required) {
    return
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>接下来定义了 3 个变量，分别是：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let type = prop.type
let valid = !type || type === true
const expectedTypes = []
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>type:<code>prop</code>中的<code>thpe</code>类型;</li> <li>valid:校验是否成功；</li> <li>expectedTypes:保存期望类型的数组，当校验失败抛出警告时，会提示用户该属性所期望的类型是什么；</li></ul> <p>通常情况下，<code>type</code>可以是一个原生构造函数，也可以是一个包含多种类型的数组，还可以不设置该属性。如果用户设置的是原生构造函数或数组，那么此时<code>vaild</code>默认为<code>false</code>（<code>!type</code>），如果用户没有设置该属性，表示不需要校验，那么此时<code>vaild</code>默认为<code>true</code>，即校验成功。</p> <p>另外，当<code>type</code>等于<code>true</code>时，即出现这样的写法：<code>props:{name:true}</code>，这说明<code>prop</code>一定会校验成功。所以当出现这种语法的时候，此时<code>type===true</code>，所以<code>vaild</code>默认为<code>true</code>。</p> <p>接下来开始校验类型，如果用户设置了<code>type</code>属性，则判断该属性是不是数组，如果不是，则统一转化为数组，方便后续处理，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (type) {
    if (!Array.isArray(type)) {
        type = [type]
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接下来遍历<code>type</code>数组，并调用<code>assertType</code>函数校验<code>value</code>。<code>assertType</code>函数校验后会返回一个对象，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    vaild:true,       // 表示是否校验成功
    expectedType：'Boolean'   // 表示被校验的类型
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>然后将被校验的类型添加到<code>expectedTypes</code>中，并将<code>valid</code>变量设置为<code>assertedType.valid</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (let i = 0; i &lt; type.length &amp;&amp; !valid; i++) {
    const assertedType = assertType(value, type[i])
    expectedTypes.push(assertedType.expectedType || '')
    valid = assertedType.valid
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>循环中的条件语句有这样一个条件：<code>!vaild</code>，即<code>type</code>数组中还要有一个校验成功，循环立即结束，表示校验通过。</p> <p>接下来，如果循环完毕后<code>vaild</code>为<code>false</code>，即表示校验未通过，则招聘警告。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!valid) {
    warn(
        `Invalid prop: type check failed for prop &quot;${name}&quot;.` +
        ` Expected ${expectedTypes.map(capitalize).join(', ')}` +
        `, got ${toRawType(value)}.`,
        vm
    )
    return
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>另外，<code>prop</code>选项还支持自定义校验函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>props:{
   // 自定义验证函数
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>所以还需要使用用户传入的自定义校验数据。首先获取到用户传入的校验函数，调用该函数并将待校验的数据传入，如果校验失败，则抛出警告。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const validator = prop.validator
if (validator) {
    if (!validator(value)) {
        warn(
            'Invalid prop: custom validator check failed for prop &quot;' + name + '&quot;.',
            vm
        )
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>初始化 methods</strong></p> <p>初始化<code>methods</code>相较而言就比较简单了，它的初始函数定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function initMethods (vm: Component, methods: Object) {
    const props = vm.$options.props
    for (const key in methods) {
        if (process.env.NODE_ENV !== 'production') {
            if (typeof methods[key] !== 'function') {
                warn(
                    `Method &quot;${key}&quot; has type &quot;${typeof methods[key]}&quot; in the component definition.` +
                    `Did you reference the function correctly?`,vm
                )
            }
            if (props &amp;&amp; hasOwn(props, key)) {
                warn(
                `Method &quot;${key}&quot; has already been defined as a prop.`,
                vm
                )
            }
            if ((key in vm) &amp;&amp; isReserved(key)) {
                warn(
                `Method &quot;${key}&quot; conflicts with an existing Vue instance method.` +
                `Avoid defining component methods that start with _ or $.`
                )
            }
    }
        vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>初始化<code>methods</code>干了三件事：判断<code>method</code>有没有？<code>method</code>的命名符不符合命名规范？如果<code>method</code>既有又符合规范那就把它挂载到<code>vm</code>实例上。</p> <p>首先，遍历<code>methods</code>选项中的每一个对象，在非生产环境下判断如果<code>methods</code>中某个方法只有<code>key</code>而没有<code>value</code>，即只有方法没有方法体时，抛出异常：提示用户方法未定义。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (methods[key] == null) {
    warn(
        `Method &quot;${key}&quot; has an undefined value in the component definition. ` +
        `Did you reference the function correctly?`,
        vm
    )
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>接着判断如果<code>methods</code>中某个方法名与<code>props</code>中某个属性名重复了，就抛出异常：提示用户方法名重复了。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (props &amp;&amp; hasOwn(props, key)) {
    warn(
        `Method &quot;${key}&quot; has already been defined as a prop.`,
        vm
    )
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>其中，<code>isReserved</code>函数是用来判断字符串是否以<code>_</code>或<code>$</code>开头。</p> <p>最后，如果上述判断都没问题，那就<code>method</code>绑定到实例<code>vm</code>上，这样，我们就可以通过<code>this.xxx</code>来访问<code>methods</code>选项中的<code>xxx</code>方法了，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm[key] = methods[key] == null ? noop : bind(methods[key], vm)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>初始化 data</strong></p> <p>初始化<code>data</code>也比较简单，它的初始化函数定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function initData (vm) {
    let data = vm.$options.data
    data = vm._data = typeof data === 'function'
        ? getData(data, vm)
    : data || {}
    if (!isPlainObject(data)) {
        data = {}
        process.env.NODE_ENV !== 'production' &amp;&amp; warn(
            'data functions should return an object:\n' +
            'https://vuejs.org/v2/guide/components.html##data-Must-Be-a-Function',
            vm
        )
    }
    // proxy data on instance
    const keys = Object.keys(data)
    const props = vm.$options.props
    const methods = vm.$options.methods
    let i = keys.length
    while (i--) {
        const key = keys[i]
        if (process.env.NODE_ENV !== 'production') {
            if (methods &amp;&amp; hasOwn(methods, key)) {
                warn(
                    `Method &quot;${key}&quot; has already been defined as a data property.`,
                    vm
                )
            }
        }
        if (props &amp;&amp; hasOwn(props, key)) {
            process.env.NODE_ENV !== 'production' &amp;&amp; warn(
                `The data property &quot;${key}&quot; is already declared as a prop. ` +
                `Use prop default value instead.`,
                vm
            )
        } else if (!isReserved(key)) {
            proxy(vm, `_data`, key)
        }
    }
    // observe data
    observe(data, true /* asRootData */)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p><code>initData</code>通过一系列条件判断用户传入的<code>data</code>选项是否合法，最后将<code>data</code>转换成响应式并绑定到实例<code>vm</code>上。</p> <p>首先获取到用户传入的<code>data</code>选项，赋给变量<code>data</code>，同时将变量<code>data</code>作为指针指向<code>vm._data</code>，然后判断<code>data</code>是不是一个函数，如果是就调用<code>getData</code>函数获取其返回值，将其保存到<code>vm._data</code>中。如果不是，就将其本身保存到<code>vm._data</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let data = vm.$options.data
data = vm._data = typeof data === 'function'
    ? getData(data, vm)
	: data || {}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>无论传入的<code>data</code>选项是不是一个函数，它最终的值都应该是一个对象，如果不是对象的话，就抛出警告：提示用户<code>data</code>应该是一个对象，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
        'data functions should return an object:\n' +
        'https://vuejs.org/v2/guide/components.html##data-Must-Be-a-Function',
        vm
    )
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>接下来遍历<code>data</code>对象中的每一项，在非生产环境下判断<code>data</code>对象中是否存在某一项<code>key</code>与<code>methods</code>中某个属性名重复，如果存在重复，就抛出警告：提示用户属性名重复。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (process.env.NODE_ENV !== 'production') {
    if (methods &amp;&amp; hasOwn(methods, key)) {
        warn(
            `Method &quot;${key}&quot; has already been defined as a data property.`,
            vm
        )
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>接下来遍历<code>data</code>对象中的每一项，在非生产环境判断<code>data</code>对象中是否存在某一项的<code>key</code>与<code>methods</code>中某个属性名重复，如果存在重复，就抛出警告：提示用户属性名重复。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (props &amp;&amp; hasOwn(props, key)) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
        `The data property &quot;${key}&quot; is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
    )
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果没有重复，则调用<code>proxy</code>函数将<code>data</code>对象中<code>key</code>不以<code>_</code>或<code>$</code>开头的属性代理到实例<code>vm</code>上，这样，我们就可以通过<code>this.xxx</code>来访问<code>data</code>选项中的<code>xxx</code>数据了。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!isReserved(key)) {
    proxy(vm, `_data`, key)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>最后，调用<code>observe</code>函数将<code>data</code>中的数据转化成响应式，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>observe(data, true /* asRootData */)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>初始化 computed</strong></p> <p>计算属性<code>computed</code>有一个很大的特点就是：计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。</p> <p><strong>用法</strong></p> <p>计算属性的用法，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var vm = new Vue({
  data: { a: 1 },
  computed: {
    // 仅读取
    aDouble: function () {
      return this.a * 2
    },
    // 读取和设置
    aPlus: {
      get: function () {
        return this.a + 1
      },
      set: function (v) {
        this.a = v - 1
      }
    }
  }
})
vm.aPlus   // =&gt; 2
vm.aPlus = 3
vm.a       // =&gt; 2
vm.aDouble // =&gt; 4
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><code>computed</code>选项中的属性值可以是一个函数，那该函数默认为取值器<code>getter</code>，用于仅读取数据；还可以是一个对象，对象里面有取值器<code>getter</code>和存值器<code>setter</code>，用于读取和设置数据。</p> <p><strong>initComputed 函数分析</strong></p> <p>初始化<code>initComputed</code>的内部原理是怎样的。<code>initComputed</code>函数的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function initComputed (vm: Component, computed: Object) {
    const watchers = vm._computedWatchers = Object.create(null)
    const isSSR = isServerRendering()
    for (const key in computed) {
        const userDef = computed[key]
        const getter = typeof userDef === 'function' ? userDef : userDef.get
        if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) {
            warn(
            `Getter is missing for computed property &quot;${key}&quot;.`,
            vm
            )
        }

        if (!isSSR) {
            watchers[key] = new Watcher(
                vm,
                getter || noop,
                noop,
                computedWatcherOptions
            )
        }

        if (!(key in vm)) {
            defineComputed(vm, key, userDef)
        } else if (process.env.NODE_ENV !== 'production') {
            if (key in vm.$data) {
                warn(`The computed property &quot;${key}&quot; is already defined in data.`, vm)
            } else if (vm.$options.props &amp;&amp; key in vm.$options.props) {
                warn(`The computed property &quot;${key}&quot; is already defined as a prop.`, vm)
            }
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>函数内部，首先定义了一个变量<code>watchers</code>并将其赋值为空对象，同时将其作为指针指向<code>vm._computedWatchers</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const watchers = vm._computedWatchers = Object.create(null)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着，遍历用户写的<code>computed</code>选项中的每一项属性，首先获取到每一项的属性值，记作<code>userDef</code>，然后判断<code>userDef</code>是不是一个函数，如果是函数，则将该函数默认为取值器<code>getter</code>，将其赋值给变量<code>getter</code>;如果不是函数，则说明是一个对象，则取对象中的<code>get</code>属性作为取值器赋给变量<code>getter</code>。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const userDef = computed[key]
const getter = typeof userDef === 'function' ? userDef : userDef.get
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>接着判断在非生产环境下如果上面两种情况取到的取值不存在，则抛出警告：提示用户计算属性必须有取值器。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) {
    warn(
        `Getter is missing for computed property &quot;${key}&quot;.`,
        vm
    )
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>接着判断如果不是在服务端渲染环境下，则为<code>computed</code>选项中的每一项属性创建一个<code>watcher</code>实例，并将当前循环的属性名作为键，创建的<code>watcher</code>实例作为值，存入<code>watchers</code>对象中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!isSSR) {
    // create internal watcher for the computed property.
    watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
    )
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>其中，上面代码中创建<code>watcher</code>实例时所传入的<code>getter</code>就是取到用户所写的该计算属性的取值器。而<code>computedWatcherOptions</code>参数如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const computedWatcherOptions = { lazy: true }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个参数是用来标记当前所创建的<code>watcher</code>实例是一个计算属性的<code>watcher</code>实例，给它一个<code>{lazy:true}</code>的配置，这是为将来计算属性值缓存做准备。计算属性有个特点就是它可以缓存当前的计算结果，也就是说如果某个计算属性所依赖的数据没有发生变化，那么该计算属性就不会去重复计算，会直接获取上一次的计算结果。这个 <code>{ lazy: true }</code>就是给计算属性做缓存时用的。</p> <p>最后，判断当前循环到的的属性名是否存在于当前实例 <code>vm</code> 上，如果存在，则在非生产环境下抛出警告；如果不存在，则调用 <code>defineComputed</code> 函数为实例 <code>vm</code> 上设置计算属性。</p> <p><strong>defineComputed 函数分析</strong></p> <p><code>defineComputed</code>函数的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
}

export function defineComputed (target,key,userDef) {
  const shouldCache = !isServerRendering()
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : userDef
    sharedPropertyDefinition.set = noop
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache &amp;&amp; userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop
  }
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        `Computed property &quot;${key}&quot; was assigned to but it has no setter.`,
        this
      )
    }
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>该函数接受 3 个参数，分别是：<code>target</code>、<code>key</code>和<code>userDef</code> 。其作用是为<code>target</code>上定义一个属性<code>key</code>，并且属性<code>key</code>的<code>getter</code>和<code>setter</code>根据<code>userDef</code>的值来设置。</p> <p>首先定义了变量<code>sharedPropertyDefinition</code>，它是一个默认值的属性描述符，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>接着，在函数内部定义了变量<code>shouldCache</code>，用于标识计算属性是否应该有缓存。该变量的值是当前环境是否为非服务端环境，如果非服务端渲染环境则该变量为<code>true</code>。也就是说，只有在非服务端渲染环境下计算属性才应该有缓存。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const shouldCache = !isServerRendering()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着，判断如果<code>userDef</code>是一个函数，则该函数默认为取值器<code>getter</code>，此处在非服务端渲染环境下并没有直接使用<code>userDef</code>作为<code>getter</code>，而调用<code>createComputedGetter</code>函数创建一个<code>getter</code>，这是因为<code>userDef</code>只是一个普通的<code>getter</code>，它并没有缓存功能，所以我们需要额外创建一个具有缓存功能的<code>getter</code>。由于用户没有调用<code>setter</code>函数，所以将<code>sharedPropertyDefinition.set</code>设置为<code>noop</code>。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/*创建计算属性的getter*/
if (typeof userDef === 'function') {
  sharedPropertyDefinition.get = shouldCache
    ? createComputedGetter(key)
    : createGetterInvoker(userDef)
  /*
    当userDef是一个function的时候是不需要setter的，所以这边给它设置成了空函数。
    因为计算属性默认是一个function，只设置getter。
    当需要设置setter的时候，会将计算属性设置成一个对象。
  */
  sharedPropertyDefinition.set = noop
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如果<code>userDef</code>不是一个函数，那么就将它当作对象处理。在设置<code>sharedPropertyDefinition.get</code>的时候先判断<code>userDef.get</code>是否存在，如果不存在，则将其设置为<code>noop</code>，如果存在，则同上面一样，在非服务端渲染环境下并且用户没有明确的将<code>userDef.cache</code>设置为<code>false</code>时调用<code>createComputedGetter</code>函数创建一个<code>getter</code>赋给 <code>sharedPropertyDefinition.get</code> 。然后设置 <code>sharedPropertyDefinition.set</code> 为 <code>userDef.set</code> 函数。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>sharedPropertyDefinition.get = userDef.get
  ? shouldCache &amp;&amp; userDef.cache !== false
    ? createComputedGetter(key)
    : createGetterInvoker(userDef.get)
  : noop
/*如果有设置set方法则直接使用，否则赋值空函数*/
sharedPropertyDefinition.set = userDef.set || noop
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>接着，再判断在非生产环境下如果用户没有设置<code>setter</code>的话，那么就给<code>setter</code>一个默认函数，这是为防止用户在没有设置<code>setter</code>的情况下修改计算属性，从而为其抛出警告，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (process.env.NODE_ENV !== 'production' &amp;&amp;
    sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
        warn(
            `Computed property &quot;${key}&quot; was assigned to but it has no setter.`,
            this
        )
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>最后调用<code>Object.defineProperty</code>方法将属性<code>key</code>绑定到<code>target</code>上，其中的属性描述符就是上面设置的<code>sharedPropertyDefinition</code>。如此以来，就将计算属性绑定到实例<code>vm</code>上了。</p> <p>计算属性有没有缓存及其响应式貌似主要在于是否将<code>getter</code>设置为<code>createComputedGetter</code>函数的返回结果。</p> <p><strong>createComputedGetter 函数分析</strong></p> <p><code>createComputedGetter</code>函数的定义在位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]
    if (watcher) {
      /*实际是脏检查，在计算属性中的依赖发生改变的时候dirty会变成true，
      在get的时候重新计算计算属性的输出值*/
      if (watcher.dirty) {
        watcher.evaluate()
      }
      /*依赖收集*/
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>该函数是一个高阶函数，其内部返回一个叫做<code>computedGetter</code>的函数，所以其实是将<code>computedGetter</code>函数赋给了<code>sharedPropertyDefinition.get</code>。当获取计算属性的值时会执行属性的<code>getter</code>，而属性的<code>getter</code>就是<code>sharedPropertyDefinition.get</code>，也就是说最终执行的<code>computedGetter</code>函数。</p> <p>在<code>computedGetter</code>函数内部，首先获取之前创建好的存储在实例上<code>_computedWatchers</code>属性中当前计算属性名<code>key</code>所对应的<code>watcher</code>实例，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果<code>watcher</code>实例存在，则判断该实例上的<code>dirty</code>属性是否为<code>true</code>，如果为<code>true</code>，即表明当前计算属性的计算结果发生了变化，则立即调用实例上的<code>evaluate</code>方法获取最新的计算结果，在<code>evaluate</code>方法内部会将最新的计算结果赋值给实例上的<code>value</code>属性，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (watcher.dirty) {
  watcher.evaluate()
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果当前有需要收集的依赖，则调用实例上的<code>depend</code>方法进行依赖收集，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (Dep.target) {
  watcher.depend()
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>最后，返回实例上的<code>value</code>属性，该属性即为当前计算属性的最终计算结果。</p> <p>在实例化<code>Watcher</code>类的时候，第四个参数传入了一个对象<code>computedWatcherOptions = { lazy: true }</code>，该对象中的<code>lazy</code>属性标志着这个<code>watcher</code>实例是计算的<code>watcher</code>实例，同时类中还定义了<code>this.dirty</code>属性用于标志计算属性的返回值是否有变化，计算属性的缓存就是通过这个属性来判断的，每当计算属性依赖的数据发生变化时，会将<code>this.dirty</code>属性设置为<code>true</code>，这样下一次读取计算属性时，会重新计算结果返回，否则直接返回之前的计算结果。</p> <p>如果计算属性中用到的数据没有发生变化，那么计算属性的<code>watcher</code>实例的<code>watcher.update</code>方法就不会执行，那么<code>watcher.dirty</code>就不会被变化为<code>true</code>，依然为<code>false</code>，那么当视图获取<code>name</code>时，就不会调用<code>watcher.evaluate</code>方法，直接返回已有的<code>watcher.value</code>，即上一次的计算结果。</p> <p>其内部原理如图所示：</p> <p><img src="vue21.jpg" alt="images"></p> <p><strong>初始化 watch</strong></p> <p>初始化<code>watch</code>选项，在日常开发中<code>watch</code>选项也经常会使用到，它可以用来侦听某个已有的数据，当该数据发生变化时执行对应的回调函数。</p> <p><strong>initWatch 函数分析</strong></p> <p><code>initWatch</code>函数的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function initWatch (vm, watch) {
  for (const key in watch) {
    const handler = watch[key]
    if (Array.isArray(handler)) {
      for (let i = 0; i &lt; handler.length; i++) {
        createWatcher(vm, key, handler[i])
      }
    } else {
      createWatcher(vm, key, handler)
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在函数内部会遍历<code>watch</code>选项，拿到每一项的<code>key</code>和对应的值<code>handler</code>。然后判断<code>handler</code>是否为数组，如果是数组则循环该数组并将数组中的每一项依次调用<code>createWatcher</code>函数来创建<code>watcher</code>；如果不是数组，则直接调用<code>createWatcher</code>函数来创建<code>watcher</code>。</p> <p><strong>createWatcher 函数分析</strong></p> <p><code>createWatcher</code>函数的定义位于源码的<code>src/core/instance/state.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function createWatcher (
  vm: Component,
  expOrFn: string | Function,
  handler: any,
  options?: Object
) {
  if (isPlainObject(handler)) {
    options = handler
    handler = handler.handler
  }
  if (typeof handler === 'string') {
    handler = vm[handler]
  }
  return vm.$watch(expOrFn, handler, options)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>可以看到，该函数接收 4 个参数，分别是：</p> <ul><li>vm：当前实例</li> <li>expOrFn：被侦听的属性表达式</li> <li>handler：<code>watch</code>选项中每一项的值</li> <li>options：用于传递给<code>vm.$watch</code>的选项对象</li></ul> <p>在该函数的内部，首先会判断传入的<code>handler</code>是否为一个对象，如果是一个对象，那么就认为用户使用的是这种写法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>watch: {
    c: {
        handler: function (val, oldVal) { /* ... */ },
		deep: true
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>即带有侦听选项的写法，此时就将<code>handler</code>对象整体记作<code>options</code>，把<code>handler</code>对象中的<code>handler</code>属性作为真正的回调函数记作<code>handler</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (isPlainObject(handler)) {
    options = handler
    handler = handler.handler
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接着判断传入的<code>handler</code>是否为一个字符串，如果是一个字符串，那么就认为用户使用的是这种写法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>watch: {
    // methods选项中的方法名
    b: 'someMethod',
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>即回调函数是<code>methods</code>选项中的一个方法名，我们知道，在初始化<code>methods</code>选项的时候会将选项中的每一个方法都绑定到当前实例上，所以此此时我们只需从当前实例上取出该方法作为真正的回调函数记作<code>handler</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (typeof handler === 'string') {
    handler = vm[handler]
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果既不是对象又不是字符串，那么我们就认为它是一个函数，就不做任何处理。</p> <p>针对不同类型的值处理完毕后，<code>expOrFn</code>是被侦听的属性表达式，<code>handler</code>亦是是回调函数，<code>options</code>变量为侦听选项，最后，调用<code>vm.$watcher</code>方法并传入以上三个参数完成初始化<code>watch</code>。</p> <h4 id="_5-2-模板编译阶段"><a href="#_5-2-模板编译阶段" aria-hidden="true" class="header-anchor">#</a> 5.2 模板编译阶段</h4> <p>模板编译阶段主要工作是获取到用户传入的模板内容并将其编译成渲染函数。</p> <p>模板编译阶段并不是存在于<code>Vue</code>的所有构建版本中，它只存在于完整版中。在只包含运行时版本中并不存在该阶段，这是因为当使用<code>vue-loader</code>或<code>vueify</code>时，<code>*.vue</code>文件内部的模板会在构建时预编译成渲染函数，所以是不需要编译的，从而不存在模板编译阶段，由上一步的初始化阶段直接进入下一阶段的挂载阶段。</p> <p><code>vue</code>基于源码构建的有两个版本，一个是<code>runtime only</code>（一个只包含运行时的版本），另一个是<code>runtime+compiler</code>（一个同时包含编译器和运行时的完整版本）。而两个版本的区别仅在于后者包含了一个编译器。</p> <ul><li>完整版本</li></ul> <p>一个完整的 <code>Vue</code>版本是包含编译器的，我们可以使用<code>template</code>选项进行模板编写。编译器会自动将<code>template</code>选项中的模板字符串编译成渲染函数的代码，源码中就是<code>render</code>函数。如果你需要在客户端编译模板（比如传入一个字符串给<code>template</code>选项，或挂载到一个元素上并以其 <code>DOM</code>内部的<code>HTML</code>作为模板），就需要一个包含编译器的版本，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//  需要编译器的版本
new Vue({
    template:'&lt;div&gt;{{hi}}&lt;/div&gt;'
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>只包含运行时版本</li></ul> <p>只包含运行时的版本拥有创建<code>Vue</code>实例、渲染并处理<code>Virtual DOM</code>等功能，基本上就是除去编译器外的完整代码。该版本的适用场景有两种：</p> <ol><li>我们在选项中通过手写<code>render</code>函数去定义渲染过程，这个时候并不需要包含编译器的版本便可完整执行。</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 不需要编译器
new Vue({
    render(h){
        return h('div',this.hi)
    }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="2"><li>借助<code>vue-loader</code>这样的编译工具进行编译，当我们利用<code>wepback</code>进行<code>vue</code>的工程化开发时，常常会利用<code>vue-loader</code>对<code>*.vue</code>文件进行编译，尽管我们也是利用<code>template</code>模板标签去书写代码，但是此时的<code>Vue</code>已经不需要利用编译器去负责模板的编译工作了，这个过程交给了插件去实现。</li></ol> <p>编译过程对性能会造成一定的损耗，并且由于加入了编译的流程代码，<code>Vue</code>代码的总体积也更加庞大（运行时版本相比完整版体积要小大约 30%）。因此在实际开发中，我们需要借助像<code>webpack</code>的<code>vue-loader</code>这类工具进行编译，将<code>vue</code>对模板的编译阶段合并到<code>webpack</code>的构建流程中，这样不仅减少了生产环境代码的体积，也大大提高了运行时的性能，一举两得。</p> <p><strong>模板编译阶段分析</strong></p> <p>完整版本和只包含运行时版之间的差异主要在于是否有模板编译阶段，而是否有模板编译阶段主要表现在<code>vm.$mount</code>方法的实现上。实现上<code>$mount</code>也有两个版本。</p> <p><strong>两种<code>$mount</code>方法对比</strong></p> <p>只包含运行时版本的<code>$mount</code>代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$mount = function(el,hydrating){
    el = el &amp;&amp; inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在该版本中的<code>$mount</code>方法内部获取到<code>el</code>选项对应的<code>DOM</code>元素后直接调用<code>mountComponent</code>函数进行挂载操作，关于该函数我们会在挂载阶段详细介绍。</p> <p>而完整版本的<code>$mount</code>代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (el,hydrating) {
  // 省略获取模板及编译代码

  return mount.call(this, el, hydrating)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在完整版本的<code>$mount</code>定义之前，先将<code>Vue</code>原型上的<code>$mount</code>方法先缓存起来，记作变量<code>mount</code>。</p> <p>其实在源码中，是先定义史包含运行时版本的<code>$mount</code>方法，再定义完整版本的<code>$mount</code>方法，所以此时缓存的<code>mount</code>变量就是只包含运行时版本的<code>$mount</code>方法。</p> <p>完整版本和只包含运行时版本之间的差异主要在于是否有模板编译阶段，只包含运行时版本没有模板编译阶段，初始化阶段完成后直接进入挂载阶段，而完整版本是初始化阶段完成后进入模板编译阶段，然后再进入挂载阶段。也就是说，这两个版本最终都会进入挂载阶段。所以在完整版本的<code>$mount</code>方法中将模板编译完成后需要回头去调只包含运行时版本的<code>$mount</code>方法以进入挂载阶段。</p> <p><strong>完整版的<code>vm.$mount</code>方法分析</strong></p> <p>完整版的<code>vm.$mount</code>方法定义位于源码的<code>src/platforms/web/entry-runtime-with-compiler.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;&amp; query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
        mark('compile')
      }

      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br></div></div><p>从代码中可以看到，该函数可以大致分为三部分：</p> <ul><li>根据传入的<code>el</code>参数获取<code>DOM</code>元素</li> <li>在用户没有手写<code>render</code>函数的情况下获取传入的模板<code>template</code>；</li> <li>将获取到的<code>template</code>编译成<code>render</code>函数；</li></ul> <p>首先，根据传入的<code>el</code>参数获取<code>DOM</code>元素。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>el = el &amp;&amp; query(el);

function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>由于<code>el</code>参数可以是元素，也可以是字符串类型的元素选择器，所以调用<code>query</code>函数来获取到<code>el</code>对应的<code>DOM</code>元素。由于<code>query</code>函数比较简单，就是根据传入的<code>el</code>参数是否为字符串从而以不同方式获取到对应的<code>DOM</code>元素。</p> <p>另外，这里还多了一个判断，就是判断获取到<code>el</code>对应的<code>DOM</code>元素如果是<code>body</code>或<code>html</code>元素时，将会抛出警告。这是因为<code>Vue</code>会将模板中的内容替换<code>el</code>对应的<code>DOM</code>元素，如果是<code>body</code>或<code>html</code>元素时，替换之后将会破坏整个<code>DOM</code>文档，所以不允许<code>el</code>是<code>body</code>或<code>html</code>。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (el === document.body || el === document.documentElement) {
  warn(
    &quot;Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.&quot;
  );
  return this
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>接着，在用户没有手写<code>render</code>函数的情况下获取传入的模板<code>template</code>；如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!options.render) {
  var template = options.template;
  if (template) {
    if (typeof template === 'string') {
      if (template.charAt(0) === '#') {
        template = idToTemplate(template);
        /* istanbul ignore if */
        if (!template) {
          warn(
            (&quot;Template element not found or is empty: &quot; + (options.template)),
            this
          );
        }
      }
    } else if (template.nodeType) {
        template = template.innerHTML;
    } else {
      {
        warn('invalid template option:' + template, this);
      }
      return this
    }
  } else if (el) {
    template = getOuterHTML(el);
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>首先获取用户传入的<code>template</code>选项赋给变量<code>template</code>，如果变量<code>template</code>存在，则接着判断如果<code>template</code>字符串并且以<code>#</code>开头，则认为<code>template</code>是<code>id</code>选择符，则调用<code>idToTemplate</code>函数获取到选择符对应的<code>DOM</code>元素的<code>innerHTML</code>作为模板，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (template) {
  if (typeof template === 'string') {
    if (template.charAt(0) === '#') {
      template = idToTemplate(template);
    }
  }
}

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el &amp;&amp; el.innerHTML
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如果<code>template</code>不是字符串，那就判断它是不是一个<code>DOM</code>元素，如果是，则使用该<code>DOM</code>元素的<code>innerHTML</code>作为模板，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (template.nodeType) {
  template = template.innerHTML;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果既不是字符串，也不是<code>DOM</code>元素，此时会抛出警告：提示用户<code>template</code>选项无效。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>else {
  {
    warn('invalid template option:' + template, this);
  }
  return this
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>如果变量<code>template</code>不存在，表明用户没有传入<code>template</code>选项，则根据传入的<code>el</code>参数调用<code>getOuterhTML</code>函数获取外部模板，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (el) {
  template = getOuterHTML(el);
}

function getOuterHTML (el) {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>不管是从内部的<code>template</code>选项中获取模板，还是从外部获取模板，总之就是要获取到用户传入的模板内容，有了模板内容接下才能装饰模板编译成渲染函数。</p> <p>获取到模板之后，接下来要做的事就是将其编译成渲染函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (template) {
  var ref = compileToFunctions(template, {
    outputSourceRange: &quot;development&quot; !== 'production',
    shouldDecodeNewlines: shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
    delimiters: options.delimiters,
    comments: options.comments
  }, this);
  var render = ref.render;
  var staticRenderFns = ref.staticRenderFns;
  options.render = render;
  options.staticRenderFns = staticRenderFns;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>把模板编译成渲染函数是在<code>compileToFunctions</code>函数中进行的，该函数接收待编译的模板字符串和编译选项作为参数，返回一个对象，对象里面的<code>render</code>属性即是编译好的渲染函数，最后将渲染函数设置到<code>$options</code>上。</p> <p><strong>总结</strong></p> <p>介绍了<code>Vue</code>源码构建的两种版本：完整版本和只包含运行时版本。并且我们知道了模板编译阶段只存在于完整版中，在只包含运行时版本中不存在该阶段，这是因为在只包含运行时版本中，当使用<code>vue-loader</code>或<code>vueify</code>时，<code>*.vue</code>文件内部的模板会在构建时预编译成渲染函数，所以是不需要编译的，从而不存在模板编译阶段。</p> <p>然后对比了两种版本<code>$mount</code>方法的区别。它们的区别在于在<code>$mount</code>方法中是否进行了模板编译。在只包含运行时版本的<code>$mount</code>方法中获取到<code>DOM</code>元素后直接进入挂载阶段，而在完整的<code>$mount</code>方法中是先将模板进行编译，然后回过头调用只包含运行时版本的<code>$mount</code>方法进入挂载阶段。</p> <p>最后，我们知道了分析模板编译阶段其实就是分析完整版本的<code>vm.$mount</code>方法的实现，我们将完整版本的<code>vm.$mount</code>方法源码进行了逐行分析。知道了在该阶段所做的工作就是：从用户传入的<code>el</code>选项和<code>template</code>选项中获取到用户传入的内部或外部模板，然后将获取到的模板编译成渲染函数。</p> <h4 id="_5-3-挂载阶段"><a href="#_5-3-挂载阶段" aria-hidden="true" class="header-anchor">#</a> 5.3 挂载阶段</h4> <p>挂载阶段所做的主要工作是创建<code>Vue</code>实例并用其替换<code>el</code>选项对应的<code>DOM</code>元素，同时还要开启对模板中数据（状态）的监控，当数据（状态）发生变化时通知其依赖进行视图更新。</p> <p><img src="vue17.jpg" alt="images"></p> <p><strong>挂载阶段分析</strong></p> <p>在完整版本的<code>$mount</code>方法中将模板编译完成之后，会回过头去调只包含运行时版本的<code>$mount</code>方法进入挂载阶段，要想分析挂载阶段我们必须从只包含运行时版本的<code>$mount</code>方法入手。</p> <p>只包含运行时版本的<code>$mount</code>代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$mount = function (el,hydrating) {
  el = el &amp;&amp; inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在该函数内部首先获取到<code>el</code>选项对应的<code>DOM</code>元素，然后调用<code>mountComponent</code>函数并将<code>el</code>选项对应的<code>DOM</code>元素传入，进入挂载阶段。</p> <p><code>mountComponent</code>函数的定义位于源码的<code>src/core/instance/lifecycle.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function mountComponent (vm,el,hydrating) {
    vm.$el = el
    if (!vm.$options.render) {
        vm.$options.render = createEmptyVNode
    }
    callHook(vm, 'beforeMount')

    let updateComponent

    updateComponent = () =&gt; {
        vm._update(vm._render(), hydrating)
    }
    new Watcher(vm, updateComponent, noop, {
        before () {
            if (vm._isMounted) {
                callHook(vm, 'beforeUpdate')
            }
        }
    }, true /* isRenderWatcher */)
    hydrating = false

    if (vm.$vnode == null) {
        vm._isMounted = true
        callHook(vm, 'mounted')
    }
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>可以看到，在该函数中，首先会判断实例上是否存在渲染函数，如果不存在，则设置一个默认的渲染函数<code>createEmptyVNode</code>，该渲染函数会创建一个注释类型的<code>VNode</code>节点。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$el = el
if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>然后调用<code>callHook</code>函数来触发<code>beforeMount</code>生命同期钩子函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>callHook(vm, 'beforeMount')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>该钩子函数触发后标志着正式开始执行挂载操作。</p> <p>接下来定义了一个<code>updateComponent</code>函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>updateComponent = () =&gt; {
    vm._update(vm._render(), hydrating)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在该函数内部，首先执行渲染函数<code>vm._render()</code>得到一份最新的<code>VNode</code>节点树，然后执行<code>vm._update()</code>方法对最新的<code>VNode</code>节点树与上一次渲染的旧<code>VNode</code>节点树进行对比并更新<code>DOM</code>节点（即<code>patch</code>操作），完成一次渲染。</p> <p>如果调用了<code>updateComponent</code>函数，就会将最新的模板内容渲染到视图页面中，这样就完成了挂载操作的一半工作。即图中的上半部分：</p> <p><img src="vue22.jpg" alt="images"></p> <p>这是因为在挂载阶段不但要将模板渲染到视图中，同时还要开启对模板中数据（状态）的监控，当数据（状态）发生变化时通知其依赖进行视图更新。即图中的下半部分：</p> <p><img src="vue23.jpg" alt="images"></p> <p>接下来创建了一个<code>Watcher</code>实例，并将定义好的<code>updateComponent</code>函数传入。要想开启对模板中数据（状态）的监控，这一段代码是关键，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>new Watcher(
    vm,                    // 第一个参数
    updateComponent,       // 第二个参数
    noop,                  // 第三个参数
    {                      // 第四个参数
        before () {
          if (vm._isMounted) {
            callHook(vm, 'beforeUpdate')
          }
        }
	},
    true                    // 第五个参数
)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在创建<code>Watcher</code>实例的时候，传入的第二个参数是<code>updateComponent</code>函数。Watcher 类构造函数的第二个参数支持两种类型：函数和数据路径（如<code>a.b.c</code>）。如果是数据路径，会根据路径去读取这个数据；如果是函数，会执行这个函数。一旦读取了数据或者执行了函数，就会触发数据或者函数内数据的<code>getter</code>方法，而在<code>getter</code>方法中会将<code>watcher</code>实例添加到该数据的依赖列表中，当该数据发生变化时就会通知依赖列表中所有的依赖，依赖接收到通知后就会调用第四个参数回调函数去更新视图。</p> <p>换句话说，上面代码中把<code>updateComponent</code>函数作为第二个参数传给<code>Watcher</code>类从而创建了<code>watcher</code>实例，那么<code>updateComponent</code>函数中读取的所有数据都将被<code>watcher</code>所监控，这些数据中只要有任何一个发生了变化，那么<code>watcher</code>都将会得到通知，从而会去调用第四个参数回调函数去更新视图，如此反复，直到实例被销毁。</p> <p><strong>总结</strong></p> <p>在该阶段中所做的主要工作是创建<code>Vue</code>实例并且用其替换<code>el</code> 选项对应的<code>DOM</code>元素，同时还要开启对模板中数据（状态）的监控，当数据（状态）发生变化时通知其依赖进行视图更新。</p> <p>我们将挂载阶段所做的工作分成两部分进行了分析，第一部分是将模板渲染到视图上，第二部分是开启对模板中数据（状态）的监控。两部分工作都完成以后挂载阶段才算真正的完成了。</p> <h4 id="_5-4-销毁阶段"><a href="#_5-4-销毁阶段" aria-hidden="true" class="header-anchor">#</a> 5.4 销毁阶段</h4> <p>销毁阶段所做的主要工作是将当前的<code>Vue</code>实例从其父级实例中删除，取消当前实例上的所有依赖追踪并且移除实例上的所有事件监听器。</p> <p><strong>销毁阶段分析</strong></p> <p>当调用了实例的<code>$destroy</code>方法之后，当前实例就进入了销毁阶段。所以分析销毁阶段就是分析<code>$destroy</code>方法的内部实现。该方法的定义位于源码的<code>src/core/instance.lifecycle.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$destroy = function () {
    const vm: Component = this
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy')
    vm._isBeingDestroyed = true
    // remove self from parent
    const parent = vm.$parent
    if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) {
      remove(parent.$children, vm)
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown()
    }
    let i = vm._watchers.length
    while (i--) {
      vm._watchers[i].teardown()
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--
    }
    // call the last hook...
    vm._isDestroyed = true
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null)
    // fire destroyed hook
    callHook(vm, 'destroyed')
    // turn off all instance listeners.
    vm.$off()
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><p>首先判断当前实例的<code>_isBeingDestroyed</code>属性是否为<code>true</code>，因为该属性标志着当前实例是否处于正在被销毁的状态，如果它为<code>true</code>，则直接<code>return</code>退出函数，防止反复执行销毁逻辑。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const vm: Component = this
if (vm._isBeingDestroyed) {
  return
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接着，触发生命周期钩子函数<code>beforeDestroy</code>，该钩子函数的调用标志着当前实例正式开始销毁。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>callHook(vm, 'beforeDestroy')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接下来，就进入了当前实例销毁的真正逻辑。</p> <p>首先，需要将当前的<code>vue</code>实例从其父级实例中删除，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const parent = vm.$parent
if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) {
  remove(parent.$children, vm)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果当前实例有父级实例，同时该父级实例没有被销毁并且不是抽象组件，那么就将当前实例从其父级实例的<code>$children</code>属性中删除，即将自己从父级实例的子实例列表中删除。</p> <p>把自己从父级实例的子实例列表中删除之后，接下来就开始将自己身上的依赖追踪和事件监听移除。</p> <p>实例身上的依赖包含两部分：一部分是实例自身依赖其他数据，需要将实例自身从其他数据的依赖列表中删除；另一部分是实例内的数据对其他数据的依赖（如用户使用<code>$watch</code>创建的依赖），也需要从其他数据的依赖列表中删除实例内数据。所以删除依赖的时候需要将这两部分依赖都删除掉。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// teardown watchers
if (vm._watcher) {
  vm._watcher.teardown()
}
let i = vm._watchers.length
while (i--) {
  vm._watchers[i].teardown()
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>首先执行<code>vm._watcher.teardown()</code>将实例自身从其他数据的依赖列表中删除，<code>teardown</code>方法的作用是从所有依赖向的<code>Dep</code>列表中将自己删除。然后，介绍<code>initState</code>函数时我们知道，所有实例内的数据对其他数据的依赖都会存放在实例的<code>_watchers</code>属性中，所以我们只需遍历<code>_watchers</code>，将其中的每一个<code>watcher</code>都调用<code>teardown</code>方法，从而实现移除实例内数据对其他数据的依赖。</p> <p>接下来移除实例内响应式数据的引用、给当前实例上添加<code>_isDestroyed</code>属性来表示当前实例已经被销毁，同时将实例的<code>VNode</code>树设置为<code>null</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (vm._data.__ob__) {
  vm._data.__ob__.vmCount--
}
vm._isDestroyed = true
vm.__patch__(vm._vnode, null)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接着，触发生命周期钩子函数<code>destroyed</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>callHook(vm, 'destroyed')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>最后，调用实例的<code>vm.$off</code>方法，移除实例上的所有事件监听器。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$off()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>总结</strong></p> <p>当调用了实例上的<code>vm.$destory</code>方法后，实例就进入了销毁阶段，在该阶段所做的主要工作是将当前的 Vue 实例从其父级实例中删除，取消当前实例上的所有依赖追踪并且移除实例上的所有事件监听器。</p> <h3 id="六、实例方法"><a href="#六、实例方法" aria-hidden="true" class="header-anchor">#</a> 六、实例方法</h3> <ul><li><a href="#_6-1-%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95">数据相关的方法</a></li> <li><a href="#_6-2-%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95">事件相关的方法</a></li> <li><a href="#_6-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95">生命周期相关的方法</a></li></ul> <h4 id="_6-1-数据相关的方法"><a href="#_6-1-数据相关的方法" aria-hidden="true" class="header-anchor">#</a> 6.1 数据相关的方法</h4> <p>参考小节<a href="#2.3-%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%9A%84-API-%E5%AE%9E%E7%8E%B0">变化侦测的 API 实现</a></p> <h4 id="_6-2-事件相关的方法"><a href="#_6-2-事件相关的方法" aria-hidden="true" class="header-anchor">#</a> 6.2 事件相关的方法</h4> <p>与事件相关的实例方法有 4 个，分别是<code>vm.$on</code>、<code>vm.$emit</code>、<code>vm.$off</code>和<code>vm.$once</code>。它们是在<code>eventsMixin</code>函数中挂载到<code>Vue</code>原型上的，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function eventsMixin (Vue) {
    Vue.prototype.$on = function (event, fn) {}
    Vue.prototype.$once = function (event, fn) {}
    Vue.prototype.$off = function (event, fn) {}
    Vue.prototype.$emit = function (event) {}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>当执行<code>eventsMixin</code>函数后，会向<code>Vue</code>原型上挂载上述 4 个实例方法。</p> <ul><li><code>vm.$on</code></li> <li><code>vm.$emit</code></li> <li><code>vm.$off</code></li> <li><code>vm.$once</code></li></ul> <p><strong><code>vm.$on</code></strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$on( event, callback )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{string | Array&lt;string&gt;} event</code>(数组只在 2.2.0+中支持)</li> <li><code>{Function} callback</code></li></ul></li> <li><p><strong>作用：</strong></p></li></ul> <p>监听当前实例上的自定义事件。事件可以由<code>vm.$emit</code>触发。回调函数会接收所有传入事件触发函数的额外参数</p> <p>示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$on('test', function (msg) {
  console.log(msg)
})
vm.$emit('test', 'hi')
// =&gt; &quot;hi&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><strong>内部原理：</strong></li></ul> <p><code>$on</code>和<code>$emit</code>这两个方法的内部原理是设计模式中最典型的发布订阅模式，首先定义一个事件中心，通过<code>$on</code>订阅事件，将事件存储在事件中心里面，然后通过<code>$emit</code>触发事件中心里面存储的订阅事件。</p> <p>该方法的定义位于源码的<code>src/core/instance/event.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$on = function (event, fn) {
    const vm: Component = this
    if (Array.isArray(event)) {
        for (let i = 0, l = event.length; i &lt; l; i++) {
            this.$on(event[i], fn)
        }
    } else {
        (vm._events[event] || (vm._events[event] = [])).push(fn)
    }
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><code>$on</code>方法接收两个参数，第一个参数是订阅的事件名，可以是数组，表示订阅多个事件。第二个参数是回调函数，当触发所订阅的事件时会执行该回调函数。</p> <p>首先，判断传入的事件名是否是一个数组，如果是数组，就表示需要一次性订阅多个事件，就遍历该数组，将数组中的每一个事件都递归调用<code>$on</code> 方法将其作为单个事件订阅。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (Array.isArray(event)) {
    for (let i = 0, l = event.length; i &lt; l; i++) {
        this.$on(event[i], fn)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果不是数组，那就当做单个事件名来处理，以该事件名作为 <code>key</code>，先尝试在当前实例的<code>_events</code> 属性中获取其对应的事件列表，如果获取不到就给其赋空数组为默认值，并将第二个参数回调函数添加进去。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>else {
    (vm._events[event] || (vm._events[event] = [])).push(fn)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当前实例的<code>_events</code>属性是干嘛的呢？</p> <p>生命周期初始化阶段的初始化事件 <code>initEvents</code> 函数中，在该函数中，首先在当前实例上绑定了<code>_events</code> 属性并给其赋值为空对象，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function initEvents (vm: Component) {
    vm._events = Object.create(null)
    // ...

}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这个<code>_events</code>属性就是用来作为当前实例的事件中心，所有绑定在这个实例上的事件都会存储在事件中心<code>_events</code>属性中。</p> <p><strong><code>vm.$emit</code></strong></p> <p><code>vm.$emit</code>用法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$emit( eventName, […args] )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数</strong></p> <ul><li><code>{string} eventName</code></li> <li><code>[…args]</code></li></ul></li> <li><p><strong>作用</strong>： 触发当前实例上的事件。附加参数都会传给监听器回调。</p></li> <li><p><strong>内部原理</strong></p></li></ul> <p>该方法接收的第一个参数是要触发的事件名，之后的附加参数都会会给触发事件的回调函数。该方法的定义位于源码的<code>src/core/instance/event.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$emit = function (event: string): Component {
    const vm: Component = this
    let cbs = vm._events[event]
    if (cbs) {
      cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs
      const args = toArray(arguments, 1)
      for (let i = 0, l = cbs.length; i &lt; l; i++) {
        try {
          cbs[i].apply(vm, args)
        } catch (e) {
          handleError(e, vm, `event handler for &quot;${event}&quot;`)
        }
      }
    }
    return vm
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>该方法传入的事件名从当前实例的<code>_events</code>属性（即事件中心）中获取到该事件名所对应的回调函数<code>cbs</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let cbs = vm._events[event]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>然后再获取传入的附加参数<code>args</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const args = toArray(arguments, 1)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>由于<code>cbs</code>是一个数组，所以遍历该数组，拿到每一个回调函数，执行回调函数并将附加参数<code>args</code>传给该回调。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (let i = 0, l = cbs.length; i &lt; l; i++) {
    try {
        cbs[i].apply(vm, args)
    } catch (e) {
        handleError(e, vm, `event handler for &quot;${event}&quot;`)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong><code>vm.$off</code></strong></p> <p>该函数的用法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$off( [event, callback] )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数</strong></p> <ul><li><code>{string | Array&lt;string&gt;} event</code></li> <li><code>{Function} [callback]</code></li></ul></li> <li><p><strong>作用</strong></p> <p>移除自定义事件监听器。</p> <ul><li>如果没有提供参数，则移除所有的事件监听器；</li> <li>如果只提供了事件，则移除该事件所有的监听器；</li> <li>如果同时提供了事件与回调，则只移除这个回调的监听器。</li></ul></li> <li><p><strong>内部原理</strong></p></li></ul> <p>该方法的定义位于源码的<code>src/core/instance/event.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$off = function (event, fn) {
    const vm: Component = this
    // all
    if (!arguments.length) {
        vm._events = Object.create(null)
        return vm
    }
    // array of events
    if (Array.isArray(event)) {
        for (let i = 0, l = event.length; i &lt; l; i++) {
            this.$off(event[i], fn)
        }
        return vm
    }
    // specific event
    const cbs = vm._events[event]
    if (!cbs) {
        return vm
    }
    if (!fn) {
        vm._events[event] = null
        return vm
    }
    if (fn) {
        // specific handler
        let cb
        let i = cbs.length
        while (i--) {
            cb = cbs[i]
            if (cb === fn || cb.fn === fn) {
                cbs.splice(i, 1)
                break
            }
        }
    }
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>该方法内部就是通过不断判断所传参数的情况进而不同的逻辑处理。</p> <p>首先，判断如果没有传入任何参数，这就是第一种情况：如果没有提供参数，则移除所有的事件监听器。我们知道，当前实例上的所有事件都存储在事件中心<code>_events</code>属性中，要想移除所有的事件，那么只需把<code>_events</code>属性重新置为空对象即可。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!arguments.length) {
    vm._events = Object.create(null)
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接着，判断如果传入的需要移除的事件名是一个数组，就表示需要一次性移除多个事件，那么我们只需订阅多个事件一样，遍历该数组，然后将数组中的每一个事件都递归调用<code>$off</code>方法进行移除即可。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (Array.isArray(event)) {
    for (let i = 0, l = event.length; i &lt; l; i++) {
        this.$off(event[i], fn)
    }
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>接着，获取到需要移除的事件名在事件中心中对应的回调函数<code>cbs</code>。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const cbs = vm._events[event]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着，判断如果<code>cbs</code>不存在，那表明在事件中心从来没有订阅过该事件，那就谈不上移除该事件，直接返回，退出程序即可。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!cbs) {
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>接着，如果<code>cbs</code>存在，但是没有传入回调函数<code>fn</code>，这就是第二种情况：如果只提供了事件，则移除该事件所有的监听器。一个事件名对应的回调函数是一个数组，要想移除所有的回调函数我们只需把它对应的数组设置为<code>null</code>即可。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!fn) {
    vm._events[event] = null
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接着，如果既传入了事件名，又传入了回调函数，<code>cbs</code>也存在，那这就是第三种情况：如果同时提供了事件与回调，则只移除这个回调的监听器。那么我们只需遍历所有回调函数数组<code>cbs</code>，如果<code>cbs</code>中某一项与<code>fn</code>相同，或者某一项的<code>fn</code>属性与<code>fn</code>相同，那么就将其从数组中删除即可。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (fn) {
    // specific handler
    let cb
    let i = cbs.length
    while (i--) {
        cb = cbs[i]
        if (cb === fn || cb.fn === fn) {
            cbs.splice(i, 1)
            break
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong><code>vm.$once</code></strong></p> <p>官方文档用法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$once( event, callback )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{string} event</code></li> <li><code>{Function} callback</code></li></ul></li> <li><p><strong>作用：</strong></p></li></ul> <p>监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。</p> <ul><li><strong>内部原理</strong></li></ul> <p>该方法的作用是先订阅事件，但是该事件只能触发一次，也就是说当该事件被触发后会立即移除。要实现这个功能也不难，我们可以定义一个子函数，用这个子函数来替换原本订阅的事件所对应的回调，也就是当触发订阅事件时，其实执行的是这个子函数，然后再子函数内部先把订阅移除，再执行原本的回调。</p> <p>该方法的定义位于源码的<code>src/core/instance/event.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$once = function (event, fn) {
    const vm: Component = this
    function on () {
        vm.$off(event, on)
        fn.apply(vm, arguments)
    }
    on.fn = fn
    vm.$on(event, on)
    return vm
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>被监听的事件是<code>event</code>，其原本对应的回调是<code>fn</code>，然后定义了一个子函数<code>on</code>。</p> <p>在该函数内部，先通过<code>$on</code>方法订阅事件，同时所使用的回调函数并不是原本的<code>fn</code>而是子函数<code>on</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$on(event, on)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当事件<code>event</code>被触发时，会执行子函数<code>on</code>。</p> <p>然后在子函数内部先通过<code>$off</code>方法移除订阅的事件，这样确保该事件不会被再次触发，接着执行原本的回调<code>fn</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function on () {
    vm.$off(event, on)
    fn.apply(vm, arguments)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们用子函数<code>on</code>替换了原本的订阅事件所对应的回调<code>fn</code>，那么在事件中心<code>_events</code>属性中存储的该事件名就会变成如下这个样子：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm._events = {
    'xxx':[on]
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>但是用户自己却不知道传入的<code>fn</code>被替换了，当用户在触发该事件之前想用<code>$off</code>方法移除该事件时：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$off('xxx',fn)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>此时就会出现问题，因为在<code>_events</code>属性中的事件名<code>xxx</code>对应的回调函数列表中没有 <code>fn</code>，那么就会移除失败。这就让用户费解了，用户明明给 <code>xxx</code> 事件传入的回调函数是 <code>fn</code>，现在反而找不到 <code>fn</code> 导致事件移除不了了。</p> <p>所以，为了解决这一问题，我们需要给 <code>on</code> 上绑定一个 <code>fn</code> 属性，属性值为用户传入的回调 <code>fn</code>，这样在使用$off 移除事件的时候，<code>$off</code> 内部会判断如果回调函数列表中某一项的 <code>fn</code> 属性与 <code>fn</code> 相同时，就可以成功移除事件了。</p> <h4 id="_6-3-生命周期相关的方法"><a href="#_6-3-生命周期相关的方法" aria-hidden="true" class="header-anchor">#</a> 6.3 生命周期相关的方法</h4> <p>与生命周期想着的实例方法有 4 个，分别是<code>vm.$mount</code>、<code>vm.$forceUpdate</code>、<code>vm.$nextTick</code>和<code>vm.$destory</code>。其中，<code>$forceUpdate</code>和<code>$destroy</code>方法是在<code>lifecycleMixin</code>函数中挂载到<code>Vue</code>原型上的，<code>$nextTick</code>方法是在<code>renderMixin</code>函数中挂载到<code>Vue</code>原型上的，而<code>$mount</code>方法是在跨平台的代码中挂载到<code>Vue</code>原型上的。</p> <ul><li><code>vm.$mount</code></li> <li><code>vm.$forceUpdate</code></li> <li><code>vm.$nextTick</code></li> <li><code>vm.$destory</code></li></ul> <p><strong><code>vm.$mount</code></strong></p> <p>官方使用如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$mount( [elementOrSelector] )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数</strong></p> <ul><li><code>{Element | string} [elementOrSelector]</code></li> <li><code>{boolean} [hydrating]</code></li></ul></li> <li><p><strong>返回值</strong>：<code>vm</code>- 实例自身</p></li> <li><p><strong>作用</strong>
如果<code>Vue</code>实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用<code>vm.$mount()</code>手动地挂载一个未挂载的实例。</p> <p>如果没有提供<code>elementOrSelector</code>参数，模板将被渲染为文档之外的元素，并且你必须使用原生<code>DOM API</code>把它插入文档中。</p></li> <li><p><strong>内部原理</strong></p></li></ul> <p>该方法的内部原理在介绍<strong>生命周期篇的模板编译阶段</strong>中已经详细分析过，此处不再重复。</p> <p><strong><code>vm.$forceUpdate</code></strong></p> <p>用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$forceUpdate()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>作用：</strong></li></ul> <p>迫使<code>Vue</code>实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p> <ul><li><strong>内部原理</strong></li></ul> <p>当实例依赖的数据发生变化时，变化的数据会通知其收集的依赖列表中的依赖进行更新，收集依赖就是收集<code>watcher</code>，依赖更新就是<code>watcher</code>调用<code>update</code>方法更新，所以实例依赖的数据发生变化时，就会通知实例<code>watcher</code>去执行<code>update</code>方法进行更新。</p> <p>实例的重新渲染其实就是实例<code>watcher</code>执行了<code>update</code>方法。</p> <p><code>$forceUpdate</code>源码实现，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.prototype.$forceUpdate = function () {
    const vm: Component = this
    if (vm._watcher) {
        vm._watcher.update()
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>当前实例的<code>_watcher</code>属性就是该实例的<code>watcher</code>，所以要想让实例重新渲染，我们只需手动的去执行一下实例<code>watcher</code>的<code>update</code>方法即可。</p> <p><strong><code>vm.$nextTick</code></strong></p> <p>参考<a href="https://km.xiaowuzi.info/js/vue-nexttick.html" target="_blank" rel="noopener noreferrer">Vue.netTick 理解与分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><strong><code>vm.$destory</code></strong></p> <p>其官方用法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$destroy()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>用法：</strong></li></ul> <p>完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。</p> <p>触发 <code>beforeDestroy</code> 和 <code>destroyed</code> 的钩子。</p> <h3 id="七、全局-api-篇"><a href="#七、全局-api-篇" aria-hidden="true" class="header-anchor">#</a> 七、全局 API 篇</h3> <p>与实例方法不同，实例方法是将方法挂载到<code>Vue</code>的原型上，而全局 API 是直接在<code>Vue</code>上挂载方法。在<code>Vue</code>中，全局 API 一共有 12 个，分别是<code>Vue.extend</code>、<code>Vue.nextTick</code>、<code>Vue.set</code>、<code>Vue.delete</code>、<code>Vue.directive</code>、<code>Vue.filter</code>、<code>Vue.component</code>、<code>Vue.use</code>、<code>Vue.mixin</code>、<code>Vue.observable</code>、<code>Vue.version</code>。这 12 个 API 中有的是我们在日常业务开发中经常会用到的，有的是对 Vue 内部或外部插件提供的，我们在日常业务开发中几乎用不到。</p> <ol><li>Vue.extend</li> <li>Vue.nextTick</li> <li>Vue.set</li> <li>Vue.delete</li> <li>Vue.directive</li> <li>Vue.filter</li> <li>Vue.component</li> <li>directive、filter、component 小结</li> <li>Vue.use</li> <li>Vue.mixin</li> <li>Vue.compile</li> <li>Vue.observable</li> <li>Vue.version</li></ol> <h4 id="_7-1-vue-extend"><a href="#_7-1-vue-extend" aria-hidden="true" class="header-anchor">#</a> 7.1 Vue.extend</h4> <p><strong>用法</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.extend( options )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>参数</strong>：</p> <ul><li><code>{Object} options</code></li></ul> <p><strong>作用</strong>：</p> <p>使用基础<code>Vue</code>构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p> <p><strong>原理分析</strong>：</p> <p><code>Vue.extend</code>的作用是创建一个继承自<code>Vue</code>类的子类，可接收的参数是一个包含组件选项的对象。</p> <p>既然是<code>Vue</code>类的子类，那么除了它本身独有的一些属性方法，还有一些是从<code>Vue</code>类中继承而来，所以创建子类的过程其实就是一边给子类上添加上独有的属性，一边将父类的公共属性到子类上。接下来，我们就来看看源码是如何实现这个过程的。</p> <p>该 API 的定义位于源码的<code>src/core/global-api/extend.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.extend = function (extendOptions: Object): Function {
extendOptions = extendOptions || {}
const Super = this
const SuperId = Super.cid
const cachedCtors = extendOptions.\_Ctor || (extendOptions.\_Ctor = {})
if (cachedCtors[SuperId]) {
return cachedCtors[SuperId]
}

const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' &amp;&amp; name) {
        validateComponentName(name)
    }

    const Sub = function VueComponent (options) {
        this._init(options)
    }
    Sub.prototype = Object.create(Super.prototype)
    Sub.prototype.constructor = Sub
    Sub.cid = cid++
    Sub.options = mergeOptions(
        Super.options,
        extendOptions
    )
    Sub['super'] = Super

    if (Sub.options.props) {
        initProps(Sub)
    }
    if (Sub.options.computed) {
        initComputed(Sub)
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type]
    })
    // enable recursive self-lookup
    if (name) {
        Sub.options.components[name] = Sub
    }

    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    Sub.sealedOptions = extend({}, Sub.options)

    // cache constructor
    cachedCtors[SuperId] = Sub
    return Sub

}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br></div></div><p>首先，该函数内部定义了几个变量，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>extendOptions = extendOptions || {}
const Super = this
const SuperId = Super.cid
const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><code>extendOptions</code>：用户传入的一个饮食组件选项的对象参数；</li> <li><code>Super</code>：指向父类，即基础<code>Vue</code>类；</li> <li><code>SuperId</code>：父类的<code>cid</code>属性，无论是基础<code>Vue</code>类继承而来的类，都有一个<code>cid</code>属性，作为该类的唯一标识；</li> <li><code>cachedCtors</code>：缓存池，用于缓存创建出来的类；</li></ul> <p>接着，在缓存池中先尝试获取是否之前已经创建过的该子类，如果之前创建过，则直接返回之前创建的。之所以有这一步，是因为<code>Vue</code>为了性能考虑，反复调用<code>Vue.extend</code>其实应该返回同一个结果，只要返回结果是固定的，就可以将结果缓存，再次调用时，只需从缓存中取出结果即可。在 API 方法定义的最后，当创建完子类后，会使用父类的<code>cid</code>作为<code>key</code>，创建好的子类作为<code>value</code>，存入缓存池<code>cachedCtors</code>中。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (cachedCtors[SuperId]) {
    return cachedCtors[SuperId]
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>接着，获取到传入的选项参数中的<code>name</code>字段，并且在开发环境下校验<code>name</code>字段是否合法，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const name = extendOptions.name || Super.options.name
if (process.env.NODE_ENV !== 'production' &amp;&amp; name) {
    validateComponentName(name)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接着，创建一个类<code>Sub</code>，这个类就是将要继承基础<code>Vue</code>类的子类，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const Sub = function VueComponent (options) {
    this._init(options)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>到这里，我们已经把类创建好了，接下来的工作就是让该类去继承基础<code>Vue</code>类，让其具备一些基础 <code>Vue</code> 类的能力。</p> <p>首先，将父类的原型继承到子类中，并且为子类添加唯一标识 <code>cid</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Sub.prototype = Object.create(Super.prototype)
Sub.prototype.constructor = Sub
Sub.cid = cid++
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>接着，将父类的<code>options</code>与子类的<code>options</code>进行合并，将合并结果赋给子类的<code>options</code>属性，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Sub.options = mergeOptions(
    Super.options,
    extendOptions
)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接着，将父类保存到子类的<code>super</code>属性中，以确保在子类中能够拿到父类，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Sub['super'] = Super
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接着，如果选项中存在<code>props</code>属性，则初始化它，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (Sub.options.props) {
    initProps(Sub)
}

function initProps (Comp) {
  const props = Comp.options.props
  for (const key in props) {
    proxy(Comp.prototype, `_props`, key)
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>初始化<code>props</code>属性其实就是把参数中传入的<code>props</code>选项代理到原型的<code>_props</code>中。</p> <p>接着，如果选项中存在<code>computed</code>属性，则初始化它，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (Sub.options.computed) {
    initComputed(Sub)
}

function initComputed (Comp) {
  const computed = Comp.options.computed
  for (const key in computed) {
    defineComputed(Comp.prototype, key, computed[key])
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>初始化<code>props</code>属性就是遍历参数中传入的<code>computed</code>选项，将每一项都调用<code>defineComputed</code>函数定义到子类原型上。此处的<code>defineComputed</code>函数与我们之前在生命周期初始化阶段<code>initState</code>中所介绍的<code>defineComputed</code>函数是一样的。</p> <p>接着，将父类中的一些属性复制到子类中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Sub.extend = Super.extend
Sub.mixin = Super.mixin
Sub.use = Super.use

export const ASSET_TYPES = [
  'component',
  'directive',
  'filter'
]
// create asset registers, so extended classes
// can have their private assets too.
ASSET_TYPES.forEach(function (type) {
    Sub[type] = Super[type]
})
// enable recursive self-lookup
if (name) {
    Sub.options.components[name] = Sub
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>接着，给子类新增三个独有的属性，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Sub.superOptions = Super.options
Sub.extendOptions = extendOptions
Sub.sealedOptions = extend({}, Sub.options)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>最后，使用父类的<code>cid</code>作为<code>key</code>，创建好的子类<code>Sub</code>作为<code>value</code>，存入缓存池<code>cachedCtors</code>中。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// cache constructor
cachedCtors[SuperId] = Sub
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>最终将创建好的子类 Sub 返回。</p> <p>整个过程就是先创建一个类<code>Sub</code>，接着通过原型继承的方式将该类继承基础<code>Vue</code>类，然后给 <code>Sub</code> 类添加一些属性以及将父类的某些属性复制到 <code>Sub</code> 类上，最后将 <code>Sub</code> 类返回。</p> <h4 id="_7-2-vue-nexttick"><a href="#_7-2-vue-nexttick" aria-hidden="true" class="header-anchor">#</a> 7.2 Vue.nextTick</h4> <p><strong>用法</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.nextTick( [callback, context] )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>参数</strong></p> <ul><li><code>{Function} [callback]</code></li> <li><code>{Object} [context]</code></li></ul> <p><strong>作用</strong></p> <p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p> <p><strong>原理</strong></p> <p>全局 nextTick 方法同实例 nextTick 方法一样</p> <h4 id="_7-3-vue-set"><a href="#_7-3-vue-set" aria-hidden="true" class="header-anchor">#</a> 7.3 Vue.set</h4> <p><strong>用法</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.set( target, propertyName/index, value )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>参数</strong></p> <ul><li><code>{Object | Array} target</code></li> <li><code>{string | number} propertyName/index</code></li> <li><code>{any} value</code></li></ul> <p>返回设置的值。</p> <p><strong>作用</strong></p> <p>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性</p> <p><strong>原理</strong>
全局 set 方法同实例 set 方法一样</p> <h4 id="_7-4-vue-delete"><a href="#_7-4-vue-delete" aria-hidden="true" class="header-anchor">#</a> 7.4 Vue.delete</h4> <p><strong>用法</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.delete( target, propertyName/index )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>参数</strong></p> <ul><li><code>{Object | Array} target</code></li> <li><code>{string | number} propertyName/index</code></li></ul> <p><strong>作用</strong></p> <p>删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。</p> <p><strong>原理</strong></p> <p>全局 delete 方法同实例 delete 方法一样</p> <h4 id="_7-5-vue-directive"><a href="#_7-5-vue-directive" aria-hidden="true" class="header-anchor">#</a> 7.5 Vue.directive</h4> <p>其用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.directive( id, [definition] )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{string} id</code></li> <li><code>{Function | Object} [definition]</code></li></ul></li> <li><p><strong>作用：</strong> 注册或获取全局指令。</p></li> <li><p><strong>原理分析</strong></p></li></ul> <p>该 API 是用来注册或获取全局指令的，接收两个参数：指令<code>id</code>和指令的定义。这里需要注意一点的是：注册指令是将定义好的指令存放在某个位置，获取指令是根据指令<code>id</code>从存放指令的位置读取指令。</p> <p>该 API 的内部实现原理，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.options = Object.create(null)
Vue.options['directives'] = Object.create(null)

Vue.directive= function (id,definition) {
    if (!definition) {
        return this.options['directives'][id]
    } else {
        if (type === 'directive' &amp;&amp; typeof definition === 'function') {
            definition = { bind: definition, update: definition }
        }
        this.options['directives'][id] = definition
        return definition
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>可以看到，我们在<code>Vue</code>类上创建了<code>options</code>属性，其属性值为一个空对象，并且在<code>options</code>属性中添加了<code>directives</code>属性，其值也是一个空对象，这个<code>directives</code>属性就是用来存放指令的位置。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.options = Object.create(null)
Vue.options['directives'] = Object.create(null)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 API 可以用来注册或获取全局指令，这两种功能的切换取决于是否传入了<code>definition</code>参数。如果没有传入<code>definition</code>参数，则表示为获取指令，那么就从存放指令的地方根据指令<code>id</code>来读取指令返回，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!definition) {
    return this.options['directives'][id]
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果传入了<code>definition</code>参数，则表示为注册指令，那么继续判断<code>definition</code>参数是否是一个函数，如果是函数，则默认监听<code>bind</code>和<code>update</code>两个事件，即将<code>definition</code>函数分别赋给<code>bind</code>和<code>update</code>两个属性。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (type === 'directive' &amp;&amp; typeof definition === 'function') {
    definition = { bind: definition, update: definition }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果 <code>definition</code> 参数不是一个函数，那么即认为它是用户自定义的指令对象，直接将其保存在 <code>this.options['directives']</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>this.options['directives'][id] = definition
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_7-6-vue-filter"><a href="#_7-6-vue-filter" aria-hidden="true" class="header-anchor">#</a> 7.6 Vue.filter</h4> <p>其用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.filter( id, [definition] )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>参数：</strong> <ul><li><code>{string} id</code></li> <li><code>{Function} [definition]</code></li></ul></li> <li><strong>作用</strong></li></ul> <p>注册或获取全局过滤器。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 注册
Vue.filter('my-filter', function (value) {
  // 返回处理后的值
})

// getter，返回已注册的过滤器
var myFilter = Vue.filter('my-filter')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><strong>原理分析</strong></li></ul> <p>该 API 是用来注册或获取全局过滤器的，接收两个参数：过滤器<code>id</code>和过滤的定义。同全局指令一样，注册过滤器是将定义好的过滤器存放在某个位置，获取过滤器是根据过滤器<code>id</code>从存放过滤器的位置来读取过滤器。</p> <p>其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.options = Object.create(null)
Vue.options['filters'] = Object.create(null)

Vue.filter= function (id,definition) {
    if (!definition) {
        return this.options['filters'][id]
    } else {
        this.options['filters'][id] = definition
        return definition
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>跟全局指令一样，<code>Vue.options['filters']</code>是用来存放全局过滤器的地方。还是根据是否传入了<code>definition</code>参数来决定本次操作是注册过滤器还是获取过滤器。如果没有传入<code>definition</code>参数，则表示本次操作为获取过滤器，那么就从存放过滤器的地方根据过滤器<code>id</code>来读取过滤器并返回；如果传入了<code>definition</code>参数，则表示本次操作为注册过滤器，那就直接将其保存在<code>this.options['filters']</code>中。</p> <h4 id="_7-7-vue-component"><a href="#_7-7-vue-component" aria-hidden="true" class="header-anchor">#</a> 7.7 Vue.component</h4> <p>其用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.component( id, [definition] )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{string} id</code></li> <li><code>{Function | Object} [definition]</code></li></ul></li> <li><p><strong>作用：</strong></p> <p>注册或获取全局组件。注册还会自动使用给定的<code>id</code>设置组件的名称</p></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 注册组件，传入一个扩展过的构造器
Vue.component('my-component', Vue.extend({ /* ... */ }))

// 注册组件，传入一个选项对象 (自动调用 Vue.extend)
Vue.component('my-component', { /* ... */ })

// 获取注册的组件 (始终返回构造器)
var MyComponent = Vue.component('my-component')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li><strong>原理分析</strong></li></ul> <p>该 API 是用来注册或获取全局组件的，接收两个参数：组件<code>id</code>和组件的定义。同全局指令一样，注册全局组件是将定义好的组件存放在某个位置，获取组件是根据组件<code>id</code>从存放组件的位置来读取组件。</p> <p>该 API 的内部实现原理，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.options = Object.create(null)
Vue.options['components'] = Object.create(null)

Vue.filter= function (id,definition) {
    if (!definition) {
        return this.options['components'][id]
    } else {
        if (process.env.NODE_ENV !== 'production' &amp;&amp; type === 'component') {
            validateComponentName(id)
        }
        if (type === 'component' &amp;&amp; isPlainObject(definition)) {
            definition.name = definition.name || id
            definition = this.options._base.extend(definition)
        }
        this.options['components'][id] = definition
        return definition
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>同全局指令一样，<code>Vue.options['components']</code>是用来存放全局组件的地方。还是根据是否传入了<code>definition</code>参数来决定本次操作是注册组件还是获取组件。如果没有传入<code>definition</code>参数，则表示本次操作为获取组件，那么就从存放组件的地方根据组件 <code>id</code> 来读取组件并返回；如果传入了<code>definition</code>参数，则表示本次操作为注册组件，如果是注册组件，那么在非生产环境下首先会校验组件的<code>name</code>值是否合法，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (process.env.NODE_ENV !== 'production' &amp;&amp; type === 'component') {
    validateComponentName(id)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>接着，判断传入的<code>definition</code>参数是否是一个对象，如果是对象，则使用<code>Vue.extend</code>方法将其变为<code>Vue</code>的子类，同时如果<code>definition</code>对象中不存在<code>name</code>属性时，则使用组件 id 作为组件的<code>name</code>属性。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (type === 'component' &amp;&amp; isPlainObject(definition)) {
    definition.name = definition.name || id
    definition = this.options._base.extend(definition)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_7-8-directive、filter、component-小结"><a href="#_7-8-directive、filter、component-小结" aria-hidden="true" class="header-anchor">#</a> 7.8 directive、filter、component 小结</h4> <p>通过对<code>Vue.directive</code>、<code>Vue.filter</code>和<code>Vue.component</code>这三个 API 的分析，细心的你肯定会发现这三个 API 的代码实现非常的相似，是的，这是我们为了便于理解故意拆开的，其实在源码中这三个 API 的实现是写在一起的，位于源码的<code>src/core/global-api/index.js</code>和<code>src/core/global-api/assets.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export const ASSET_TYPES = [
  'component',
  'directive',
  'filter'
]

Vue.options = Object.create(null)
ASSET_TYPES.forEach(type =&gt; {
    Vue.options[type + 's'] = Object.create(null)
})

ASSET_TYPES.forEach(type =&gt; {
    Vue[type] = function (id,definition) {
        if (!definition) {
            return this.options[type + 's'][id]
        } else {
            if (process.env.NODE_ENV !== 'production' &amp;&amp; type === 'component') {
                validateComponentName(id)
            }
            if (type === 'component' &amp;&amp; isPlainObject(definition)) {
                definition.name = definition.name || id
                definition = this.options._base.extend(definition)
            }
            if (type === 'directive' &amp;&amp; typeof definition === 'function') {
                definition = { bind: definition, update: definition }
            }
            this.options[type + 's'][id] = definition
            return definition
        }
    }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><h4 id="_7-9-vue-use"><a href="#_7-9-vue-use" aria-hidden="true" class="header-anchor">#</a> 7.9 Vue.use</h4> <p>其用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.use( plugin )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{Object | Function} plugin</code></li></ul></li> <li><p><strong>作用：</strong></p></li></ul> <p>安装 Vue.js 插件。如果插件是一个对象，必须提供<code>install</code>方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将<code>Vue</code>作为参数传入。</p> <ul><li><strong>原理分析：</strong></li></ul> <p>该 API 内部会调用插件提供的<code>install</code>方法，同时将<code>Vue</code> 作为参数传入。另外，由于插件只会被安装一次，所以该 API 内部还应该防止 <code>install</code>方法被同一个插件多次调用。</p> <p>该 API 的定义位于源码的<code>src/core/global-api/use.js</code>中，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
Vue.use = function (plugin) {
const installedPlugins = (this.\_installedPlugins || (this.\_installedPlugins = []))
if (installedPlugins.indexOf(plugin) &gt; -1) {
return this
}

    // additional parameters
    const args = toArray(arguments, 1)
    args.unshift(this)
    if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args)
    } else if (typeof plugin === 'function') {
        plugin.apply(null, args)
    }
    installedPlugins.push(plugin)
    return this

}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>在该函数内部，首先定义了一个变量<code>installedPlugins</code>，该变量初始值是一个空数组，用来存储已安装过的插件。首先判断传入的插件是否存在于<code>installedPlugins</code>数组中（即已经被安装过），如果存在的话，则直接返回，防止重复安装。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))
if (installedPlugins.indexOf(plugin) &gt; -1) {
    return this
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接下来获取到传入的其余参数，并且使用<code>toArray</code>方法将其转换成数组，同时将 <code>Vue</code> 插入到该数组的第一个位置，这是因为在后续调用 <code>install</code> 方法时，<code>Vue</code> 必须作为第一个参数传入。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const args = toArray(arguments, 1)
args.unshift(this)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>首先，判断传入的插件如果是一个提供了<code>install</code>方法的对象，那么就执行该对象中提供的<code>install</code>方法并传入参数完成插件安装。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (typeof plugin.install === 'function') {
    plugin.install.apply(plugin, args)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果传入的插件是一个函数，那么就把这个函数当作<code>install</code>方法执行，同时传入参数完成插件安装。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>else if (typeof plugin === 'function') {
    plugin.apply(null, args)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果传入的插件是一个函数，那么就把这个函数当作<code>install</code>方法执行，同时传入参数完成插件安装。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>else if (typeof plugin === 'function') {
    plugin.apply(null, args)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>插件安装完成之后，将该插件添加进已安装插件列表中，防止重复安装。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>installedPlugins.push(plugin)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_7-10-vue-mixin"><a href="#_7-10-vue-mixin" aria-hidden="true" class="header-anchor">#</a> 7.10 Vue.mixin</h4> <p>其用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.mixin( mixin )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{Object} mixin</code></li></ul></li> <li><p><strong>作用：</strong></p></li></ul> <p>全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。</p> <ul><li><strong>原理分析</strong></li></ul> <p>该 API 是用来向全局注册一个混入，即可以修改<code>Vue.options</code>属性，并且会影响之后的所有 Vue 实例，这个 API 虽然在日常的业务开发中几乎用不到，但是在编写 Vue 插件时用处非常大。</p> <p>该 API 的定义位于源码的 <code>src/core/global-api/mixin.js</code> 中，代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.mixin = function (mixin: Object) {
    this.options = mergeOptions(this.options, mixin)
    return this
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>该 API 就是通过修改<code>Vue.options</code>属性进而影响之后的所有 Vue 实例。所以我们只需将传入的<code>mixin</code>对象与<code>this.options</code>合并即可，然后将合并后的新对象作为<code>this.options</code>传给之后的所有 Vue 实例，从而达到改变其原有特性的效果。</p> <h4 id="_7-11-vue-compile"><a href="#_7-11-vue-compile" aria-hidden="true" class="header-anchor">#</a> 7.11 Vue.compile</h4> <p>其用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.compile( template )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{string} template</code></li></ul></li> <li><p><strong>作用：</strong></p> <p>在<code>render</code>函数中编译模板字符串。只在独立构建时有效</p></li> <li><p><strong>原理分析</strong></p></li></ul> <p>该 API 是用来编译模板字符串的，我们在日常业务开发中几乎用不到，它内部是调用了<code>compileFunctions</code>方法，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.compile = compileToFunctions;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_7-12-vue-observable"><a href="#_7-12-vue-observable" aria-hidden="true" class="header-anchor">#</a> 7.12 Vue.observable</h4> <p>其用法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.observable( object )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>参数：</strong></p> <ul><li><code>{Object} object</code></li></ul></li> <li><p><strong>用法：</strong></p> <p>让一个对象可响应。Vue 内部会用它来处理<code>data</code>函数返回的对象。</p> <p>返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  const state = Vue.observable({ count: 0 })

  const Demo = {
  render(h) {
      return h('button', {
      on: { click: () =&gt; { state.count++ }}
      }, `count is: ${state.count}`)
  }
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p><strong>分析原理</strong></p></li></ul> <p>该 API 是用来将一个普通对象转化成响应式对象。</p> <h3 id="八、过滤器篇"><a href="#八、过滤器篇" aria-hidden="true" class="header-anchor">#</a> 八、过滤器篇</h3> <h4 id="_8-1-用法回顾"><a href="#_8-1-用法回顾" aria-hidden="true" class="header-anchor">#</a> 8.1 用法回顾</h4> <p><strong>使用方式</strong></p> <p>过滤器有两种使用方式：<strong>在双花括号插值中和在 v-bind 表达式中</strong> 添加在 JavaScript 表达式的尾部，由&quot;|&quot;符号指示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!-- 在双花括号中 --&gt;
{{ message | capitalize }}

&lt;!-- 在 `v-bind` 中 --&gt;
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>过滤器的定义</strong></p> <p>你可以在一个组件的选项中定义本地的过滤器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>也可以在创建 <code>Vue</code> 实例之前使用全局 API<code>Vue.filter</code>来定义全局过滤器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>当全局过滤器和局部过滤器重名时，会采用局部过滤器。</p> <p><strong>串联过滤器</strong></p> <p>过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，<code>capitalize</code> 过滤器函数将会收到 <code>message</code> 的值作为第一个参数。</p> <p>过滤器可以串联：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{{ message | filterA | filterB }}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在这个例子中，<code>filterA</code> 被定义为接收单个参数的过滤器函数，表达式 <code>message</code> 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 <code>filterB</code>，将 <code>filterA</code> 的结果传递到 <code>filterB</code> 中。</p> <p>过滤器是 JavaScript 函数，因此可以接收参数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{{ message | filterA('arg1', arg2) }}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这里，<code>filterA</code> 被定义为接收三个参数的过滤器函数。其中 <code>message</code> 的值作为第一个参数，普通字符串<code>'arg1'</code>作为第二个参数，表达式 <code>arg2</code> 的值作为第三个参数。</p> <p><strong>总结</strong></p> <p>过滤器有两种使用方式，分别是在双花括号插值和在<code>v-bind</code>表达式中。无论是哪种使用方式，它的使用形式都是<code>表达式|过滤器1|过滤器2|...</code>。</p> <p>并且，我们知道了过滤器的定义也有两种方式，分别是在组件选项内定义和使用全局 API<code>Vue.filter</code>定义全局过滤器。在组件选项内定义的过滤器称为本地过滤器，它只能用于当前组件中。使用<code>Vue.filter</code>定义的过滤器称为全局过滤器，它可以用在任意组件中。</p> <p>另外，我们还知道了过滤器不仅可以单个使用，还可以多个串联一起使用。当多个过滤器串联一起使用的时候，前一个过滤器的输出是后一个过滤器的输入，通过将多种不同的过滤器进行组合使用来将文本处理成最终需要的格式。</p> <p>最后，官方文档还说了所谓过滤器本质上就是一个 JS 函数，所以我们在使用过滤器的时候还可以给过滤器传入参数，过滤器接收的第一个参数永远是表达式的值，或者是前一个过滤器处理后的结果，后续其余的参数可以被用于过滤器内部的过滤规则中。</p> <h4 id="_8-2-工作原理"><a href="#_8-2-工作原理" aria-hidden="true" class="header-anchor">#</a> 8.2 工作原理</h4> <p>过滤器有两种使用方式，分别是在双花括号插件中和在<code>v-bind</code>表达式。但是无论是哪一种使用方式，过滤器都是写在模板里面的。既然是写在模板里面，那么它就会被编译，会被编译成渲染函数字符串，然后在挂载的时候会执行渲染函数，从而就会使过滤器生效。举个例子：</p> <p>假如有如下过滤器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{{ message | capitalize }}

filters: {
    capitalize: function (value) {
        if (!value) return ''
        value = value.toString()
        return value.charAt(0).toUpperCase() + value.slice(1)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>那么它被编译成渲染函数字符串后，会变成这个样子：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>_f(&quot;capitalize&quot;)(message)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>_f</code>对应的是<code>resolveFilter</code>函数，通过模板编译会生成一个<code>_f</code> 函数调用字符串，当执行渲染函数的时候，就会执行<code>_f</code>函数，从而让过滤器生效。</p> <p><strong>resolveFilter 函数分析</strong></p> <p><code>resolveFilter</code>函数的定义位于源码的<code>src/core/instance/render-helper.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import { identity, resolveAsset } from 'core/util/index'

export function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可以看到，<code>resolveFilter</code>函数内部只有一行代码，就是调用<code>resolveAsset</code>函数并获取其返回值，如果返回值不存在，则返回<code>identity</code>，而<code>identity</code>是一个返回同参数一样的值，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/**
 * Return same value
 */
export const identity = _ =&gt; _
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>resolveAsset</code>函数，该函数的定义位于源码的<code>src/core/util/options.js</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function resolveAsset (options,type,id,warnMissing) {
  if (typeof id !== 'string') {
    return
  }
  const assets = options[type]
  // 先从本地注册中查找
  if (hasOwn(assets, id)) return assets[id]
  const camelizedId = camelize(id)
  if (hasOwn(assets, camelizedId)) return assets[camelizedId]
  const PascalCaseId = capitalize(camelizedId)
  if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId]
  // 再从原型链中查找
  const res = assets[id] || assets[camelizedId] || assets[PascalCaseId]
  if (process.env.NODE_ENV !== 'production' &amp;&amp; warnMissing &amp;&amp; !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    )
  }
  return res
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>调用该函数时传入了 4 个参数，分别是当前实例的<code>$options</code>属性，<code>type</code>为<code>filters</code>，<code>id</code>为当前过滤器的<code>id</code>。</p> <p>在该函数内部，首先判断传入的参数<code>id</code>（即当前过滤器的名称 id）是否为字符串类型，如果不是，则直接退出程序。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (typeof id !== 'string') {
    return
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>接着，获取到当前实例的<code>$options</code>属性中所有的过滤器，赋给变量<code>assets</code>，组件中的所有选项都会被合并到当前实例的<code>$options</code>属性中，并且使用<code>Vue.filter</code>定义的过滤器也会被添加到<code>$options</code>中的<code>filters</code>属性中，所以不管是以何种方式定义的过滤器，我们都可以从<code>$options</code>中的<code>filters</code>属性中获取到。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const assets = options[type]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>获取到所有的过滤器后，接下来我们只需根据过滤器 id 取出对应的过滤器函数即可，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 先从本地注册中查找
if (hasOwn(assets, id)) return assets[id]
const camelizedId = camelize(id)
if (hasOwn(assets, camelizedId)) return assets[camelizedId]
const PascalCaseId = capitalize(camelizedId)
if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId]
// 再从原型链中查找
const res = assets[id] || assets[camelizedId] || assets[PascalCaseId]
if (process.env.NODE_ENV !== 'production' &amp;&amp; warnMissing &amp;&amp; !res) {
    warn(
        'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
        options
    )
}
return res
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>根据过滤器<code>id</code>查找过滤器首先先从本地注册中查找，先通过<code>hasOwn</code>函数检查<code>assets</code>自身中是否存在，如果存在则直接返回；如果不存在，则将过滤器<code>id</code>转化成驼峰式后再次查找，如果存在则直接返回；如果也不存在，则将过滤器<code>id</code>转化成首字母大写后再次查找，如果存在则直接返回；如果还不存在，则再从原型链中查找，如果存在则直接返回；如果还不存在，则在非生产环境下抛出警告。</p> <p>以上，就是<code>resolveFilter</code>函数的所有逻辑，可以看到，<code>resolveFilter</code>函数其实就是在根据过滤器<code>id</code>获取到用户定义的对应的过滤函数返回，拿到用户定义的过滤器函数之后，就可以调用该函数并传入参数使其生效了。如下图所示：</p> <p><img src="vue24.jpg" alt="images"></p> <p><strong>串联过滤器原理</strong></p> <p>上面分析了单个过滤器的工作原理，对于多个过滤器串联一起使用其原理也是相同的，还是先根据过滤器<code>id</code>获取到对应的过滤器函数，然后传入参数调用即可，唯一有所区别的是：对于多个串联过滤器，在调用过滤器函数传递参数时，后一个过滤器的输入参数是前一个过滤器的输出结果。举个例子：</p> <p>假如有如下过滤器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{{ message | filterA | filterB }}

filters: {
    filterA: function (value) {
        // ...
    },
    filterB: function (value) {
        // ...
    },
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>那么它被编译成渲染函数字符串后，会变成这个样子：</p> <p><img src="25.jpg" alt="images"></p> <p>可以看到，过滤器<code>filterA</code>的执行结果作为参数传给了过滤器<code>filterB</code>。</p> <p><strong>过滤器接收参数</strong></p> <p>过滤器本质上就是一个<code>JS</code>函数，既然是函数，那它肯定就可以接收参数，唯一一点需要注意的就是：过滤器的第一个参数永远是表达式的值，或者是前一个过滤器处理后的结果，后续其余的参数可以被用于过滤器内部的过滤规则中。举个例子：</p> <p>假如有如下过滤器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{{ message | filterA | filterB(arg) }}

filters: {
    filterA: function (value) {
        // ...
    },
    filterB: function (value,arg) {
        return value + arg
    },
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>那么它被编译成渲染函数字符串后，会变成这个样子：</p> <p><img src="vue26.jpg" alt="images"></p> <p>可以看到，当过滤器接收其余参数时，它的参数都是从第二个参数开始往后传入的。</p> <p><strong>小结</strong></p> <p>介绍了过滤器的内部工作原理，就是将用户写在模板中的过滤器通过模板编译，编译成<code>_f</code>函数的调用字符串，之后在执行渲染函数的时候会执行<code>_f</code>函数，从而使过滤器生效。</p> <p>所谓<code>_f</code>函数其实就是<code>resolveFilter</code>函数的别名，在<code>resolveFilter</code>函数内部是根据过滤器<code>id</code>从当前实例的<code>$options</code>中的<code>filters</code>属性中获取到对应的过滤器函数，在之后执行渲染函数的时候就会执行获取到的过滤器函数。</p> <h4 id="_8-3-解析过滤器"><a href="#_8-3-解析过滤器" aria-hidden="true" class="header-anchor">#</a> 8.3 解析过滤器</h4> <p><strong>在何处解析过滤器</strong></p> <p>过滤器有两种使用方式，分别在<strong>在双花括号插值中和在 v-bind 表达式中</strong>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!-- 在双花括号中 --&gt;
{{ message | capitalize }}

&lt;!-- 在 `v-bind` 中 --&gt;
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>两不同的使用方式唯一的区别是将过滤器写在不同的地方，既然有两种不同的地方可以书写过滤器，那解析的时候必然要在这两种不同地方都进行解析。</p> <ul><li>写在<code>v-bind</code>表达式中</li></ul> <p><code>v-bind</code>表达式中的过滤器它属于存在于标签属性中，那么写在该处的过滤器就需要在处理标签属性时进行解析。我们知道，在<code>HTML</code>解析器<code>parseHTML</code>函数中负责处理标签属性的函数是<code>processAttrs</code>，所以会在<code>processAttrs</code>函数中调用过滤解析器<code>parseFilters</code>函数对写在该处的过滤器进行解析，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function processAttrs (el) {
    // 省略无关代码...
    if (bindRE.test(name)) { // v-bind
        // 省略无关代码...
        value = parseFilters(value)
        // 省略无关代码...
    }
    // 省略无关代码...
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在双花括号中的过滤器它属于存在于标签文本中，那么写在该处的过滤器就需要在处理标签文本时进行解析。我们知道，在<code>HTML</code>解析器<code>parseHTML</code>函数中，当遇到文本信息时会调用<code>parseHTML</code>函数的<code>chars</code>钩子函数，在<code>chars</code>钩子函数内部又会调用文本解析器<code>parseText</code>函数对文本进行解析，而写在该处的过滤器它就是存在于文本中，所以在文本解析器<code>parseText</code>函数中调用过滤器解析器<code>parseFilters</code>函数对写在该处的过滤器进行解析，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function parseText (text,delimiters){
    // 省略无关代码...
    const exp = parseFilters(match[1].trim())
    // 省略无关代码...
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>parseFilters 函数分析</strong></p> <p><code>parseFilters</code>函数的定义位于源码的<code>src/complier/parser/filter-parser.js</code>文件中，其代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function parseFilters (exp) {
  let inSingle = false                     // exp是否在 '' 中
  let inDouble = false                     // exp是否在 &quot;&quot; 中
  let inTemplateString = false             // exp是否在 `` 中
  let inRegex = false                      // exp是否在 \\ 中
  let curly = 0                            // 在exp中发现一个 { 则curly加1，发现一个 } 则curly减1，直到culy为0 说明 { ... }闭合
  let square = 0                           // 在exp中发现一个 [ 则curly加1，发现一个 ] 则curly减1，直到culy为0 说明 [ ... ]闭合
  let paren = 0                            // 在exp中发现一个 ( 则curly加1，发现一个 ) 则curly减1，直到culy为0 说明 ( ... )闭合
  let lastFilterIndex = 0
  let c, prev, i, expression, filters


  for (i = 0; i &lt; exp.length; i++) {
    prev = c
    c = exp.charCodeAt(i)
    if (inSingle) {
      if (c === 0x27 &amp;&amp; prev !== 0x5C) inSingle = false
    } else if (inDouble) {
      if (c === 0x22 &amp;&amp; prev !== 0x5C) inDouble = false
    } else if (inTemplateString) {
      if (c === 0x60 &amp;&amp; prev !== 0x5C) inTemplateString = false
    } else if (inRegex) {
      if (c === 0x2f &amp;&amp; prev !== 0x5C) inRegex = false
    } else if (
      c === 0x7C &amp;&amp; // pipe
      exp.charCodeAt(i + 1) !== 0x7C &amp;&amp;
      exp.charCodeAt(i - 1) !== 0x7C &amp;&amp;
      !curly &amp;&amp; !square &amp;&amp; !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1
        expression = exp.slice(0, i).trim()
      } else {
        pushFilter()
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // &quot;
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        let j = i - 1
        let p
        // find first non-whitespace prev char
        for (; j &gt;= 0; j--) {
          p = exp.charAt(j)
          if (p !== ' ') break
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim()
  } else if (lastFilterIndex !== 0) {
    pushFilter()
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim())
    lastFilterIndex = i + 1
  }

  if (filters) {
    for (i = 0; i &lt; filters.length; i++) {
      expression = wrapFilter(expression, filters[i])
    }
  }

  return expression
}

function wrapFilter (exp: string, filter: string): string {
  const i = filter.indexOf('(')
  if (i &lt; 0) {
    // _f: resolveFilter
    return `_f(&quot;${filter}&quot;)(${exp})`
  } else {
    const name = filter.slice(0, i)
    const args = filter.slice(i + 1)
    return `_f(&quot;${name}&quot;)(${exp}${args !== ')' ? ',' + args : args}`
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br></div></div><p>该函数的作用的是将传入的形如<code>'message | capitalize'</code>这样的过滤器字符串转化成<code>_f(&quot;capitalize&quot;)(message)</code>，接下来我们就来分析一下其内部逻辑。</p> <p>在该函数内部，首先定义了一些变量，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let inSingle = false
let inDouble = false
let inTemplateString = false
let inRegex = false
let curly = 0
let square = 0
let paren = 0
let lastFilterIndex = 0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>inSingle：标志 exp 是否在<code>'...'</code>中；</li> <li>inDouble：标志 exp 是否在<code>&quot;...&quot;</code>中；</li> <li>inTemplateString：标志 <code>exp</code> 是否在<code>...</code>中；</li> <li>inRegex：标志 exp 是否在<code>\...\</code>中；</li> <li>curly = 0：在 exp 中发现一个（则 curly 加 1，发现一个）由 curly 减 1，直到 culy 为 0 说明<code>{...}</code>闭合；</li> <li>square = 0：在 exp 中发现一个（则 curly 加 1，发现一个）则 curly 减 1，直到 curly 为 0 说明 <code>[ ... ]</code>闭合；</li> <li>paren = 0：在 exp 中发现一个（则 curly 加 1，发现一个）</li> <li>lastFilterIndex = 0：解析游标，每循环过一个字符串游标加 1；</li></ul> <p>从头开始遍历传入的<code>exp</code>每一个字符，通过判断每一个字符是否是字符（如<code>'</code>，<code>&quot;</code>，<code>{</code>，<code>}</code>，<code>[</code>，<code>]</code>，<code>(</code>，<code>)</code>，<code>\</code>，<code>|</code>）进而判断出<code>exp</code>字符串中哪些部分是表达式，哪些部分是过滤器<code>id</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (i = 0; i &lt; exp.length; i++) {
    prev = c
    c = exp.charCodeAt(i)
    if (inSingle) {
        if (c === 0x27 &amp;&amp; prev !== 0x5C) inSingle = false
    } else if (inDouble) {
        if (c === 0x22 &amp;&amp; prev !== 0x5C) inDouble = false
    } else if (inTemplateString) {
        if (c === 0x60 &amp;&amp; prev !== 0x5C) inTemplateString = false
    } else if (inRegex) {
        if (c === 0x2f &amp;&amp; prev !== 0x5C) inRegex = false
    } else if (
        c === 0x7C &amp;&amp; // pipe
        exp.charCodeAt(i + 1) !== 0x7C &amp;&amp;
        exp.charCodeAt(i - 1) !== 0x7C &amp;&amp;
        !curly &amp;&amp; !square &amp;&amp; !paren
    ) {
        if (expression === undefined) {
            // first filter, end of expression
            lastFilterIndex = i + 1
            expression = exp.slice(0, i).trim()
        } else {
            pushFilter()
        }
    } else {
        switch (c) {
            case 0x22: inDouble = true; break         // &quot;
            case 0x27: inSingle = true; break         // '
            case 0x60: inTemplateString = true; break // `
            case 0x28: paren++; break                 // (
            case 0x29: paren--; break                 // )
            case 0x5B: square++; break                // [
            case 0x5D: square--; break                // ]
            case 0x7B: curly++; break                 // {
            case 0x7D: curly--; break                 // }
        }
        if (c === 0x2f) { // /
            let j = i - 1
            let p
            // find first non-whitespace prev char
            for (; j &gt;= 0; j--) {
                p = exp.charAt(j)
                if (p !== ' ') break
            }
            if (!p || !validDivisionCharRE.test(p)) {
                inRegex = true
            }
        }
    }
}

if (expression === undefined) {
    expression = exp.slice(0, i).trim()
} else if (lastFilterIndex !== 0) {
    pushFilter()
}

function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim())
    lastFilterIndex = i + 1
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br></div></div><p><code>ASCII</code>码与字符的对应关系，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>0x22 ----- &quot;
0x27 ----- '
0x28 ----- (
0x29 ----- )
0x2f ----- /
0x5C ----- \
0x5B ----- [
0x5D ----- ]
0x60 ----- `
0x7C ----- |
0x7B ----- {
0x7D ----- }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>上述代码的逻辑就是将字符串<code>exp</code>的每一个字符都从前往后开始一个一个匹配，匹配出那些特殊字符，如<code>'</code>，<code>&quot;</code>，<code>{</code>，<code>}</code>，<code>[</code>，<code>]</code>，<code>(</code>，<code>)</code>，<code>\</code>，<code>|</code>。</p> <p>如果匹配到<code>'</code>，<code>&quot;</code>字符，说明当前字符在字符串中，那么直到匹配到下一个同样的字符才结束，同时， 匹配 <code>()</code>, <code>{}</code>,<code>[]</code> 这些需要两边相等闭合, 那么匹配到的 | 才被认为是过滤器中的<code>|</code>。</p> <p>当匹配到过滤器中的|符时，那么|符前面的字符串就认为是待处理的表达式，将其存储在 <code>expression</code> 中，后面继续匹配，如果再次匹配到过滤器中的 |符 ,并且此时<code>expression</code>有值， 那么说明后面还有第二个过滤器，那么此时两个|符之间的字符串就是第一个过滤器的<code>id</code>，此时调用 <code>pushFilter</code>函数将第一个过滤器添加进<code>filters</code>数组中。举个例子：</p> <p>假如有如下过滤器字符串：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>message | filter1 | filter2(arg)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>那么它的匹配过程如下图所示：</p> <p><img src="vue27.jpg" alt="imags"></p> <p>将上例中的过滤器字符串都匹配完毕后，会得到如下结果：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>expression = message
filters = ['filter1','filter2(arg)']
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>接下来遍历得到的<code>filters</code>数组，并将数组的每一个元素及<code>expression</code>传给<code>wrapFilter</code>函数，用来生成最终的<code>_f</code>函数调用字符串，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (filters) {
    for (i = 0; i &lt; filters.length; i++) {
        expression = wrapFilter(expression, filters[i])
    }
}

function wrapFilter (exp, filter) {
  const i = filter.indexOf('(')
  if (i &lt; 0) {
    return `_f(&quot;${filter}&quot;)(${exp})`
  } else {
    const name = filter.slice(0, i)
    const args = filter.slice(i + 1)
    return `_f(&quot;${name}&quot;)(${exp}${args !== ')' ? ',' + args : args}`
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>可以看到， 在<code>wrapFilter</code>函数中，首先在解析得到的每个过滤器中查找是否有<code>(</code>，以此来判断过滤器中是否接收了参数，如果没有<code>(</code>，表示该过滤器没有接收参数，则直接构造<code>_f</code>函数调用字符串即<code>_f(&quot;filter1&quot;)(message)</code>并返回赋给<code>expression</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const i = filter.indexOf('(')
if (i &lt; 0) {
    return `_f(&quot;${filter}&quot;)(${exp})`
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>接着，将新的<code>experssion</code>与<code>filters</code>数组中下一个过滤器再调用<code>wrapFilter</code>函数,如果下一个过滤器有参数，那么先取出过滤器<code>id</code>，再取出其带有的参数，生成第二个过滤器的_f 函数调用字符串，即<code>_f(&quot;filter2&quot;)(_f(&quot;filter1&quot;)(message),arg)</code>，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const name = filter.slice(0, i)
const args = filter.slice(i + 1)
return `_f(&quot;${name}&quot;)(${exp}${args !== ')' ? ',' + args : args}`
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这样就最终生成了用户所写的过滤器的<code>_f</code>函数调用字符串。</p> <p><strong>小结</strong></p> <p>首先，我们介绍了两种不同写法的过滤会在不同的地方进行解析，但解析原理都是相同的，都是调用过滤器解析器<code>parseFilters</code>函数进行解析。</p> <p>接着我们分析了<code>parseFilters</code>函数的内部逻辑。该函数接收一个形如<code>'message | capitalize'</code>这样的过滤器字符串作为，最终将其转化成<code>_f(&quot;capitalize&quot;)(message)</code>输出。在<code>parseFilters</code>函数内部是通过遍历传入的过滤器字符串每一个字符，根据每一个字符是否是一些特殊的字符从而作出不同的处理，最终，从传入的过滤器字符串中解析出待处理的表达式<code>expression</code>和所有的过滤器<code>filters</code>数组。</p> <p>最后，将解析得到的<code>expression</code>和<code>filters</code>数组通过调用<code>wrapFilter</code>函数将其构造成<code>_f</code>函数调用字符串。</p> <h3 id="九、指令篇"><a href="#九、指令篇" aria-hidden="true" class="header-anchor">#</a> 九、指令篇</h3> <p>在<code>Vue</code>中，除了<code>Vue</code>本身为我们提供的一些内置指令之外，<code>Vue</code>还支持用户自定义指令。并且用户有两种定义的方式：一种是使用全局 API——<code>Vue.directive</code>来定义全局指令，这种方式定义的指令会被存放在<code>Vue.options['directives']</code>中；另一种是在组件内的<code>directive</code>选项专为该组件使用的局部指令，这种方式定义的指令会被存放在<code>vm.$options['directives']</code>中。</p> <h4 id="_9-1-何时生效"><a href="#_9-1-何时生效" aria-hidden="true" class="header-anchor">#</a> 9.1 何时生效</h4> <p>指令是作为标签属性写在模板中的 HTML 标签上的，那么又回到那句老话了，既然是写在模板中的，那它必然会经过模板编译，编译之后会产生虚拟 DOM，在虚拟 DOM 渲染更新时，除了更新节点的内容之外，节点上的一些指令、事件等内容也需要更新。另外，我们还知道，虚拟 DOM 节点的更新不只是更新一个已有的节点，也有可能是创建一个新的节点，还有可能是删除一个节点等等，这些都叫做虚拟 DOM 节点的更新。</p> <p>在虚拟<code>DOM</code>渲染更新的时候，它在执行相关操作的同时，还会在每个阶段触发相应的钩子函数，我们只需监听不同的钩子函数，就可以在虚拟<code>DOM</code>渲染更新的不同阶段做一些额外的事情。下表给出了虚拟<code>DOM</code> 在渲染更新的不同阶段所触发的不同的钩子函数及其触发时机：</p> <table><thead><tr><th>钩子函数名称</th> <th>触发时机</th> <th>回调参数</th></tr></thead> <tbody><tr><td>init</td> <td>已创建 VNode，在 patch 期间发现新的虚拟节点时被触发</td> <td>VNode</td></tr> <tr><td>create</td> <td>已基于 VNode 创建了 DOM 元素</td> <td>emptyNode 和 VNode</td></tr> <tr><td>activate</td> <td>keep-alive 组件被创建</td> <td>emptyNode 和 innerNode</td></tr> <tr><td>insert</td> <td>VNode 对应的</td> <td>VNode</td></tr> <tr><td>prepatch</td> <td>已创建 VNode，在 patch 期间发现新的虚拟节点时被触发</td> <td>VNode</td></tr> <tr><td>update</td> <td>已创建 VNode，在 patch 期间发现新的虚拟节点时被触发</td> <td>VNode</td></tr> <tr><td>postpatch</td> <td>已创建 VNode，在 patch 期间发现新的虚拟节点时被触发</td> <td>VNode</td></tr> <tr><td>destory</td> <td>已创建 VNode，在 patch 期间发现新的虚拟节点时被触发</td> <td>VNode</td></tr> <tr><td>remove</td> <td>已创建 VNode，在 patch 期间发现新的虚拟节点时被触发</td> <td>VNode</td></tr></tbody></table> <h4 id="_9-2-指令钩子函数"><a href="#_9-2-指令钩子函数" aria-hidden="true" class="header-anchor">#</a> 9.2 指令钩子函数</h4> <p><code>Vue</code>对于自定义指令定义对象提供了几个钩子函数，这几个钩子函数分别对应着指令的几种状态，一个指令从第一次被绑定到元素上到最终与被绑定的元素解绑，它会经过以下几种状态：</p> <ul><li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li> <li>inserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</li> <li>update：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong></li> <li>componentUpdated：指令所在组件的 VNode<strong>及其子 VNode</strong>全部更新后调用。</li> <li>unbind：只调用一次，指令与元素解绑时调用。</li></ul> <p>有了每个状态的钩子函数，这样我们就可以让指令在不同状态下做不同的事件。</p> <h4 id="_9-3-如何生效"><a href="#_9-3-如何生效" aria-hidden="true" class="header-anchor">#</a> 9.3 如何生效</h4> <p>当虚拟<code>DOM</code>渲染更新的时候会触发<code>create</code>、<code>update</code>、<code>destory</code>这三个钩子函数，从而就会执行<code>updateDirectives</code>函数来处理指令的想着逻辑，执行指令函数，让指令生效。</p> <p><code>updateDirectives</code>函数的定义位于源码的<code>src/core/vdom/modules/directives.js</code>文件中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function updateDirectives (oldVnode: VNodeWithData, vnode: VNodeWithData) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode)
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>该函数的内部是判断了如果新旧<code>VNode</code>中只要有一方涉及到指令，那就调用<code>_update</code>方法去处理指令逻辑。</p> <p><code>_update</code>方法定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function _update (oldVnode, vnode) {
  const isCreate = oldVnode === emptyNode
  const isDestroy = vnode === emptyNode
  const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context)
  const newDirs = normalizeDirectives(vnode.data.directives, vnode.context)

  const dirsWithInsert = []
  const dirsWithPostpatch = []

  let key, oldDir, dir
  for (key in newDirs) {
    oldDir = oldDirs[key]
    dir = newDirs[key]
    if (!oldDir) {
      // new directive, bind
      callHook(dir, 'bind', vnode, oldVnode)
      if (dir.def &amp;&amp; dir.def.inserted) {
        dirsWithInsert.push(dir)
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value
      dir.oldArg = oldDir.arg
      callHook(dir, 'update', vnode, oldVnode)
      if (dir.def &amp;&amp; dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir)
      }
    }
  }

  if (dirsWithInsert.length) {
    const callInsert = () =&gt; {
      for (let i = 0; i &lt; dirsWithInsert.length; i++) {
        callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode)
      }
    }
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert)
    } else {
      callInsert()
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', () =&gt; {
      for (let i = 0; i &lt; dirsWithPostpatch.length; i++) {
        callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode)
      }
    })
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy)
      }
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br></div></div><p>可以看到，该方法内首先定义了一些变量，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const isCreate = oldVnode === emptyNode
const isDestroy = vnode === emptyNode
const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context)
const newDirs = normalizeDirectives(vnode.data.directives, vnode.context)

const dirsWithInsert = []
const dirsWithPostpatch = []
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>isCreate：判断当前节点<code>vnode</code>对应的旧节点<code>oldVnode</code>是不是一个空节点，如果是的话，表明当前节点是一个新创建的节点。</li> <li>isDestroy：判断当前节点<code>vnode</code>是不是一个空节点，如果是的话，表明当前节点对应的旧节点将要被销毁。</li> <li>oldDirs：旧的指令集合，即<code>oldVnode</code>中保存的指令。</li> <li>newDirs：新的指令集合，即<code>vnode</code>中保存的指令。</li> <li>dirsWithInsert：保存需要触发<code>inserted</code>指令钩子函数的指令列表。</li> <li>dirsWidthPostpatch：保存需要触发<code>componentUpdated</code>指令钩子函数的指令列表。</li></ul> <p>另外，你可能还看到了在定义新旧指令集合的变量中调用了<code>normalizeDirectives</code>函数，其实该函数是用来模板中使用到的指令从存放指令的地方取出来，并将其格式进行统一化，其定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function normalizeDirectives (dirs,vm):  {
  const res = Object.create(null)
  if (!dirs) {
    return res
  }
  let i, dir
  for (i = 0; i &lt; dirs.length; i++) {
    dir = dirs[i]
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers
    }
    res[getRawDirName(dir)] = dir
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true)
  }
  return res
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><code>v-focus</code>指令为例，通过<code>normalizeDirectives</code>函数取出的指令会变成如下样子：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    'v-focus':{
        name : 'focus' ,  // 指令的名称
        value : '',       // 指令的值
        arg:'',           // 指令的参数
        modifiers:{},     // 指令的修饰符
        def:{
            inserted:fn
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>获取到<code>oldDirs</code>和<code>newDirs</code>之后，接下来要做的事件就是对比这两个指令集合并触发对应的指令钩子函数。</p> <p>首先，循环<code>newDirs</code>，并分别从<code>oldDirs</code>和<code>newDirs</code>取出当前循环的指令分别保存在变量<code>oldDir</code>和<code>dir</code>中，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let key, oldDir, dir
for (key in newDirs) {
    oldDir = oldDirs[key]
    dir = newDirs[key]
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>然后判断当前循环到的指令循环的指令名<code>key</code>在旧的指令列表<code>oldDirs</code>中是否存在，说明该指令是首次绑定到元素上的一个新指令，此时调用<code>callHook</code>触发指令中的<code>bind</code>钩子函数，接着判断如果该新指令在定义时设置了<code>inserted</code>钩子函数，那么将该指令添加到<code>dirsWithInsert</code>中，以保证执行完所有指令的<code>bind</code>钩子函数后再执行指令的<code>inserted</code>钩子函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 判断当前循环到的指令名`key`在旧的指令列表`oldDirs`中是否存在，如果不存在，那么说明这是一个新的指令
if (!oldDir) {
    // new directive, bind
    // 触发指令中的`bind`钩子函数
    callHook(dir, 'bind', vnode, oldVnode)
    // 如果定义了inserted 时的钩子函数 那么将该指令添加到dirsWithInsert中
    if (dir.def &amp;&amp; dir.def.inserted) {
        dirsWithInsert.push(dir)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>如果当前循环到的指令名<code>key</code>在旧的指令列表<code>oldDirs</code>中存在时，说明该指令在之前已经绑定过了，那么这一次的操作应该是更新指令。</p> <p>首先，在<code>dir</code>上添加<code>oldValue</code>属性和<code>oldArg</code>属性，用来保存上一次指令的<code>value</code>属性值和<code>arg</code>属性值，然后调用<code>callHook</code>触发指令的<code>update</code>钩子函数，接着判断如果该指令在定义时设置了<code>componentUpdated</code>钩子函数，那么将该指令添加到<code>dirsWithPostpatch</code>中，以保证指令所在的组件的<code>VNode</code>及其子<code>VNode</code>全部更新完后再执行指令的<code>componentUpdated</code>钩子函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>else {
    // existing directive, update
    dir.oldValue = oldDir.value
    dir.oldArg = oldDir.arg
    callHook(dir, 'update', vnode, oldVnode)
    if (dir.def &amp;&amp; dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>最后，判断<code>dirsWidthInsert</code>数组中是否有元素，如果有，则循环<code>dirsWidthInsert</code>数组，依次执行每一个指令的<code>inserted</code>钩子函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (dirsWithInsert.length) {
    const callInsert = () =&gt; {
        for (let i = 0; i &lt; dirsWithInsert.length; i++) {
            callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode)
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>从上述代码中可以看到，并没有直接去循环执行每一个指令的<code>inserted</code>钩子函数，而是新创建了一个<code>callInsert</code>函数，当执行该函数的时候才会去循环每一个指令的<code>inserted</code>钩子函数。这又是为什么呢？</p> <p>这是因为指令的<code>inserted</code>钩子函数必须在被绑定元素插入到父节点时调用，那么如果是一个新增的节点，如何保证它已经被插入到父节点了呢？我们之前说过，虚拟<code>DOM</code>在渲染更新的不同阶段会触发不同的钩子函数，比如当<code>DOM</code>节点在被插入到父节点时会触发<code>insert</code>函数，那么我们就知道了，当虚拟<code>DOM</code>渲染更新的<code>insert</code>钩子函数被调用的时候就标志着当前节点已经被插入到父节点了，所以我们要在虚拟<code>DOM</code>渲染更新的<code>insert</code>钩子函数内执行指令的 <code>inserted</code> 钩子函数。也就是说，当一个新创建的元素被插入到父节点中时虚拟 <code>DOM</code> 渲染更新的 <code>insert</code> 钩子函数和指令的 <code>inserted</code> 钩子函数都要被触发。既然如此，那就可以把这两个钩子函数通过调用 <code>mergeVNodeHook</code> 方法进行合并，然后统一在虚拟 <code>DOM</code> 渲染更新的 <code>insert</code> 钩子函数中触发，这样就保证了元素确实被插入到父节点中才执行的指令的 <code>inserted</code> 钩子函数，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (dirsWithInsert.length) {
    const callInsert = () =&gt; {
        for (let i = 0; i &lt; dirsWithInsert.length; i++) {
            callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode)
        }
    }
    if (isCreate) {
        mergeVNodeHook(vnode, 'insert', callInsert)
    } else {
        callInsert()
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>同理，我们也需要保证指令所在的组件的<code>VNode</code>及其子全部更新完后再执行指令的<code>componentUpdated</code>钩子函数，所以我们将虚拟<code>DOM</code>渲染更新的<code>postpatch</code>钩子函数和指令的<code>componentUpdated</code>钩子函数进行合并触发，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', () =&gt; {
        for (let i = 0; i &lt; dirsWithPostpatch.length; i++) {
            callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode)
        }
    })
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>最后，当<code>newDirs</code>循环完毕后，再循环<code>oldDirs</code>，如果某个指令存在于旧的指令列表<code>oldDirs</code>而在新的指令列表<code>newDirs</code>中不存在，那说明该指令是被废弃的，所以则触发指令的<code>unbind</code>钩子函数对指令进行解绑。如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (!isCreate) {
    for (key in oldDirs) {
        if (!newDirs[key]) {
            // no longer present, unbind
            callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy)
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>总结</strong></p> <p>首先，我们知道了如果一个<code>DOM</code>节点上绑定了指令，那么在这个<code>DOM</code>节点所对应虚拟<code>DOM</code>节点进行渲染更新的时候，不但会处理节点渲染更新的逻辑，还会处理节点上指令的相关逻辑。具体处理指令逻辑的时机是在虚拟<code>DOM</code>渲染更新的<code>create</code>、<code>update</code>、<code>destory</code>阶段。</p> <p>接着，我们介绍了<code>Vue</code>对于自定义指令对象提供了几个钩子函数，这几个钩子函数分别对应着指令的几种状态；我们可以根据实际的需求将指令逻辑写在合适的指令状态的钩子函数中，比如，我们想让指令所绑定的元素一插入到<code>DOM</code>中就执行指令逻辑，那我们就应该把指令逻辑写在指令的<code>inserted</code>钩子函数中。</p> <p>接着，我们逐行分析了<code>updateDirectives</code>函数，在该函数中就是对比新旧两份<code>VNode</code>上的指令列表，通过对比的异同点从而执行指令不同的钩子函数，让指令生效。</p> <p>最后，一句话概括就是：<strong>所谓让指令生效，其实就是在合适的时机执行定义指令时所设置的钩子函数</strong>。</p> <h3 id="十、总结"><a href="#十、总结" aria-hidden="true" class="header-anchor">#</a> 十、总结</h3> <p><img src="vue-code.png" alt="images"></p> <h3 id="参考资料"><a href="#参考资料" aria-hidden="true" class="header-anchor">#</a> 参考资料</h3> <ul><li><a href="https://github.com/muwoo/blogs" target="_blank" rel="noopener noreferrer">vue 源码分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://hcysun.me/vue-design/art/" target="_blank" rel="noopener noreferrer">Vue 技术内幕<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener noreferrer">Vue.js 技术揭秘<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener noreferrer">Vue.js 源码解析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/dirkhe1051931999/hjBlog/tree/master/blog-vue-sourcecode-study" target="_blank" rel="noopener noreferrer">你想要的 vue 源码分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5ce5565d6fb9a07ed2244513" target="_blank" rel="noopener noreferrer">学习 Vue 源码的必要知识储备<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://nlrx-wjc.github.io/Learn-Vue-Source-Code/start/" target="_blank" rel="noopener noreferrer">逐行剖析 Vue.js 源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener noreferrer">渲染器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.cnblogs.com/tugenhua0707/category/1577630.html" target="_blank" rel="noopener noreferrer">深入 Vue 技术栈及源码系列<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://www.zhufengpeixun.cn/train/vue-info/source.html" target="_blank" rel="noopener noreferrer">Vue 原理剖析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/lihongxun945/myblog/issues/22" target="_blank" rel="noopener noreferrer">Vue2.x 源码解析系列一：我的源码阅读心得<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>《深入浅出 Vue.js》</li></ul> <h2 id="联系作者"><a href="#联系作者" aria-hidden="true" class="header-anchor">#</a> 联系作者</h2> <div align="center"><p>
        平凡世界，贵在坚持。
    </p> <img src="/about/contact.png"></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新于:</span> <span class="time">2020/6/2 下午6:25:23</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/js/vue-vuex-code.html" class="prev">vue-vuex 源码分析</a></span> <!----></p></div> </main></div><div class="global-ui"><!----><!----><div></div></div></div>
    <script src="/assets/js/app.e6aa2542.js" defer></script><script src="/assets/js/2.274a054e.js" defer></script><script src="/assets/js/200.63b2f061.js" defer></script><script src="/assets/js/3.65dbdf4c.js" defer></script>
  </body>
</html>
