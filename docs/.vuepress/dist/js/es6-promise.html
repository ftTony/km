<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Promise 对象 | 小武子知识库</title>
    <meta name="description" content="用心，谈技术。大前端">
    <link rel="icon" href="/hero.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.56546b06.css" as="style"><link rel="preload" href="/assets/js/app.317e8fe1.js" as="script"><link rel="preload" href="/assets/js/2.67134772.js" as="script"><link rel="preload" href="/assets/js/105.56f79dba.js" as="script"><link rel="preload" href="/assets/js/3.65dbdf4c.js" as="script"><link rel="prefetch" href="/assets/js/10.51212818.js"><link rel="prefetch" href="/assets/js/100.5b285a6b.js"><link rel="prefetch" href="/assets/js/101.8453c7cc.js"><link rel="prefetch" href="/assets/js/102.82f0adf3.js"><link rel="prefetch" href="/assets/js/103.34f049f4.js"><link rel="prefetch" href="/assets/js/104.cacff51d.js"><link rel="prefetch" href="/assets/js/106.bcfbec74.js"><link rel="prefetch" href="/assets/js/107.7a474f46.js"><link rel="prefetch" href="/assets/js/108.cb679908.js"><link rel="prefetch" href="/assets/js/109.f08efba1.js"><link rel="prefetch" href="/assets/js/11.8d51635e.js"><link rel="prefetch" href="/assets/js/110.557adc0d.js"><link rel="prefetch" href="/assets/js/111.0ef5c9a9.js"><link rel="prefetch" href="/assets/js/112.b00a391b.js"><link rel="prefetch" href="/assets/js/113.dd2045c3.js"><link rel="prefetch" href="/assets/js/114.8a56bfdc.js"><link rel="prefetch" href="/assets/js/115.4a0a0bc6.js"><link rel="prefetch" href="/assets/js/116.1325243b.js"><link rel="prefetch" href="/assets/js/117.c190cf64.js"><link rel="prefetch" href="/assets/js/118.23981b43.js"><link rel="prefetch" href="/assets/js/119.4fb6f74f.js"><link rel="prefetch" href="/assets/js/12.24bb78b4.js"><link rel="prefetch" href="/assets/js/120.dd2613f9.js"><link rel="prefetch" href="/assets/js/121.fce160e6.js"><link rel="prefetch" href="/assets/js/122.5d8d6e2b.js"><link rel="prefetch" href="/assets/js/123.e41c816e.js"><link rel="prefetch" href="/assets/js/124.390253f6.js"><link rel="prefetch" href="/assets/js/125.978c9d46.js"><link rel="prefetch" href="/assets/js/126.0c259ad1.js"><link rel="prefetch" href="/assets/js/127.1df0e89b.js"><link rel="prefetch" href="/assets/js/128.62c4b786.js"><link rel="prefetch" href="/assets/js/129.0e9ff0ee.js"><link rel="prefetch" href="/assets/js/13.739a8c4b.js"><link rel="prefetch" href="/assets/js/130.f178d1bd.js"><link rel="prefetch" href="/assets/js/131.defeae62.js"><link rel="prefetch" href="/assets/js/132.a08299c1.js"><link rel="prefetch" href="/assets/js/133.4a1f3b36.js"><link rel="prefetch" href="/assets/js/134.1b9f1bb4.js"><link rel="prefetch" href="/assets/js/135.33f72f44.js"><link rel="prefetch" href="/assets/js/136.7870c0e7.js"><link rel="prefetch" href="/assets/js/137.41abeb0d.js"><link rel="prefetch" href="/assets/js/138.b14d1ba6.js"><link rel="prefetch" href="/assets/js/139.d91f89c7.js"><link rel="prefetch" href="/assets/js/14.8b13601f.js"><link rel="prefetch" href="/assets/js/140.967b27ae.js"><link rel="prefetch" href="/assets/js/141.0cf51511.js"><link rel="prefetch" href="/assets/js/142.e84d1759.js"><link rel="prefetch" href="/assets/js/143.cd3171ad.js"><link rel="prefetch" href="/assets/js/144.f3042181.js"><link rel="prefetch" href="/assets/js/145.d488de38.js"><link rel="prefetch" href="/assets/js/146.1d599960.js"><link rel="prefetch" href="/assets/js/147.bcfbeb60.js"><link rel="prefetch" href="/assets/js/148.b1a78358.js"><link rel="prefetch" href="/assets/js/149.33574f1f.js"><link rel="prefetch" href="/assets/js/15.71112d0f.js"><link rel="prefetch" href="/assets/js/150.bdc6407c.js"><link rel="prefetch" href="/assets/js/151.b9e41604.js"><link rel="prefetch" href="/assets/js/152.ebfe2461.js"><link rel="prefetch" href="/assets/js/153.83066f9c.js"><link rel="prefetch" href="/assets/js/154.148d48ac.js"><link rel="prefetch" href="/assets/js/155.3f966844.js"><link rel="prefetch" href="/assets/js/156.e25bac41.js"><link rel="prefetch" href="/assets/js/157.945b30f0.js"><link rel="prefetch" href="/assets/js/158.177791ec.js"><link rel="prefetch" href="/assets/js/159.5412d214.js"><link rel="prefetch" href="/assets/js/16.0ec647a8.js"><link rel="prefetch" href="/assets/js/160.762bb636.js"><link rel="prefetch" href="/assets/js/161.e5cabb60.js"><link rel="prefetch" href="/assets/js/162.93ebb0b4.js"><link rel="prefetch" href="/assets/js/163.2372d351.js"><link rel="prefetch" href="/assets/js/164.bff482b7.js"><link rel="prefetch" href="/assets/js/165.77c96470.js"><link rel="prefetch" href="/assets/js/166.d180b784.js"><link rel="prefetch" href="/assets/js/167.957514a1.js"><link rel="prefetch" href="/assets/js/168.e6bb1602.js"><link rel="prefetch" href="/assets/js/169.87c2f501.js"><link rel="prefetch" href="/assets/js/17.fe813512.js"><link rel="prefetch" href="/assets/js/170.315907bd.js"><link rel="prefetch" href="/assets/js/171.1dd289a5.js"><link rel="prefetch" href="/assets/js/172.522ea95a.js"><link rel="prefetch" href="/assets/js/173.25bcf534.js"><link rel="prefetch" href="/assets/js/174.e9c810c5.js"><link rel="prefetch" href="/assets/js/175.287dfdd5.js"><link rel="prefetch" href="/assets/js/176.8fa6ea39.js"><link rel="prefetch" href="/assets/js/177.3a2098af.js"><link rel="prefetch" href="/assets/js/178.7315add5.js"><link rel="prefetch" href="/assets/js/179.3e3b9ab3.js"><link rel="prefetch" href="/assets/js/18.659924a5.js"><link rel="prefetch" href="/assets/js/180.ada782c3.js"><link rel="prefetch" href="/assets/js/181.e7fdf9b0.js"><link rel="prefetch" href="/assets/js/182.a7a728c3.js"><link rel="prefetch" href="/assets/js/183.17c4ba49.js"><link rel="prefetch" href="/assets/js/184.49875401.js"><link rel="prefetch" href="/assets/js/185.aaf0b66b.js"><link rel="prefetch" href="/assets/js/186.306ef53d.js"><link rel="prefetch" href="/assets/js/187.de85ecf4.js"><link rel="prefetch" href="/assets/js/188.c2cecbc3.js"><link rel="prefetch" href="/assets/js/189.0dadb7d7.js"><link rel="prefetch" href="/assets/js/19.9bc16e66.js"><link rel="prefetch" href="/assets/js/190.5f30ed64.js"><link rel="prefetch" href="/assets/js/191.8b37387a.js"><link rel="prefetch" href="/assets/js/192.a07b8570.js"><link rel="prefetch" href="/assets/js/193.8c20bf70.js"><link rel="prefetch" href="/assets/js/194.eb7f22d0.js"><link rel="prefetch" href="/assets/js/195.76ef8b6d.js"><link rel="prefetch" href="/assets/js/196.c8b7f01f.js"><link rel="prefetch" href="/assets/js/197.6b585738.js"><link rel="prefetch" href="/assets/js/198.c106fcb5.js"><link rel="prefetch" href="/assets/js/199.d474daed.js"><link rel="prefetch" href="/assets/js/20.5da7c682.js"><link rel="prefetch" href="/assets/js/200.3a5c3ef4.js"><link rel="prefetch" href="/assets/js/201.6a66f7f3.js"><link rel="prefetch" href="/assets/js/202.4ebd9828.js"><link rel="prefetch" href="/assets/js/203.5572b70e.js"><link rel="prefetch" href="/assets/js/204.08ef034b.js"><link rel="prefetch" href="/assets/js/205.3331baad.js"><link rel="prefetch" href="/assets/js/206.3bdcb31a.js"><link rel="prefetch" href="/assets/js/207.81ed362f.js"><link rel="prefetch" href="/assets/js/208.6bc0ae76.js"><link rel="prefetch" href="/assets/js/209.3cf0d67e.js"><link rel="prefetch" href="/assets/js/21.a884b92d.js"><link rel="prefetch" href="/assets/js/210.50f402df.js"><link rel="prefetch" href="/assets/js/211.db22db74.js"><link rel="prefetch" href="/assets/js/212.1676d088.js"><link rel="prefetch" href="/assets/js/213.0e8b03f0.js"><link rel="prefetch" href="/assets/js/214.c4c796f6.js"><link rel="prefetch" href="/assets/js/215.f4923d79.js"><link rel="prefetch" href="/assets/js/216.a127c867.js"><link rel="prefetch" href="/assets/js/217.270726ca.js"><link rel="prefetch" href="/assets/js/218.53ae0272.js"><link rel="prefetch" href="/assets/js/219.6d7ea89b.js"><link rel="prefetch" href="/assets/js/22.0aff44b6.js"><link rel="prefetch" href="/assets/js/220.ef994822.js"><link rel="prefetch" href="/assets/js/221.ed0fc04e.js"><link rel="prefetch" href="/assets/js/222.490688f9.js"><link rel="prefetch" href="/assets/js/223.c76bd366.js"><link rel="prefetch" href="/assets/js/224.1bf6e862.js"><link rel="prefetch" href="/assets/js/225.5060586a.js"><link rel="prefetch" href="/assets/js/23.6bf73bcf.js"><link rel="prefetch" href="/assets/js/24.f8599c7f.js"><link rel="prefetch" href="/assets/js/25.0a717abe.js"><link rel="prefetch" href="/assets/js/26.247a1740.js"><link rel="prefetch" href="/assets/js/27.57ebe0d3.js"><link rel="prefetch" href="/assets/js/28.0b23d8e7.js"><link rel="prefetch" href="/assets/js/29.78a9d581.js"><link rel="prefetch" href="/assets/js/30.f55e017e.js"><link rel="prefetch" href="/assets/js/31.cd48cabe.js"><link rel="prefetch" href="/assets/js/32.25636a63.js"><link rel="prefetch" href="/assets/js/33.e210c275.js"><link rel="prefetch" href="/assets/js/34.aa2b9dc7.js"><link rel="prefetch" href="/assets/js/35.2cfd2f29.js"><link rel="prefetch" href="/assets/js/36.203a2e4d.js"><link rel="prefetch" href="/assets/js/37.0e6620d2.js"><link rel="prefetch" href="/assets/js/38.e7b4f55c.js"><link rel="prefetch" href="/assets/js/39.e0d7fdab.js"><link rel="prefetch" href="/assets/js/4.803c74cf.js"><link rel="prefetch" href="/assets/js/40.16d6d165.js"><link rel="prefetch" href="/assets/js/41.59898b2c.js"><link rel="prefetch" href="/assets/js/42.6d809fcc.js"><link rel="prefetch" href="/assets/js/43.dc810c4f.js"><link rel="prefetch" href="/assets/js/44.17b61651.js"><link rel="prefetch" href="/assets/js/45.f6c75e37.js"><link rel="prefetch" href="/assets/js/46.42ea7905.js"><link rel="prefetch" href="/assets/js/47.ed456b7e.js"><link rel="prefetch" href="/assets/js/48.538607d6.js"><link rel="prefetch" href="/assets/js/49.58a6997e.js"><link rel="prefetch" href="/assets/js/5.444b0f34.js"><link rel="prefetch" href="/assets/js/50.688b2b6e.js"><link rel="prefetch" href="/assets/js/51.d0a99f8b.js"><link rel="prefetch" href="/assets/js/52.87c5385c.js"><link rel="prefetch" href="/assets/js/53.7931d053.js"><link rel="prefetch" href="/assets/js/54.ad80d239.js"><link rel="prefetch" href="/assets/js/55.b0d1df05.js"><link rel="prefetch" href="/assets/js/56.983eb5aa.js"><link rel="prefetch" href="/assets/js/57.ef2e3e14.js"><link rel="prefetch" href="/assets/js/58.550d2ae3.js"><link rel="prefetch" href="/assets/js/59.c63600b1.js"><link rel="prefetch" href="/assets/js/6.b313ca13.js"><link rel="prefetch" href="/assets/js/60.4fae8b05.js"><link rel="prefetch" href="/assets/js/61.711c6d4f.js"><link rel="prefetch" href="/assets/js/62.3e682e5f.js"><link rel="prefetch" href="/assets/js/63.63531e30.js"><link rel="prefetch" href="/assets/js/64.3ba262a2.js"><link rel="prefetch" href="/assets/js/65.c048b23e.js"><link rel="prefetch" href="/assets/js/66.38876418.js"><link rel="prefetch" href="/assets/js/67.3f3dbc43.js"><link rel="prefetch" href="/assets/js/68.ef416d7d.js"><link rel="prefetch" href="/assets/js/69.a7aa265e.js"><link rel="prefetch" href="/assets/js/7.9f48120b.js"><link rel="prefetch" href="/assets/js/70.f5d57ce0.js"><link rel="prefetch" href="/assets/js/71.1541e1ba.js"><link rel="prefetch" href="/assets/js/72.e5ae2d5d.js"><link rel="prefetch" href="/assets/js/73.e39e2c29.js"><link rel="prefetch" href="/assets/js/74.c59b9397.js"><link rel="prefetch" href="/assets/js/75.b1ee900f.js"><link rel="prefetch" href="/assets/js/76.8d3e75a0.js"><link rel="prefetch" href="/assets/js/77.a5737ef3.js"><link rel="prefetch" href="/assets/js/78.fa654373.js"><link rel="prefetch" href="/assets/js/79.398f8e38.js"><link rel="prefetch" href="/assets/js/8.91e99945.js"><link rel="prefetch" href="/assets/js/80.766f414a.js"><link rel="prefetch" href="/assets/js/81.15c61fc8.js"><link rel="prefetch" href="/assets/js/82.8b050cd7.js"><link rel="prefetch" href="/assets/js/83.288ad76c.js"><link rel="prefetch" href="/assets/js/84.9c957078.js"><link rel="prefetch" href="/assets/js/85.6cd1da4d.js"><link rel="prefetch" href="/assets/js/86.91d2339e.js"><link rel="prefetch" href="/assets/js/87.fe54d698.js"><link rel="prefetch" href="/assets/js/88.bde60cf4.js"><link rel="prefetch" href="/assets/js/89.73948a86.js"><link rel="prefetch" href="/assets/js/9.468e6e84.js"><link rel="prefetch" href="/assets/js/90.1ea05676.js"><link rel="prefetch" href="/assets/js/91.49bf8b29.js"><link rel="prefetch" href="/assets/js/92.3ecf1beb.js"><link rel="prefetch" href="/assets/js/93.1e701636.js"><link rel="prefetch" href="/assets/js/94.e5a86652.js"><link rel="prefetch" href="/assets/js/95.d52424df.js"><link rel="prefetch" href="/assets/js/96.12c6de7f.js"><link rel="prefetch" href="/assets/js/97.80f23a18.js"><link rel="prefetch" href="/assets/js/98.9e2ea0f8.js"><link rel="prefetch" href="/assets/js/99.67235967.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56546b06.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">小武子知识库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/js/" class="nav-link router-link-active">javascript</a></div><div class="nav-item"><a href="/css/" class="nav-link">css</a></div><div class="nav-item"><a href="/html5/" class="nav-link">HTML5</a></div><div class="nav-item"><a href="/tool/" class="nav-link">工具</a></div><div class="nav-item"><a href="/project/" class="nav-link">软件工程</a></div><div class="nav-item"><a href="/cs/" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/materials/" class="nav-link">资料收集</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于作者</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/js/" class="nav-link router-link-active">javascript</a></div><div class="nav-item"><a href="/css/" class="nav-link">css</a></div><div class="nav-item"><a href="/html5/" class="nav-link">HTML5</a></div><div class="nav-item"><a href="/tool/" class="nav-link">工具</a></div><div class="nav-item"><a href="/project/" class="nav-link">软件工程</a></div><div class="nav-item"><a href="/cs/" class="nav-link">计算机基础</a></div><div class="nav-item"><a href="/materials/" class="nav-link">资料收集</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于作者</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>javascript基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/es5-expression.html" class="sidebar-link">表达式与运算符</a></li><li><a href="/js/es5-type.html" class="sidebar-link">数据类型与数据类型转换</a></li><li><a href="/js/es5-prototype.html" class="sidebar-link">原型与原型链</a></li><li><a href="/js/es5-this.html" class="sidebar-link">this 解析</a></li><li><a href="/js/es5-closure.html" class="sidebar-link">闭包</a></li><li><a href="/js/es5-apply-call-bind.html" class="sidebar-link">apply&amp;bind&amp;call</a></li><li><a href="/js/es5-dom.html" class="sidebar-link">DOM与BOM</a></li><li><a href="/js/es5-event.html" class="sidebar-link">事件</a></li><li><a href="/js/es5-execution-context.html" class="sidebar-link">执行上下文与执行上下文栈</a></li><li><a href="/js/es5-extends.html" class="sidebar-link">继承</a></li><li><a href="/js/es5-fn.html" class="sidebar-link">函数</a></li><li><a href="/js/es5-news.html" class="sidebar-link">new 理解</a></li><li><a href="/js/es5-object.html" class="sidebar-link">对象</a></li><li><a href="/js/es5-reg.html" class="sidebar-link">正则表达式学习</a></li><li><a href="/js/es5-scope.html" class="sidebar-link">作用域</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>javascript进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/js-curry.html" class="sidebar-link">函数柯理化</a></li><li><a href="/js/js-debounce.html" class="sidebar-link">节流与防抖动</a></li><li><a href="/js/js-precision.html" class="sidebar-link">js精度丢失问题</a></li><li><a href="/js/js-memory.html" class="sidebar-link">js 内存管理</a></li><li><a href="/js/js-async.html" class="sidebar-link">事件循环和异步编程的崛起</a></li><li><a href="/js/js-bit.html" class="sidebar-link">js 位运算</a></li><li><a href="/js/js-eventloop.html" class="sidebar-link">理解 EventLoop</a></li><li><a href="/js/js-module.html" class="sidebar-link">js 模块化</a></li><li><a href="/js/js-run.html" class="sidebar-link">javascript 执行过程</a></li><li><a href="/js/js-ast.html" class="sidebar-link">解析、抽象语法树（AST）+ 提升编译速度 5 个技巧</a></li><li><a href="/js/js-v8.html" class="sidebar-link">V8 简介</a></li><li><a href="/js/js-principle.html" class="sidebar-link">JS 编译器，解释引擎</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>es6</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/es6-array.html" class="sidebar-link">数组扩展</a></li><li><a href="/js/es6-fn.html" class="sidebar-link">函数扩展</a></li><li><a href="/js/es6-class-1.html" class="sidebar-link">Class 基本用法</a></li><li><a href="/js/es6-class-2.html" class="sidebar-link">Class继承</a></li><li><a href="/js/es6-async.html" class="sidebar-link">async 函数</a></li><li><a href="/js/es6-generator-1.html" class="sidebar-link">Generator 函数的语法</a></li><li><a href="/js/es6-generator-2.html" class="sidebar-link">Generator 函数的异步应用</a></li><li><a href="/js/es6-iterator.html" class="sidebar-link">Iterator 和 for...of 循环</a></li><li><a href="/js/es6-let-const.html" class="sidebar-link">let 与 const</a></li><li><a href="/js/es6-module.html" class="sidebar-link">Module 对象</a></li><li><a href="/js/es6-number.html" class="sidebar-link">数值扩展</a></li><li><a href="/js/es6-object.html" class="sidebar-link">对象扩展</a></li><li><a href="/js/es6-promise.html" class="active sidebar-link">Promise 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/es6-promise.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/js/es6-promise.html#内容" class="sidebar-link">内容</a></li><li class="sidebar-sub-header"><a href="/js/es6-promise.html#联系作者" class="sidebar-link">联系作者</a></li></ul></li><li><a href="/js/es6-proxy-reflect.html" class="sidebar-link">Proxy 和 Reflect</a></li><li><a href="/js/es6-set-map.html" class="sidebar-link">Set和Map数据结构</a></li><li><a href="/js/es6-string.html" class="sidebar-link">字符串扩展</a></li><li><a href="/js/es6-symbol.html" class="sidebar-link">Symbol</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>nodejs</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/node-introdect.html" class="sidebar-link">node 介绍</a></li><li><a href="/js/node-buffer.html" class="sidebar-link">buffer 模块</a></li><li><a href="/js/node-cheerio.html" class="sidebar-link">cheerio 模块</a></li><li><a href="/js/node-cluster.html" class="sidebar-link">cluster 集群</a></li><li><a href="/js/node-egg.html" class="sidebar-link">egg 基础应用</a></li><li><a href="/js/node-events.html" class="sidebar-link">events 模块</a></li><li><a href="/js/node-express.html" class="sidebar-link">express 基础应用</a></li><li><a href="/js/node-fs.html" class="sidebar-link">fs 模块</a></li><li><a href="/js/node-http.html" class="sidebar-link">http 模块</a></li><li><a href="/js/node-koa.html" class="sidebar-link">koa 基础应用</a></li><li><a href="/js/node-net.html" class="sidebar-link">net 模块</a></li><li><a href="/js/node-process.html" class="sidebar-link">process 进程</a></li><li><a href="/js/node-querystring.html" class="sidebar-link">querystring 模块</a></li><li><a href="/js/node-stream.html" class="sidebar-link">stream 模块</a></li><li><a href="/js/node-session-cookie.html" class="sidebar-link">session 与 cookie</a></li><li><a href="/js/node-url.html" class="sidebar-link">url 模块</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>vue框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/mvvm.html" class="sidebar-link">mvvm 框架介绍</a></li><li><a href="/js/jquery-code.html" class="sidebar-link">jquery 源码分析</a></li><li><a href="/js/undescore.html" class="sidebar-link">undescore 源码分析</a></li><li><a href="/js/vue-lifecycle.html" class="sidebar-link">Vue生命周期</a></li><li><a href="/js/vue-bind.html" class="sidebar-link">vue 双向数据绑定原理</a></li><li><a href="/js/vue-nexttick.html" class="sidebar-link">Vue.netTick理解与分析</a></li><li><a href="/js/vue-watch.html" class="sidebar-link">Vue中的computed,watch,methods理解与分析</a></li><li><a href="/js/vue-code.html" class="sidebar-link">vue 源码分析</a></li><li><a href="/js/vue-diff.html" class="sidebar-link">diff 算法</a></li><li><a href="/js/vue-router-code.html" class="sidebar-link">vue-router 源码分析</a></li><li><a href="/js/vue-communication.html" class="sidebar-link">vue 组件通信</a></li><li><a href="/js/vue-router.html" class="sidebar-link">vue-router 学习及原理</a></li><li><a href="/js/vue-vuex.html" class="sidebar-link">vuex 学习及原理</a></li><li><a href="/js/vue-vuex-code.html" class="sidebar-link">vue-vuex 源码分析</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="promise-对象"><a href="#promise-对象" aria-hidden="true" class="header-anchor">#</a> Promise 对象</h1> <h2 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h2> <p>在异步编程中，Promise 扮演了举足轻重的角色，它解决了 ajax 请求过程中的回调地狱的问题，令代码更具可读性。</p> <p><code>Promise</code>对象有以下两处特点：</p> <ul><li>对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li> <li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错误了它，再去监听，是得不到结果的。</li></ul> <h2 id="内容"><a href="#内容" aria-hidden="true" class="header-anchor">#</a> 内容</h2> <ul><li><a href="#%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li> <li><a href="#%E4%BA%8Cthen">then()</a></li> <li><a href="#%E4%B8%89catch">catch()</a></li> <li><a href="#%E5%9B%9Bfinally">finally()</a></li> <li><a href="#%E4%BA%94all">all()</a></li> <li><a href="#%E5%85%ADace">ace()</a></li> <li><a href="#%E4%B8%83resolve">resolve()</a></li> <li><a href="#%E5%85%ABreject">reject()</a></li> <li><a href="#%E4%B9%9Dtry">try()</a></li> <li><a href="#%E5%8D%81%E4%B8%80%E5%BA%94%E7%94%A8">应用</a></li> <li><a href="#%E5%8D%81%E4%B8%80%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%95%E5%8F%8A%E8%AF%AF%E5%8C%BA">错误用法及误区</a></li> <li><a href="#%E5%8D%81%E4%BA%8Cpromise-%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-6-%E4%BB%B6%E4%BA%8B">promise 你可能不知道的 6 件事</a></li> <li><a href="#%E5%8D%81%E4%B8%89%E6%89%8B%E5%86%99-promise">手写 Promise</a></li> <li><a href="##%E5%8D%81%E5%9B%9Bpromise-%E5%87%A0%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98">Promise 几道面试题</a></li></ul> <h3 id="一、基本用法"><a href="#一、基本用法" aria-hidden="true" class="header-anchor">#</a> 一、基本用法</h3> <p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const promise = new Promise(function(resolve,reject){

    if(/* 异步操作成功*/){
        resolve(value);
    }else{
        reject(error);
    }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>Promise</code> 构造函数接受一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 和 <code>reject</code>。</p> <p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变成“成功”（即从 pending 变成 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p> <p><code>reject</code>函数的作用是，将<code>Promse</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p> <h3 id="二、then"><a href="#二、then" aria-hidden="true" class="header-anchor">#</a> 二、then()</h3> <p><code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。<code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用。其中，第二个函数是可选的，不一定要提供。<code>then</code>方法返回的是一个新<code>Promise</code>实例。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>getJSON(&quot;/post/1.json&quot;)
.then(post=&gt;getJSON(post.commentURL))
.then(
    comments=&gt;console.log(&quot;resolved:&quot;,comments),
    err=&gt;console.log(&quot;rejected:&quot;,err)
);

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="三、catch"><a href="#三、catch" aria-hidden="true" class="header-anchor">#</a> 三、catch()</h3> <p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p> <ul><li><a href="#31-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li> <li><a href="#32-promise-%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F">Promise 的异常捕获方式</a></li></ul> <h4 id="_3-1-基本用法"><a href="#_3-1-基本用法" aria-hidden="true" class="header-anchor">#</a> 3.1 基本用法</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>上面代码中，<code>getJSON</code>方法返回一个<code>Promise</code>对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch</code>方法指定的回调函数，处理这个错误。另外，<code>then</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch</code>方法捕获。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var promise = new Promise(function(resolve, reject) {
  resolve('ok');
  throw new Error('test');
});
promise
  .then(function(value) { console.log(value) })
  .catch(function(error) { console.log(error) });
// ok
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上面代码中，<code>Promise</code>在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 <code>Promise</code>的状态一旦改变，就永久保持该状态，不会再变了。</p> <h4 id="_3-2-promise-的异常捕获方式"><a href="#_3-2-promise-的异常捕获方式" aria-hidden="true" class="header-anchor">#</a> 3.2 Promise 的异常捕获方式</h4> <ul><li><a href="#321-%E5%9C%A8-promise-%E7%9A%84%E6%9E%84%E9%80%A0%E4%BD%93%E5%86%85%E8%BF%9B%E8%A1%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">在 Promise 的构造体内进行错误处理</a></li> <li><a href="#322-%E9%80%9A%E8%BF%87-promiseprototypecatch-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">通过 Promise.prototype.catch 来进行错误处理</a></li> <li><a href="#323-promiseall-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7">Promise.all 中的异常捕获</a></li> <li><a href="#324-promisetry-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7">Promise.try 中的异常捕获</a></li> <li><a href="#325-%E5%9C%A8-promise-%E4%B8%AD%E6%97%A0%E6%B3%95%E8%A2%AB%E6%8D%95%E8%8E%B7%E7%9A%84%E9%94%99%E8%AF%AF">在 Promise 中无法被捕获的错误</a></li></ul> <h5 id="_3-2-1-在-promise-的构造体内进行错误处理"><a href="#_3-2-1-在-promise-的构造体内进行错误处理" aria-hidden="true" class="header-anchor">#</a> 3.2.1 在 Promise 的构造体内进行错误处理</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>var promise = new Promise(function(resolve,reject){
    try{
        throw new Error('test');
    }catch(e){
        reject(e)
    }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在 Promise 的构造体内进行错误处理，类似于我们在 ES5 中的错误处理方式。</p> <h5 id="_3-2-2-通过-promise-prototype-catch-来进行错误处理"><a href="#_3-2-2-通过-promise-prototype-catch-来进行错误处理" aria-hidden="true" class="header-anchor">#</a> 3.2.2 通过 Promise.prototype.catch 来进行错误处理</h5> <p>生成<strong>Promise</strong>实例后，我们可以通过<strong>Promise</strong>原型上的 catch 方法来捕获 Promise 实例内部的错误。<code>catch</code>方法返回的还是一个 Promise 对象。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var promise = new Promise(function(resolve,reject){
    reject(new Error('test'));
})

promise.catch(function(e){
    // something to deal with the error
    console.log(e);
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>此外 catch 方法还可以处理链式调用中的错误，比如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var promise = new Promise(function(resolve,reject){
    resolve();
})
promise.then(function(){
    // if some error throw
}).then(function(){
    // if some error throw
}).catch(function(e){
    // something to deal with the error
    console.log(e)
})

// Error:test1

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>上述的代码，最后一个 catch 方法可以捕获前面链式调用过程中任何一步 then 方法里面所抛出的错误。catch 方面里面还可以再抛错误，这个错误会被后面的 catch 捕获</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var promise = new Promise(function(resolve,reject){
    reject(new Error('test1'))
})
promise.catch(function(e){
    console.log(e);
    throw new Error('test2')
}).catch(function(e){
    console.log(e)
})

// Error:test1
// Error:test2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h5 id="_3-2-3-promise-all-中的异常捕获"><a href="#_3-2-3-promise-all-中的异常捕获" aria-hidden="true" class="header-anchor">#</a> 3.2.3 Promise.all 中的异常捕获</h5> <p>如果组成<strong>Promise.all</strong>的<strong>promise</strong>有自己的错误捕获方法，那么<strong>Promise.all</strong>中的 catch 就不能捕获该错误。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var p1= new Promise(function(resolve,reject){
    reject(new Error('test1'));
}).catch(function(e){
    console.log('由p1自身捕获')
});

var p2= new Promise(function(resolve,reject){
    resolve();
})
var p = Promise.all([p1,p2]);
p.then(function(){

}).catch(function(e){
    // 在此处捕获不到p1中的error
    console.log(e)
})
// 由p1贴身捕获Error:test1

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h5 id="_3-2-4-promise-try-中的异常捕获"><a href="#_3-2-4-promise-try-中的异常捕获" aria-hidden="true" class="header-anchor">#</a> 3.2.4 Promise.try 中的异常捕获</h5> <p>ES2018 中可以通过<strong>Promise.try</strong>来同步处理，可能是异步也可能是同步的函数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function f(){}
Promise.try(f);
console.log(2);

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>上述的方法，不管是同步还是异步，都会执行该方法，再输出 2.</p> <p>在<strong>Promise.try</strong>的错误处理中，通过 catch 方法既可以捕获 f 是同步函数情况下的错误，也可以捕获 f 是异步函数下的错误。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function f(){

}

Promise.try(f).then(function(){

}).catch(function(e){

})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h5 id="_3-2-5-在-promise-中无法被捕获的错误"><a href="#_3-2-5-在-promise-中无法被捕获的错误" aria-hidden="true" class="header-anchor">#</a> 3.2.5 在 Promise 中无法被捕获的错误</h5> <p>在<strong>promise</strong>实例<strong>resolve</strong>之后，错误无法被捕获。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var promise = new Promise(function(resolve,reject){
    resolve();
    throw new Error('test');    // 该错误无法被捕获
})
promise.then(function(){
//
}).then(function(e){
    console.log(e)
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>该错误可以用尾调用 resolve 来避免。</p> <p>参考资料：<a href="https://github.com/forthealllight/blog/issues/16" target="_blank" rel="noopener noreferrer">总结一下 ES6/ES7 中 promise、generator 和 async/await 中的异常捕获方法 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="四、finally"><a href="#四、finally" aria-hidden="true" class="header-anchor">#</a> 四、finally()</h3> <p><code>finally</code>方法用于指定不管<code>Promise</code>对象最后状态如何，都会执行的操作。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>promise.then(result=&gt;{...}).catch(error=&gt;{...}).finally(()=&gt;{...});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p> <p>简单实现 finally</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    Promise.prototype.finally = function(callback){
        let P = this.contructor;
        return this.then(
            value =&gt; P.resolve(callback()).then(()=&gt;value),
            reason =&gt; P.resolve(callback()).then(()=&gt;{throw reason})
        )
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="五、all"><a href="#五、all" aria-hidden="true" class="header-anchor">#</a> 五、all()</h3> <p><code>Promise.all</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<code>Promise.all</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是<code>Promise</code>实例，如果不是就会先调<code>Promise.resolve</code>方法，再进一步处理。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var p = Promise.all([p1,p2,p3]);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>p 的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p> <ol><li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>返回值组成一个数组，传递给<code>p</code>的回调函数。</li> <li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 生成一个Promise对象的数组
var promises = [2, 3, 5, 7, 11, 13].map(function (id) {
  return getJSON('/post/' + id + &quot;.json&quot;);
});

Promise.all(promises).then(function (posts) {
  // ...
}).catch(function(reason){
  // ...
});

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="六、ace"><a href="#六、ace" aria-hidden="true" class="header-anchor">#</a> 六、ace()</h3> <p><code>Promise.race</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var p = Promise.race([p1,p2,p3]);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p> <p><code>Promise.race</code>方法的参数与<code>Promise.all</code>方法一样，如果不是<code>Promise</code>实例，就会先调用<code>Promise.resolve</code>方法，将参数转为<code>Promise</code>实例，再进一步处理。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() =&gt; reject(new Error('request timeout')), 5000)
  })
]);
p.then(response =&gt; console.log(response));
p.catch(error =&gt; console.log(error));
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="七、resolve"><a href="#七、resolve" aria-hidden="true" class="header-anchor">#</a> 七、resolve()</h3> <p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve</code>方法就赶到这个作用。</p> <p><code>Promise.resolve</code>等价于下面的写法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Promise.resolve('foo')
//  等价于
new Promise(resolve=&gt;resolve('foo'))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>resolve</code>方法的参数分成四种情况</p> <ol><li>参数是一个 <code>Promise</code>实例</li> <li>参数是一个<code>thenable</code>对象</li> <li>参数不是具有<code>then</code>方法的对象，或根本就不是对象</li> <li>不带有任何参数</li></ol> <h4 id="_7-1-参数是一个-promise实例"><a href="#_7-1-参数是一个-promise实例" aria-hidden="true" class="header-anchor">#</a> 7.1 参数是一个 <code>Promise</code>实例</h4> <p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p> <h4 id="_7-2-参数是一个thenable对象"><a href="#_7-2-参数是一个thenable对象" aria-hidden="true" class="header-anchor">#</a> 7.2 参数是一个<code>thenable</code>对象</h4> <p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，<code>Promise.resolve</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let thenable = {
    then: function(resolve,reject){
        resolve(42);
    }
};

let p1 = Promise.resolve(thenable);
p1.then(function(value){
    console.log(value);     // 42
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>thenable</code>对象的<code>then</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then</code>方法指定的回调函数，输出 42。</p> <h4 id="_7-3-参数不是具有then方法的对象，或根本就不是对象"><a href="#_7-3-参数不是具有then方法的对象，或根本就不是对象" aria-hidden="true" class="header-anchor">#</a> 7.3 参数不是具有<code>then</code>方法的对象，或根本就不是对象</h4> <p>如果参数是一个原始值，或者是一个不具有<code>then</code>方法的对象，则<code>Promise.resolve</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var p = Promise.resolve('Hello');

p.then(function (s){
  console.log(s)
});
// Hello
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="_7-4-不带有任何参数"><a href="#_7-4-不带有任何参数" aria-hidden="true" class="header-anchor">#</a> 7.4 不带有任何参数</h4> <p><code>Promise.resolve</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的<code>Promise</code>对象。</p> <h3 id="八、reject"><a href="#八、reject" aria-hidden="true" class="header-anchor">#</a> 八、reject()</h3> <p><code>reject(reason)</code>方法也会返回一个新的<code>Promise</code>实例，该实例的状态为<code>rejected</code>。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var p = Promise.reject('出错了');

// 等同于
var p = new Promise((resolve,reject)=&gt; reject('出错了'))

p.then(null,function(s){
    console.log(s)
})
// 出错了
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="九、try"><a href="#九、try" aria-hidden="true" class="header-anchor">#</a> 九、try()</h3> <p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否饮食异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Promise.resolve().then(f)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>上面的写法有一个缺点，就是如果 f 是同步函数，那么它会在本轮事件循环的末尾执行。</p> <h3 id="十、应用"><a href="#十、应用" aria-hidden="true" class="header-anchor">#</a> 十、应用</h3> <ul><li><a href="#101-%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87">加载图片</a></li> <li><a href="#102-%E9%80%9A%E8%BF%87-promise-%E5%B0%81%E8%A3%85-ajax-%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98">通过 Promise 封装 ajax 解决回调地狱问题</a></li> <li><a href="#103-generator-%E5%87%BD%E6%95%B0%E4%B8%8E-promise-%E7%9A%84%E7%BB%93%E5%90%88">Generator 函数与 Promise 的结合</a></li></ul> <h4 id="_10-1-加载图片"><a href="#_10-1-加载图片" aria-hidden="true" class="header-anchor">#</a> 10.1 加载图片</h4> <p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const preloadImage = function(path){
    return new Promise(function(resolve,reject){
        var image = new Image();
        image.onload = resolve;
        image.onerror = reject;
        image.src = path;
    });
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_10-2-通过-promise-封装-ajax-解决回调地狱问题"><a href="#_10-2-通过-promise-封装-ajax-解决回调地狱问题" aria-hidden="true" class="header-anchor">#</a> 10.2 通过 Promise 封装 ajax 解决回调地狱问题</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>
function getJSON(url){
    return new Promise((resolve,reject) =&gt; {
        var XHR = new XMLHttpRequest();
        XHR.open('GET',url);
        client.onreadystatechange = handler;
        client.responseType = 'json';
        client.setRequestHeader('Accept','application/json');
        client.send();

        function handler(){
            if(this.readyState !==4){
                return;
            }
            if(this.status === 200){
                resolve(this.response);
            }else{
                reject(new Error(this.statusText));
            }
        };
    });

    return promise;
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h4 id="_10-3-generator-函数与-promise-的结合"><a href="#_10-3-generator-函数与-promise-的结合" aria-hidden="true" class="header-anchor">#</a> 10.3 Generator 函数与 Promise 的结合</h4> <p>使用<code>Generator</code>函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function getFoo(){

}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="十一、错误用法及误区"><a href="#十一、错误用法及误区" aria-hidden="true" class="header-anchor">#</a> 十一、错误用法及误区</h3> <ul><li><a href="#111-%E5%BD%93%E4%BD%9C%E5%9B%9E%E8%B0%83%E6%9D%A5%E7%94%A8-callback-hell">当作回调来用 Callback Hell</a></li> <li><a href="#112-%E6%80%8E%E6%A0%B7%E7%94%A8-foreach-%E5%A4%84%E7%90%86-promise">怎样用 forEach() 处理 promise</a></li> <li><a href="#113-%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC">没有返回值</a></li> <li><a href="#114-%E6%B2%A1%E6%9C%89-catch">没有 Catch</a></li> <li><a href="#115-catch%E4%B8%8E-thennull-fn%E5%B9%B6%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C">catch()与 then(null, fn)</a></li> <li><a href="#116-%E6%96%AD%E9%93%BE-the-broken-chain">断链 The Broken Chain</a></li> <li><a href="#117-%E7%A9%BF%E9%80%8F-fall-through">穿透 Fall Through</a></li></ul> <h4 id="_11-1-当作回调来用-callback-hell"><a href="#_11-1-当作回调来用-callback-hell" aria-hidden="true" class="header-anchor">#</a> 11.1 当作回调来用 Callback Hell</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>loadAsync1().then(function(data1){
    loadAsync2(data1).then(function(data2){
        loadAsync3(data2).then(okFn,failFn)
    });
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Promise 用来解决异步嵌套回调的，这种写法虽然可靠，但违背了 Promise 的设计初衷改成下面的写法，会让结构更加清晰</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>loadAsync1().then(function(data1){
    return loadAsync2(data1)
}).then(function(data2){
    return loadAsync3(data2)
}).then(okFn,failFn)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="_11-2-怎样用-foreach-处理-promise"><a href="#_11-2-怎样用-foreach-处理-promise" aria-hidden="true" class="header-anchor">#</a> 11.2 怎样用 forEach() 处理 promise</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>db.allDocs({include_docs:true}).then(function(result){
    result.rows.forEach(function(row){
        db.remove(row.doc);
    })
}).then(function(){

})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这段代码的问题在于第一个回调函数实际上返回的是<code>undefined</code>，也就意味着第二个函数并不是在所有的<code>db.remove()</code>执行结束之后才执行。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>db.allDocs({include_docs:true}).then(function(result){
    return Promise.all(result.rows.map(function(row){
        return db.remove(row.doc);
    }))
}).then(function(arrayObject){
    // All docs have
})

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>从根本上说，<code>Promise.all()</code>以一个 promise 对象组成的数组为输入，返回另一个 promise 对象。</p> <h4 id="_11-3-没有返回值"><a href="#_11-3-没有返回值" aria-hidden="true" class="header-anchor">#</a> 11.3 没有返回值</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>loadAsync1().then(function(data1){
    loadAsync2(data1)
}).then(function(data2){
    loadAsync3(data2)
}).then(res=&gt;console.log(res))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="_11-4-没有-catch"><a href="#_11-4-没有-catch" aria-hidden="true" class="header-anchor">#</a> 11.4 没有 Catch</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>loadAsync1().then(function(data1){

}).then(function(data2){

}).then(okFn,failFn)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这里的调用，并没有添加 catch 方法，那么如果中间某个环节发生错误，将不会被捕获，控制台将看不到任何错误，不利于调试查错，所以最好在最后添加 catch 方法用于捕获错误。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>loadAsync1()
    .then(function(data1){
        return loadAsync2(data1)
    })
    .then(function(data2){
        return loadAsync3(data2)
    }).then(okFn,failFn)
    .catch(err=&gt;console.log(err))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_11-5-catch-与-then-null-fn-并不完全相同"><a href="#_11-5-catch-与-then-null-fn-并不完全相同" aria-hidden="true" class="header-anchor">#</a> 11.5 <code>catch()</code>与 <code>then(null, fn)</code>并不完全相同</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>somePromise().then(function () {
  throw new Error('oh noes');
}).catch(function (err) {
  // I caught your error! :)
});

somePromise().then(function () {
  throw new Error('oh noes');
}, function (err) {
  // I didn't catch your error! :(
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>当使用<code>then(resolveHandler,rejectHandler)</code>，<code>rejectHandler</code>不会捕获在<code>resolveHandler</code>中抛出的错误。</p> <h4 id="_11-6-断链-the-broken-chain"><a href="#_11-6-断链-the-broken-chain" aria-hidden="true" class="header-anchor">#</a> 11.6 断链 The Broken Chain</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>function loadAsyncFnX(){return Promise.resolve(1);}
function doSth(){return 2;}

function asyncFn(){
    var promise = loadAsyncFnx()
    promise.then(function(){
            reutrn doSth();
    })
    return promise;
}

asyncFn().then(res=&gt;console.log(res)).catch(err=&gt;console.log(err))      // 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>从执行结果来看，then 中架设的参数其实并不是 doSth()返回的结果，而是 loadAsyncFnX()返回的结果，catch 到的错误也是 loadAsyncFnX()中的错误，所以 doSth()的结果和错误将不会被后而的 then 中的回调捕获到，形成了断链，因为 then 方法将返回一个新的 Promise 对象，而不是原来的 Promise 对象</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function loadAsyncFnX(){ return Promise.resolve(1); }
function doSth(){ return 2; }

function asyncFn(){
	var promise = loadAsyncFnX()
    return promise.then(function(){
		return doSth();
    })
}

asyncFn().then(res=&gt;console.log(res)).catch(err=&gt;console.log(err))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="_11-7-穿透-fall-through"><a href="#_11-7-穿透-fall-through" aria-hidden="true" class="header-anchor">#</a> 11.7 穿透 Fall Through</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>Promise.resolve('foo').then(Promise.resolve('bar')).then(function(result){
    console.log(result);
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果你认为输出的是 bar，那么你就错了。实际上它输出的是 foo！</p> <p>产生这样的输出是因为你给 then 方法传递了一个非函数的值，代码会这样理解：<code>then(null)</code>，因此导致前一个 promise 的结果产生了坠落的效果。</p> <p>参考资料：<a href="http://coderlt.coding.me/2016/12/03/promise-in-depth-an-introduction-1/" target="_blank" rel="noopener noreferrer">深入理解 Promise (上)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="十二、promise-你可能不知道的-6-件事"><a href="#十二、promise-你可能不知道的-6-件事" aria-hidden="true" class="header-anchor">#</a> 十二、promise 你可能不知道的 6 件事</h3> <ul><li><a href="#121-then%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-forked-promise%E5%88%86%E5%8F%89%E7%9A%84-promise"><code>then()</code>返回一个 forked Promise(分叉的 Promise)</a></li> <li><a href="#122-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%BA%94%E8%AF%A5%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%9C">回调函数应该传递结果</a></li> <li><a href="#123-%E5%8F%AA%E8%83%BD%E6%8D%95%E8%8E%B7%E6%9D%A5%E8%87%AA%E4%B8%8A%E4%B8%80%E7%BA%A7%E7%9A%84%E5%BC%82%E5%B8%B8">只能捕获来自上一级的异常</a></li> <li><a href="#124-%E9%94%99%E8%AF%AF%E8%83%BD%E8%A2%AB%E6%81%A2%E5%A4%8D">错误能被恢复</a></li> <li><a href="#125-promise-%E8%83%BD%E8%A2%AB%E6%9A%82%E5%81%9C">Promise 能被暂停</a></li> <li><a href="#126-resolved-%E7%8A%B6%E6%80%81%E7%9A%84-promise-%E4%B8%8D%E4%BC%9A%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C">resolved 状态的 Promise 不会立即执行</a></li></ul> <h4 id="_12-1-then-返回一个-forked-promise-分叉的-promise"><a href="#_12-1-then-返回一个-forked-promise-分叉的-promise" aria-hidden="true" class="header-anchor">#</a> 12.1 <code>then()</code>返回一个 forked Promise(分叉的 Promise)</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>// Exhitbit A
var p = new Promise(/*...*/);
p.then(func1);
p.then(func2);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>// Exhitbit B
var p = new Promise(/*...*/);
p.then(func1).then(func2);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果你认为两段代码等价，那么你可能认为 promise 仅仅就是一维回调函数的数组。然而，这两段代码并不等价。<code>p</code>每次调用<code>then()</code>都会返回一个<code>forked promise</code>。因此，在 A 中，如果<code>func1</code>抛出一个异常，<code>func2</code>依然能执行，而在 B 中，<code>func2</code>不会被执行，因为第一次调用返回了一个新<code>promise</code>，由于<code>func1</code>中抛出异常，这个<code>promise</code>被<code>rejected</code>了，结果<code>func2</code>被跳过不执行了。</p> <h4 id="_12-2-回调函数应该传递结果"><a href="#_12-2-回调函数应该传递结果" aria-hidden="true" class="header-anchor">#</a> 12.2 回调函数应该传递结果</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>var p = new Promise(function(resolve,reject){
    resolve(&quot;hello world&quot;);
})

p.then(function(str){

}).then(function(str){
    console.log(str)
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>第二个<code>then()</code>中的<code>console.log</code>显示的是<code>undefined</code>，因为在 promise 的上下文中，回调函数像普通的回调函数一样传递结果。promise 期望你的回调函数或者返回同一个结果，或者返回其它结果，返回的结果会被传给下一个回调。</p> <h4 id="_12-3-只能捕获来自上一级的异常"><a href="#_12-3-只能捕获来自上一级的异常" aria-hidden="true" class="header-anchor">#</a> 12.3 只能捕获来自上一级的异常</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>new Promise(function(resolve,reject){
    resolve('hello world');
}).then(function(str){
    throw new Error('uh oh');
},undefined).then(undefined,function(error){
    console.log(error);
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>// Exhibit B
new Promise(function(resolve,reject){
    resolve('hello world');
}).then(function(str){
    throw new Error('uh oh');
},function(error){
    console.log(error);
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在 A 中，当第一个<code>then</code>抛出异常时，第二个<code>then</code>能捕获到该异常，并会弹出<code>uh oh</code>。这符合只捕获来自上一级异常的规则。</p> <p>在 B 中，正确的回调函数和错误的回调函数在同一级，也就是说，尽管在回调中抛出了异常，但是这个异常不会被捕获。事实上，B 中的错误回调只有在<code>promise</code>被<code>rejected</code>或者<code>promise</code>自身抛出一个异常时才会被执行。</p> <h4 id="_12-4-错误能被恢复"><a href="#_12-4-错误能被恢复" aria-hidden="true" class="header-anchor">#</a> 12.4 错误能被恢复</h4> <p>在一个错误回调中，如果没有重新抛出错误，promise 会认为你已经恢复了该错误，promise 的状态会转变为<code>resolved</code>。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var p = new Promise(function(resolve,reject){
    reject(new Error('pebkac'));
});

p.then(
    undefined,
    function(error){ }
)
 .then(
    function(str){
        alert('I am saved!');
    },
    function(error){
     alert('Bad computer!');
    }
);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="_12-5-promise-能被暂停"><a href="#_12-5-promise-能被暂停" aria-hidden="true" class="header-anchor">#</a> 12.5 Promise 能被暂停</h4> <p>仅仅因为你已经在一个<code>then()</code>函数中执行过代码，并不意味着你不能够暂停 promise 去做其他事情。为了暂停当前的 promise，或者要它等待另一个 promise 完成，只需要简单地在 then() 函数中返回另一个 promise。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var p = new Promise(/*...*/);

p.then(function(str){
    if(!loggedIn){
        return new Promise(/*...*/);
    }
})
 .then(function(str){
    alert(&quot;Done!&quot;);
 });
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在上面的代码中，直到新的<code>promise</code>的状态是<code>resolved</code>解析后，<code>alert</code>才会显示。如果要在已经存在的异步代码中引入更多的依赖，这是一个很便利的方式。例如，你发现用户会话已经超时了，因此，你可能想要在继续执行后面的代码之前发起第二次登录。</p> <h4 id="_12-6-resolved-状态的-promise-不会立即执行"><a href="#_12-6-resolved-状态的-promise-不会立即执行" aria-hidden="true" class="header-anchor">#</a> 12.6 resolved 状态的 Promise 不会立即执行</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>function runme() {
  var i = 0;

  new Promise(function(resolve) {
    resolve();
  })
  .then(function() {
    i += 2;
  });
  alert(i);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>你可能会认为弹出 2，因为 promise 已经是 resolved ，then() 会立即执行(同步)。然而，promise 规范要求所有回调都是异步的，因此，alert 执行时 i 的值还没有被修改。</p> <p>参考资料：<a href="https://github.com/dwqs/blog/issues/1" target="_blank" rel="noopener noreferrer">关于 Promise：你可能不知道的 6 件事<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="十三、手写-promise"><a href="#十三、手写-promise" aria-hidden="true" class="header-anchor">#</a> 十三、手写 Promise</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

function Promise(excutor){
    let that = this;        // 缓存当前promise实例对象
    that.status = PENDING;  // 初始状态
    that.value = undefined;     // fulfilled状态时 返回的信息
    that.reason = undefined;    // rejected状态时，拒绝的原因
    that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数
    that.onRejectedCallbacks = [];      //存储rejected状态对应的onRejected函数

    function resolve(value){    // value成功态时接收的终值
        if(value instanceof Promise){
            return value.then(resolve,reject);
        }
        //  实践中要确保onFulfilled 和 onRejected方法异步执行，且应该在then方法被调用的那一轮事件循环之后的新执行栈中执行。
        setTimeout(()=&gt;{
            //调用resolve回调对应onFulfilled函数
            if(that.status === PENDING){
                // 只能由pending状态=&gt; fullfilled状态（避免调用多次resolve reject）
                that.status = FULFILLED;
                that.value = value;
                that.onFulfilledCallbacks.forEach(cb=&gt;cb(that.value));
            }
        })
    }
    function reject(reason){    // reason失败态时接收的拒因
        setTimeout(()=&gt;{
            // 调用reject 回调对应onRejected函数
            if (that.status === PENDING){
                // 只能由pending状态 =&gt; rejected状态（避免调用多次resolve reject）
                that.status = REJECTED;
                that.reason = reason;
                that.onRejectedCallbacks.forEach(cb=&gt;cb(that.reason));
            }
        });
    }

    // 捕获在excutor执行器中抛出异常
    // new Promise((resolve,reject)=&gt;{
        //   throw new Error('error in excutor')
    // })

    try{
        excutor(resolve,reject);
    }catch(e){
        reject(e);
    }
}

function resolvePromise(promise2,x,resolve,reject){
    var then;
    var thenCalledThrow = false;

    if(promise2 === x){
        return reject(new TypeError('Chaining cycle detected for promise!'))
    }

    if( x instanceof Promise){
        if(x.status === 'pending'){
            x.then(function(v){
                resolvePromise(promise2,v,resolve,reject)
            },reject)
        }else{
            x.then(resolve,reject)
        }
        return
    }

    if((x!==null) &amp;&amp; ((typeof x=== 'object') || (typeof x === 'function'))){
        try{
            then = x.then   // because x.then could be a getter
            if(typeof then === 'function'){
                then.call(x,function rs(y){
                    if(thenCalledOrThrow) return
                    thenCalledOrThrow = true
                    reutrn resolvePromise(promise2,y,resolve,reject)
                },function rj(r){
                    if(thenCalledOrThrow) return
                    thenCalledOrThrow = true
                    return reject(r)
                })
            }else{
                resolve(x)
            }
        }catch(e){
            if(thenCalledOrThrow) return
            thenCalledOrThrow = true
            return reject(e)
        }
    }else{
        resolve(x)
    }
}

Promise.prototype.then = function(onFulfilled,onRejected){
    const that = this;
    let newPromise;
    // 处理参数默认值  保证参数后续能够继续执行
    onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value;
    onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; {
        throw reason;
    }
    if ( that.status === FULFILLED){    //成功态
        return newPromise = new Promise((resolve,reject) =&gt;{
            setTimeout(()=&gt;{
                try{
                    let x = onFulfilled(that.value);
                    resolvePromise(newPromise,x,resolve,reject);
// 新的promise resolve 上一个onFulfilled的返回值
                }catch(e){
                    reject(e);  //  捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);
                }
            })
        })
    }

    if(that.status === REJECTED){   // 失败态
        return newPromise = new Promise((resolve,reject)=&gt;{
            setTimeout(()=&gt;{
                try{
                    let x = onRejected(that.reason);
                    resolvePromise(newPromise,x,resolve,reject);
                }catch(e){
                    reject(e);
                }
            })
        })
    }

    if(that.status === PENDING){    // 等待态
        // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中
        return newPromise = new Promise((resolve,reject)=&gt;{
            that.onFulfilledCallbacks.push((value)=&gt;{
                try{
                    let x = onFulfilled(value);
                    resolvePromise(newPromise,x,resolve,reject);
                }catch(e){
                    reject(e);
                }
            });
            that.onRejectedCallbacks.push((reason)=&gt;{
                try{
                    let x = onRejected(reason);
                    reasolvePromise(newPromise,x,resolve,reject);
                }catch(e){
                    reject(e);
                }
            })
        })
    }
}

Promise.prototype.catch = function(onRejected){
    return thsi.then(null,onRejected)
}

Promise.deferred = Promise.defer = function(){
    var dfd ={}
    dfd.promise = new Promise(function(resolve,reject){
        dfd.resolve = resolve
        dfd.reject = reject
    })
    return dfd;
}

Promise.all = function(promises){
    return new Promise((resolve,reject){
        const result = []
        let cnt = 0
        for (let i = 0; i &lt; promises.length;++i){
            promises[i].then(value=&gt;{
                cnt++
                result[i]=value
                if(cnt  === promises.length) resolve(result)
            },reject)
        }
    })
}

Promise.race = function(promises){
    return new Promise((resolve,reject)=&gt;{
        promises[i].then(resolve,reject)
    })
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br><span class="line-number">162</span><br><span class="line-number">163</span><br><span class="line-number">164</span><br><span class="line-number">165</span><br><span class="line-number">166</span><br><span class="line-number">167</span><br><span class="line-number">168</span><br><span class="line-number">169</span><br><span class="line-number">170</span><br><span class="line-number">171</span><br><span class="line-number">172</span><br><span class="line-number">173</span><br><span class="line-number">174</span><br><span class="line-number">175</span><br><span class="line-number">176</span><br><span class="line-number">177</span><br><span class="line-number">178</span><br><span class="line-number">179</span><br><span class="line-number">180</span><br><span class="line-number">181</span><br><span class="line-number">182</span><br><span class="line-number">183</span><br><span class="line-number">184</span><br><span class="line-number">185</span><br><span class="line-number">186</span><br><span class="line-number">187</span><br></div></div><p>参考资料：</p> <ul><li><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="noopener noreferrer">手写 promise<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5b2f02cd5188252b937548ab" target="_blank" rel="noopener noreferrer">BAT 前端经典面试问题：史上最最最详细的手写 Promise 教程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5aa7868b6fb9a028dd4de672" target="_blank" rel="noopener noreferrer">Promise 原理讲解 &amp;&amp; 实现一个 Promise 对象 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="十四、promise-几道面试题"><a href="#十四、promise-几道面试题" aria-hidden="true" class="header-anchor">#</a> 十四、Promise 几道面试题</h3> <ul><li><a href="#141-%E9%A2%98%E7%9B%AE%E4%B8%80">题目一</a></li> <li><a href="#142-%E9%A2%98%E7%9B%AE%E4%BA%8C">题目二</a></li> <li><a href="#143-%E9%A2%98%E7%9B%AE%E4%B8%89">题目三</a></li> <li><a href="#144-%E9%A2%98%E7%9B%AE%E5%9B%9B">题目四</a></li> <li><a href="#145-%E9%A2%98%E7%9B%AE%E4%BA%94">题目五</a></li> <li><a href="#146-%E9%A2%98%E7%9B%AE%E5%85%AD">题目六</a></li> <li><a href="#147-%E9%A2%98%E7%9B%AE%E4%B8%83">题目七</a></li> <li><a href="#148-%E9%A2%98%E7%9B%AE%E5%85%AB">题目八</a></li> <li><a href="#149-%E9%A2%98%E7%9B%AE%E4%B9%9D">题目九</a></li> <li><a href="#1410-%E9%A2%98%E7%9B%AE%E5%8D%81">题目十</a></li></ul> <h4 id="_14-1-题目一"><a href="#_14-1-题目一" aria-hidden="true" class="header-anchor">#</a> 14.1 题目一</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const promise = new Promise((resolve,reject)=&gt;{
    console.log(1)
    resolve()
    console.log(2)
})
promise.then(()=&gt;{
    console.log(3)
})
console.log(4)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="_14-2-题目二"><a href="#_14-2-题目二" aria-hidden="true" class="header-anchor">#</a> 14.2 题目二</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const promise1 = new Promise(resolve,reject)=&gt;{
    setTimeout(()=&gt;{
        resolve('success')
    },1000)
})
const promise2 = promise1.then(()=&gt;{
    throw new Error('error!!!')
})

console.log('promise1',promise1)
console.log('promise2',promise2)

setTimeout(()=&gt;{
    console.log('promise1',promise1)
    console.log('promise2',promise2)
},2000)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="_14-3-题目三"><a href="#_14-3-题目三" aria-hidden="true" class="header-anchor">#</a> 14.3 题目三</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const promise = new Promise((resolve,reject)=&gt;{
    resolve('success1')
    reject('error')
    resolve('success2')
})

promise.then((res)=&gt;{
    console.log('then:',res)
}).catch((err)=&gt;{
    console.log('catch:',err)
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="_14-4-题目四"><a href="#_14-4-题目四" aria-hidden="true" class="header-anchor">#</a> 14.4 题目四</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>Promise.resolve(1).then((res)=&gt;{
    console.log(res)
    return 2
}).catch((err)=&gt;{
    return 3
}).then((res)=&gt;{
    console.log(res)
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_14-5-题目五"><a href="#_14-5-题目五" aria-hidden="true" class="header-anchor">#</a> 14.5 题目五</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const promise = new Promise((resolve,reject)=&gt;{
    setTimeout(()=&gt;{
        console.log('once')
        resolve('success')
    },1000)
})

const start = Date.now()
promise.then((res)=&gt;{
    console.log(res,Date.now()-start)
})
promise.then((res)=&gt;{
    console.log(res,Date.now()-start)
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="_14-6-题目六"><a href="#_14-6-题目六" aria-hidden="true" class="header-anchor">#</a> 14.6 题目六</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>Promise.resolve().then(()=&gt;{
    return new Error('error!!')
}).then((res)=&gt;{
    console.log('then:',res)
}).catch((err)=&gt;[
    cosnole.log('catch:',err)
])
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_14-7-题目七"><a href="#_14-7-题目七" aria-hidden="true" class="header-anchor">#</a> 14.7 题目七</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const promise = Promise.resolve().then(()=&gt;{
    return promise
})
promise.catch(console.error)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_14-8-题目八"><a href="#_14-8-题目八" aria-hidden="true" class="header-anchor">#</a> 14.8 题目八</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_14-9-题目九"><a href="#_14-9-题目九" aria-hidden="true" class="header-anchor">#</a> 14.9 题目九</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>Promise.resolve().then(function(res){
    throw new Error('error')
},function (e){
    console.log(e)
}).catch((e)=&gt;{
    console.log('fail:',e)
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_14-10-题目十"><a href="#_14-10-题目十" aria-hidden="true" class="header-anchor">#</a> 14.10 题目十</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>process.nextTick(()=&gt;{
    console.log('nextTick')
})
Promise.resolve().then(()=&gt;{
    console.log('then')
})
setImmediate(()=&gt;{
    console.log('setImmediate')
})
console.log('end')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><a href="https://juejin.im/post/5a04066351882517c416715d" target="_blank" rel="noopener noreferrer">Promise 必知必会（十道题）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="参考资料"><a href="#参考资料" aria-hidden="true" class="header-anchor">#</a> 参考资料</h3> <ul><li><a href="https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/" target="_blank" rel="noopener noreferrer">Promise A+ 规范<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://liubin.org/promises-book/" target="_blank" rel="noopener noreferrer">JavaScript Promise 迷你书<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s/mvqR4oEq1VcTYB57QqGIvQ" target="_blank" rel="noopener noreferrer">你了解 Promise 吗？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s/0DVOqFQYSzCaviSv_3AF-g" target="_blank" rel="noopener noreferrer">promise 是什么？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://zhuanlan.zhihu.com/p/83965949" target="_blank" rel="noopener noreferrer">100 行代码实现 Promises/A+ 规范<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://yjhenan.gitbooks.io/-ecmascript-6/content/docs/promise.html" target="_blank" rel="noopener noreferrer">《ECMAScript 6 入门》 第三版<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener noreferrer">ECMAScript 6 入门<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="联系作者"><a href="#联系作者" aria-hidden="true" class="header-anchor">#</a> 联系作者</h2> <div align="center"><p>
        平凡世界，贵在坚持。
    </p> <img src="/about/contact.png"></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新于:</span> <span class="time">2019-10-8 10:31:42</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/js/es6-object.html" class="prev">对象扩展</a></span> <span class="next"><a href="/js/es6-proxy-reflect.html">Proxy 和 Reflect</a>→
    </span></p></div> </main></div><div class="global-ui"><!----><!----><div></div></div></div>
    <script src="/assets/js/app.317e8fe1.js" defer></script><script src="/assets/js/2.67134772.js" defer></script><script src="/assets/js/105.56f79dba.js" defer></script><script src="/assets/js/3.65dbdf4c.js" defer></script>
  </body>
</html>
