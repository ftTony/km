(window.webpackJsonp=window.webpackJsonp||[]).push([[164],{385:function(s,a,t){"use strict";t.r(a);var e=t(13),r=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"symbol"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[s._v("#")]),s._v(" Symbol")]),s._v(" "),t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),t("p",[s._v("ES5 的对象属性名都是字符串，这容易造成属性名的冲突。ES6 引入了一种新的原始数据类型"),t("code",[s._v("Symbol")]),s._v("，表示独一无二的值。")]),s._v(" "),t("h2",{attrs:{id:"内容"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内容"}},[s._v("#")]),s._v(" 内容")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E4%B8%80%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84-symbol"}},[s._v("作为属性名的 Symbol")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#%E4%BA%8C%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E9%81%8D%E5%8E%86"}},[s._v("属性名的遍历")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#%E4%B8%89symbolforsymbolkeyfor"}},[s._v("Symbol.for()，Symbol.keyFor()")])]),s._v(" "),t("li",[t("a",{attrs:{href:"#%E5%9B%9B%E5%86%85%E7%BD%AE%E7%9A%84symbol%E5%80%BC"}},[s._v("内置的Symbol值")])])]),s._v(" "),t("h3",{attrs:{id:"一、作为属性名的-symbol"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、作为属性名的-symbol"}},[s._v("#")]),s._v(" 一、作为属性名的 Symbol")]),s._v(" "),t("p",[s._v("由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var mySymbol = Symbol();\n\n// 第一种写法\nvar a = {};\na[mySymbol] = 'Hello!';\n\n// 第二种写法\nvar a = {\n    [mySymbol]:'Hello!';\n};\n\n// 第三种写法\nvar a = {};\nObject.defineProperty(a, mySymbol, { value: 'Hello!' });\n\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br")])]),t("h3",{attrs:{id:"二、属性名的遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、属性名的遍历"}},[s._v("#")]),s._v(" 二、属性名的遍历")]),s._v(" "),t("p",[s._v("Symbol 作为属性名，该属性不会出现在"),t("code",[s._v("for...in")]),s._v("、"),t("code",[s._v("for...of")]),s._v("循环中，也不会被"),t("code",[s._v("Object.keys()")]),s._v("、"),t("code",[s._v("Object.getOwnPropertyNames()")]),s._v("、"),t("code",[s._v("JSON.stringify()")]),s._v("返回。但是，它也不是私有属性，有一个"),t("code",[s._v("Object.getOwnPropertySymbols")]),s._v("方法，可以获取指定对象的所有 Symbol 属性名。")]),s._v(" "),t("p",[t("code",[s._v("Object.getOwnPropertySymbols")]),s._v("方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var obj = {};\nvar a = Symbol('a');\nvar b = Symbol('b');\n\nobj[a] = 'Hello';\nobj[b] = 'World';\n\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\n\nobjectSymbols\n// [Symbol(a), Symbol(b)]\n\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br")])]),t("h3",{attrs:{id:"三、symbol-for-，symbol-keyfor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、symbol-for-，symbol-keyfor"}},[s._v("#")]),s._v(" 三、Symbol.for()，Symbol.keyFor()")]),s._v(" "),t("p",[s._v("有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var s1 = Symbol.for('foo');\nvar s2 = Symbol.for('foo');\n\ns1 === s2 // true\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("h3",{attrs:{id:"四、内置的symbol值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、内置的symbol值"}},[s._v("#")]),s._v(" 四、内置的Symbol值")]),s._v(" "),t("p",[s._v("除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。")]),s._v(" "),t("ul",[t("li",[t("p",[t("code",[s._v("Symbol.hasInstance")]),s._v("：指向一个内部方法。当其他对象使用"),t("code",[s._v("instanceof")]),s._v("运算符，判断是否为该对象的实例时，会调用这个方法。")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("Symbol.isConcatSpreadable")]),s._v("：属性等于一个布尔值，表示该对象用于"),t("code",[s._v("Array.prototype.concat()")]),s._v("时，是否可以展开。")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("Symbol.species")]),s._v("：指向当前对象的构造函数。创造实例时，默认会调用这个方法，即使用这个属性返回的函数当作构造函数，来创造新的实例对象。")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("Symbol.match")]),s._v("：指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("Symbol.replace")]),s._v("：指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("Symbol.search")]),s._v("：指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("Symbol.split")]),s._v("：指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("Symbol.iterator")]),s._v("：指向该对象的默认遍历器方法。")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("Symbol.toPrimitive")]),s._v("：指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。")]),s._v(" "),t("p",[s._v("Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式")]),s._v(" "),t("ul",[t("li",[s._v("Number：该场合需要转成数值")]),s._v(" "),t("li",[s._v("String：该场合需要转成字符串")]),s._v(" "),t("li",[s._v("Default：该场合可以转成数值，也可以转成字符串")])])]),s._v(" "),t("li",[t("p",[t("code",[s._v("Symbol.toStringTag")]),s._v("：指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。")])]),s._v(" "),t("li",[t("p",[t("code",[s._v("Symbol.unscopables")]),s._v("：指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。")])])]),s._v(" "),t("h3",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[s._v("#")]),s._v(" 参考资料")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://yjhenan.gitbooks.io/-ecmascript-6/content/docs/symbol.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("《ECMAScript 6 入门》 第三版"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"http://es6.ruanyifeng.com/#docs/symbol",target:"_blank",rel:"noopener noreferrer"}},[s._v("ECMAScript 6 入门"),t("OutboundLink")],1)])]),s._v(" "),t("h2",{attrs:{id:"联系作者"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#联系作者"}},[s._v("#")]),s._v(" 联系作者")]),s._v(" "),t("div",{attrs:{align:"center"}},[t("p",[s._v("\n        平凡世界，贵在坚持。\n    ")]),s._v(" "),t("img",{attrs:{src:s.$withBase("/about/contact.png")}})])])}),[],!1,null,null,null);a.default=r.exports}}]);