(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{434:function(_,v,e){"use strict";e.r(v);var r=e(4),t=Object(r.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"字典树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字典树","aria-hidden":"true"}},[_._v("#")]),_._v(" 字典树")]),_._v(" "),e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[_._v("#")]),_._v(" 前言")]),_._v(" "),e("p",[_._v("本人平时学习及收集内容，欢迎参入一起讨论。")]),_._v(" "),e("h2",{attrs:{id:"内容"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内容","aria-hidden":"true"}},[_._v("#")]),_._v(" 内容")]),_._v(" "),e("ul",[e("li",[_._v("Tire 树")]),_._v(" "),e("li",[_._v("Trie 树的特点")]),_._v(" "),e("li",[_._v("Trie 树的插入操作")]),_._v(" "),e("li",[_._v("Trie 树的查询操作")]),_._v(" "),e("li",[_._v("Trie 树的删除操作")]),_._v(" "),e("li",[_._v("Trie 树的应用")]),_._v(" "),e("li",[_._v("Trie 树的局限性")])]),_._v(" "),e("h3",{attrs:{id:"一、tire-树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、tire-树","aria-hidden":"true"}},[_._v("#")]),_._v(" 一、Tire 树")]),_._v(" "),e("blockquote",[e("p",[_._v("Trie 这个名字取自“retrieval”，检索，因为 Trie 可以只用一个前缀便可以在一部字典中找到想要的单词。")])]),_._v(" "),e("p",[_._v("Tire 树，也叫“字典树”。顾名思义，它是一个"),e("strong",[_._v("树形结构")]),_._v("。它是一种专门处理字符串切尔西的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。")]),_._v(" "),e("p",[_._v("此外 Trie 树也称前缀树（因为某节点的后代存在共同的前缀，比如 pan 是 panda 的前缀）。")]),_._v(" "),e("p",[_._v("它的 key 都为字符串，能做到高效查询和插入，时间复杂度为 O(k)，k 为空符串长度，缺点是如果大量字符串没有共同前缀时很耗内存。")]),_._v(" "),e("p",[e("strong",[_._v("它的核心思想就是通过最大限度地减少无谓的字符串比较，舍不得查询效率，即用空间换时间，再利用共同前缀来提高查询效率。")])]),_._v(" "),e("h3",{attrs:{id:"二、trie-树的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、trie-树的特点","aria-hidden":"true"}},[_._v("#")]),_._v(" 二、Trie 树的特点")]),_._v(" "),e("p",[_._v("假设有 5 个字符串，它们分别是：code，cook，five，file，fat。现在需要在里面多次查找某个字符串是否存在。如果每次查找，都是拿要查找字符串跟这 5 个字符串今次进行字符串匹配，那效率就比较低，有没有更高效的方法呢？")]),_._v(" "),e("p",[_._v("如果将这 5 个字符串组织成下图的结构，从肉眼上扫描过感官上是不是比查找起来会更加迅速。")]),_._v(" "),e("p",[e("img",{attrs:{src:"trie01.png",alt:"images"}})]),_._v(" "),e("p",[_._v("通过上图，可以发现 Trie 树的三个特点：")]),_._v(" "),e("ul",[e("li",[_._v("根节点不包含字符，除根节点外每一个节点都只包含一个字符")]),_._v(" "),e("li",[_._v("从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串")]),_._v(" "),e("li",[_._v("每个节点的所有子节点节点包含的字符都不相同")])]),_._v(" "),e("p",[_._v("通过动画理解 Trie 树构造的过程。在构造过程中的每一步，都相当于往 Trie 树中插入一个字符串。当所有字符串都插入完成之后，Trie 树就构造好了。")]),_._v(" "),e("p",[e("img",{attrs:{src:"trie02.gif",alt:"images"}})]),_._v(" "),e("h3",{attrs:{id:"三、trie-树的插入操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、trie-树的插入操作","aria-hidden":"true"}},[_._v("#")]),_._v(" 三、Trie 树的插入操作")]),_._v(" "),e("p",[e("img",{attrs:{src:"trie03.gif",alt:"images"}})]),_._v(" "),e("p",[_._v("Trie 树的插入操作很简单，其实就是将单词的每个字母逐一插入 Trie 树。插入前先看字母对应的节点是否存在，存在则共享该节点，不存在则创建对应的节点。比如要插入新单词"),e("code",[_._v("cook")]),_._v("，就有下面几步：")]),_._v(" "),e("ul",[e("li",[_._v("插入第一个字母"),e("code",[_._v("c")]),_._v("，发现"),e("code",[_._v("root")]),_._v("节点下方存在子节点"),e("code",[_._v("c")]),_._v("，则共享节点"),e("code",[_._v("c")])]),_._v(" "),e("li",[_._v("插入第二个字母"),e("code",[_._v("o")]),_._v("，发现"),e("code",[_._v("c")]),_._v("节点下方存在子节点"),e("code",[_._v("o")]),_._v("，则共享节点"),e("code",[_._v("o")])]),_._v(" "),e("li",[_._v("插入第三个字母"),e("code",[_._v("o")]),_._v("，发现"),e("code",[_._v("o")]),_._v("节点下方不存在子节点"),e("code",[_._v("o")]),_._v("，则创建子节点"),e("code",[_._v("o")])]),_._v(" "),e("li",[_._v("插入第四个字母"),e("code",[_._v("o")]),_._v("，发现"),e("code",[_._v("o")]),_._v("节点下方不存在子节点"),e("code",[_._v("k")]),_._v("，则创建子节点"),e("code",[_._v("k")])]),_._v(" "),e("li",[_._v("至此，单词"),e("code",[_._v("cook")]),_._v("中所有字母已被插入"),e("code",[_._v("Trie树")]),_._v("中，然后设置节点"),e("code",[_._v("k")]),_._v("中的标志位，标记路径"),e("code",[_._v("root")]),_._v("->"),e("code",[_._v("c")]),_._v("->"),e("code",[_._v("o")]),_._v("->"),e("code",[_._v("o")]),_._v("->"),e("code",[_._v("k")]),_._v("这条路径上所有节点的字符可以组成一个单词"),e("code",[_._v("cook")])])]),_._v(" "),e("h3",{attrs:{id:"四、trie-树的查询操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、trie-树的查询操作","aria-hidden":"true"}},[_._v("#")]),_._v(" 四、Trie 树的查询操作")]),_._v(" "),e("p",[_._v("在 Trie 树中查找一个字符串的时候，比如查找字符串"),e("code",[_._v("code")]),_._v("，可以将要查找的字符串分割成单个的字符 c，o，d，e，然后从 Trie 树的根节点开始匹配。如图所示，绿色的路径就是在 Trie 树中匹配的路径。")]),_._v(" "),e("p",[e("img",{attrs:{src:"trie04.jpg",alt:"images"}})]),_._v(" "),e("p",[_._v("如果要查找的是字符串"),e("code",[_._v("cod")]),_._v("呢？还是可以用上面同样的方法，从根节点开始，沿着某条路径来切尔西，如图所示，绿色的路径，是字符串"),e("code",[_._v("cod")]),_._v("匹配的路径。但是，路径的最后一个节点 d 并不是橙色的，并不是单词标志位，所以"),e("code",[_._v("cod")]),_._v("字符不存在。也就是说，"),e("code",[_._v("cod")]),_._v("是某个字符串的前缀子串，但并不能完全匹配任何字符串。")]),_._v(" "),e("p",[e("img",{attrs:{src:"trie05.jpg",alt:"images"}})]),_._v(" "),e("h3",{attrs:{id:"五、trie-树的删除操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、trie-树的删除操作","aria-hidden":"true"}},[_._v("#")]),_._v(" 五、Trie 树的删除操作")]),_._v(" "),e("p",[_._v("Trie 树的删除操作与二叉树的删除操作有类似的地方，需要考虑删除的节点所处的位置，这里分三种情况进行分析：")]),_._v(" "),e("h4",{attrs:{id:"_5-1-删除整个单词（比如-hi）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-删除整个单词（比如-hi）","aria-hidden":"true"}},[_._v("#")]),_._v(" 5.1 删除整个单词（比如 hi）")]),_._v(" "),e("p",[e("img",{attrs:{src:"trie06.gif",alt:"images"}})]),_._v(" "),e("ul",[e("li",[_._v("从根节点开始查找第一个字符"),e("code",[_._v("h")])]),_._v(" "),e("li",[_._v("找到"),e("code",[_._v("h")]),_._v("子节点后，继续查找"),e("code",[_._v("h")]),_._v("的下一个子节点"),e("code",[_._v("i")])]),_._v(" "),e("li",[e("code",[_._v("i")]),_._v("是单词"),e("code",[_._v("hi")]),_._v("的标志位，将该标志位去掉")]),_._v(" "),e("li",[e("code",[_._v("i")]),_._v("节点是"),e("code",[_._v("hi")]),_._v("的叶子节点，将其删除")]),_._v(" "),e("li",[_._v("删除后发现"),e("code",[_._v("h")]),_._v("节点为叶子节点，并且不是单词标志位，也将其删除")]),_._v(" "),e("li",[_._v("这样就完成了"),e("code",[_._v("hi")]),_._v("单词的删除操作")])]),_._v(" "),e("h4",{attrs:{id:"_5-2-删除前缀单词（比如-cod）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-删除前缀单词（比如-cod）","aria-hidden":"true"}},[_._v("#")]),_._v(" 5.2 删除前缀单词（比如 cod）")]),_._v(" "),e("p",[e("img",{attrs:{src:"trie07.gif",alt:"images"}})]),_._v(" "),e("p",[_._v("这种方式删除比较简单。")]),_._v(" "),e("p",[_._v("只需要将"),e("code",[_._v("cod")]),_._v("单词整个字符串查找完后，"),e("code",[_._v("d")]),_._v("节点因为不是叶子节点，只需将其单词标志去掉即可。")]),_._v(" "),e("h4",{attrs:{id:"_6-3-删除分支单词（比如-cook）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-删除分支单词（比如-cook）","aria-hidden":"true"}},[_._v("#")]),_._v(" 6.3 删除分支单词（比如 cook）")]),_._v(" "),e("p",[e("img",{attrs:{src:"trie08.gif",alt:"images"}})]),_._v(" "),e("p",[_._v("与"),e("strong",[_._v("删除整个单词")]),_._v("情况类似，区别点在于删除到"),e("code",[_._v("cook")]),_._v("的第一个"),e("code",[_._v("o")]),_._v("时，该节点为非叶子节点，停止删除，这样就完成"),e("code",[_._v("cook")]),_._v("字符串的删除操作。")]),_._v(" "),e("h3",{attrs:{id:"六、相关代码实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、相关代码实现","aria-hidden":"true"}},[_._v("#")]),_._v(" 六、相关代码实现")]),_._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br")])]),e("h3",{attrs:{id:"七、trie-树的应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七、trie-树的应用","aria-hidden":"true"}},[_._v("#")]),_._v(" 七、Trie 树的应用")]),_._v(" "),e("p",[_._v("事实上 Trie 树，在日常生活中的使用随处可见，比如这个：")]),_._v(" "),e("p",[_._v("具体来说就是经常用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。")]),_._v(" "),e("h4",{attrs:{id:"_7-1-前缀匹配"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-前缀匹配","aria-hidden":"true"}},[_._v("#")]),_._v(" 7.1 前缀匹配")]),_._v(" "),e("p",[_._v("例如：找出一个字符串集合中所有以"),e("code",[_._v("五分钟")]),_._v("开头的字符串。我们只需要用所有字符串构造一个 trie 树，然后输出以 五->分->钟 开头的路径上的关键字即可。")]),_._v(" "),e("p",[_._v("trie 树前缀切尔西常用于搜索提示。如当输入一个网址，可以自动搜索出融通的选择。当没有完全匹配搜索结果，可以返回前缀相似的可能。")]),_._v(" "),e("p",[e("img",{attrs:{src:"trie09.jpg",alt:"images"}})]),_._v(" "),e("h4",{attrs:{id:"_7-2-字符串检索"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-字符串检索","aria-hidden":"true"}},[_._v("#")]),_._v(" 7.2 字符串检索")]),_._v(" "),e("p",[_._v("给出 N 个单词组成的熟词表，以及一篇使用小写英文书写的文章，按最早出现的顺序写出所有不丰熟词表中的生词。")]),_._v(" "),e("p",[_._v("检索/查询功能是 Trie 树最原始的功能。给定一级字符串，查找某个字符串是否出现过，思路就是从根节点开始一个一个字符进行比较。")]),_._v(" "),e("ul",[e("li",[_._v("如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。")]),_._v(" "),e("li",[_._v("如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。")])]),_._v(" "),e("h3",{attrs:{id:"八、trie-树的局限性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#八、trie-树的局限性","aria-hidden":"true"}},[_._v("#")]),_._v(" 八、Trie 树的局限性")]),_._v(" "),e("p",[_._v("如前文所讲，Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。")]),_._v(" "),e("p",[_._v("假设字符的种数有"),e("code",[_._v("m")]),_._v("个，有若干个长度为"),e("code",[_._v("n")]),_._v("的字符串构成了一个"),e("code",[_._v("Trie")]),_._v("树 ，则每个节点的出度为"),e("code",[_._v("m")]),_._v("（即每个节点的可能子节点数量为 m），Trie 树 的高度为"),e("code",[_._v("n")]),_._v("。很明显我们浪费了大量的空间来存储字符，此时 Trie 树的最坏空间复杂度为 "),e("code",[_._v("O(m^n)")]),_._v("。也正由于每个节点的出度为 "),e("code",[_._v("m")]),_._v("，所以我们能够沿着树的一个个分支高效的向下逐个字符的查询，而不是遍历所有的字符串来查询，此时 Trie 树的最坏时间复杂度为 "),e("code",[_._v("O(n)")]),_._v("。")]),_._v(" "),e("p",[_._v("这正是空间换时间的体现，也是利用公共前缀降低查询时间开销的体现。")]),_._v(" "),e("h3",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料","aria-hidden":"true"}},[_._v("#")]),_._v(" 参考资料")]),_._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/Y5_r4C5a9gU0FDtqXD9bkQ",target:"_blank",rel:"noopener noreferrer"}},[_._v("看动画轻松理解「Trie 树」"),e("OutboundLink")],1)]),_._v(" "),e("li",[e("a",{attrs:{href:"https://time.geekbang.org/column/article/72414",target:"_blank",rel:"noopener noreferrer"}},[_._v("Trie 树：如何实现搜索引擎的搜索关键词提示功能？"),e("OutboundLink")],1)])]),_._v(" "),e("h2",{attrs:{id:"联系作者"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#联系作者","aria-hidden":"true"}},[_._v("#")]),_._v(" 联系作者")]),_._v(" "),e("div",{attrs:{align:"center"}},[e("p",[_._v("\n        平凡世界，贵在坚持。\n    ")]),_._v(" "),e("img",{attrs:{src:_.$withBase("/about/contact.png")}})])])}),[],!1,null,null,null);v.default=t.exports}}]);