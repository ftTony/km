(window.webpackJsonp=window.webpackJsonp||[]).push([[273],{495:function(e,s,a){"use strict";a.r(s);var n=a(13),t=Object(n.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"babel-学习"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel-学习"}},[e._v("#")]),e._v(" babel 学习")]),e._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),a("p",[e._v("Babel 是 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“转换编译器”。意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。")]),e._v(" "),a("h2",{attrs:{id:"内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内容"}},[e._v("#")]),e._v(" 内容")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#%E4%B8%80%E3%80%81%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91"}},[e._v("抽象语法树")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#%E4%BA%8C%E3%80%81babel-%E7%9A%84%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"}},[e._v("Babel 的处理步骤")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#%E4%B8%89%E3%80%81babel-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"}},[e._v("Babel 使用方法")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#%E5%9B%9B%E3%80%81%E5%85%B6%E4%BB%96%E9%85%8D%E5%A5%97%E5%B7%A5%E5%85%B7"}},[e._v("其他配套工具")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#%E4%BA%94%E3%80%81babel-%E6%8F%92%E4%BB%B6%E5%AE%9E%E8%B7%B5"}},[e._v("Babel 插件实践")])])]),e._v(" "),a("h3",{attrs:{id:"一、抽象语法树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、抽象语法树"}},[e._v("#")]),e._v(" 一、抽象语法树")]),e._v(" "),a("p",[e._v("这个处理过程中的每一步都涉及到创建或是操作抽象语法树，亦称 AST。")]),e._v(" "),a("blockquote",[a("p",[e._v("Babel 使用一个基于 ESTree 并修改过的 AST，它的内核说明文档可以在"),a("a",{attrs:{href:"https://github.com/babel/babel/blob/master/doc/ast/spec.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),a("OutboundLink")],1),e._v("找到。")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function square(n) {\n  return n * n;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("blockquote",[a("p",[a("a",{attrs:{href:"http://astexplorer.net/",target:"_blank",rel:"noopener noreferrer"}},[e._v("AST Explorer"),a("OutboundLink")],1),e._v("可以让你对 AST 节点有一个更好的感性认识。 "),a("a",{attrs:{href:"http://astexplorer.net/#/Z1exs6BWMq",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),a("OutboundLink")],1),e._v("是上述代码的一个示例链接。")])]),e._v(" "),a("p",[e._v("这个程序可以被表示成如下的一棵树：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("- FunctionDeclaration:\n  - id:\n    - Identifier:\n      - name: square\n  - params [1]\n    - Identifier\n      - name: n\n  - body:\n    - BlockStatement\n      - body [1]\n        - ReturnStatement\n          - argument\n            - BinaryExpression\n              - operator: *\n              - left\n                - Identifier\n                  - name: n\n              - right\n                - Identifier\n                  - name: n\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br")])]),a("p",[e._v("或是如下所示的 JavaScript Object（对象）：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n  type: "FunctionDeclaration",\n  id: {\n    type: "Identifier",\n    name: "square"\n  },\n  params: [{\n    type: "Identifier",\n    name: "n"\n  }],\n  body: {\n    type: "BlockStatement",\n    body: [{\n      type: "ReturnStatement",\n      argument: {\n        type: "BinaryExpression",\n        operator: "*",\n        left: {\n          type: "Identifier",\n          name: "n"\n        },\n        right: {\n          type: "Identifier",\n          name: "n"\n        }\n      }\n    }]\n  }\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br"),a("span",{staticClass:"line-number"},[e._v("25")]),a("br"),a("span",{staticClass:"line-number"},[e._v("26")]),a("br"),a("span",{staticClass:"line-number"},[e._v("27")]),a("br"),a("span",{staticClass:"line-number"},[e._v("28")]),a("br"),a("span",{staticClass:"line-number"},[e._v("29")]),a("br")])]),a("p",[e._v("你会留意到 AST 的每一层都拥有相同的结构：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n  type: "FunctionDeclaration",\n  id: {...},\n  params: [...],\n  body: {...}\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n  type: "Identifier",\n  name: ...\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n  type: "BinaryExpression",\n  operator: ...,\n  left: {...},\n  right: {...}\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("blockquote",[a("p",[e._v("注意：出于简化的目的移除了某些属性")])]),e._v(" "),a("p",[e._v("这样的每一层结构也被叫做"),a("strong",[e._v("节点（Node）")]),e._v("。一个 AST 可以由单一的节点或是成百上千个节点构成。它们组合在一些可以描述用于静态分析的程序语法。")]),e._v(" "),a("p",[e._v("每一个节点都有如下所示的接口（Interface）：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("interface Node {\n  type: string;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("字符串形式的"),a("code",[e._v("type")]),e._v("字段表示节点的类型（如："),a("code",[e._v('"FunctionDeclaration"')]),e._v("，"),a("code",[e._v('"Identifier"')]),e._v("，"),a("code",[e._v('"BinaryExpression"')]),e._v("）。每一种类型的节点定义了一些附加属性用来进一步描述该节点类型。")]),e._v(" "),a("p",[e._v("Babel 还为每个节点额外生成了一些属性，用于描述该节点在原始代码中的位置。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("{\n  type: ...,\n  start: 0,\n  end: 38,\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 3,\n      column: 1\n    }\n  },\n  ...\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br")])]),a("p",[e._v("每一个节点都会有"),a("code",[e._v("start")]),e._v("，"),a("code",[e._v("end")]),e._v("，"),a("code",[e._v("loc")]),e._v("这几个属性。")]),e._v(" "),a("h3",{attrs:{id:"二、babel-的处理步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、babel-的处理步骤"}},[e._v("#")]),e._v(" 二、Babel 的处理步骤")]),e._v(" "),a("p",[e._v("Babel 的三个主要处理步骤分别是："),a("strong",[e._v("解析(parse)")]),e._v("，"),a("strong",[e._v("转换(transform)")]),e._v("，"),a("strong",[e._v("生成(generate)")]),e._v("。")]),e._v(" "),a("h4",{attrs:{id:"_2-1-解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-解析"}},[e._v("#")]),e._v(" 2.1 解析")]),e._v(" "),a("p",[e._v("将代码解析成抽象语法树(AST)，每个 js 引擎(比如 Chrome 浏览器中的 V8 引擎)都有自己的 AST 解析器，而 Babel 是通过"),a("a",{attrs:{href:"https://github.com/babel/babylon",target:"_blank",rel:"noopener noreferrer"}},[e._v("Babylon"),a("OutboundLink")],1),e._v("实现的。在解析过程中有两个阶段："),a("strong",[e._v("词法分析")]),e._v("和"),a("strong",[e._v("语法分析")]),e._v("，词法分析阶段把字符串形式的代码转换为"),a("strong",[e._v("令牌")]),e._v("(tokens)流，令牌类似于 AST 中节点；而语法分析阶段则会把一个令牌流转换成 AST 的形式，同时这个阶段会把令牌中的信息转换成 AST 的表述结构。")]),e._v(" "),a("p",[a("strong",[e._v("词法分析")])]),e._v(" "),a("p",[e._v("词法分析阶段把字符串形式的代码转换为"),a("strong",[e._v("令牌")]),e._v("流。")]),e._v(" "),a("p",[e._v("你可以把令牌看作是一个扁平的语法片段数组：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("n * n;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('[\n  { type: { ... }, value: "n", start: 0, end: 1, loc: { ... } },\n  { type: { ... }, value: "*", start: 2, end: 3, loc: { ... } },\n  { type: { ... }, value: "n", start: 4, end: 5, loc: { ... } },\n  ...\n]\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("每一个"),a("code",[e._v("type")]),e._v("有一组属性来描述该令牌：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("{\n  type: {\n    label: 'name',\n    keyword: undefined,\n    beforeExpr: false,\n    startsExpr: true,\n    rightAssociative: false,\n    isLoop: false,\n    isAssign: false,\n    prefix: false,\n    postfix: false,\n    binop: null,\n    updateContext: null\n  },\n  ...\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br")])]),a("p",[e._v("和 AST 节点一样它们也有"),a("code",[e._v("start")]),e._v("、"),a("code",[e._v("end")]),e._v("、"),a("code",[e._v("loc")]),e._v("属性。")]),e._v(" "),a("p",[a("strong",[e._v("语法分析")])]),e._v(" "),a("p",[e._v("语法分析阶段会把一个令牌流转换成 AST 的形式。这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。")]),e._v(" "),a("h4",{attrs:{id:"_2-2-转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-转换"}},[e._v("#")]),e._v(" 2.2 转换")]),e._v(" "),a("p",[e._v("转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。这是 Babel 或是其他编译器中最复杂的过程同时也是插件将要介入工作的部分。")]),e._v(" "),a("h4",{attrs:{id:"_2-3-生成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-生成"}},[e._v("#")]),e._v(" 2.3 生成")]),e._v(" "),a("p",[e._v("代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射。")]),e._v(" "),a("p",[e._v("代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。")]),e._v(" "),a("p",[e._v("为了了解 Babel 在遍历时处理 AST 的具体过程，我们还需要了解下面几个重要知识点。")]),e._v(" "),a("h4",{attrs:{id:"_2-4-visitor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-visitor"}},[e._v("#")]),e._v(" 2.4 Visitor")]),e._v(" "),a("p",[e._v("当 Babel 处理一个节点时，是以访问者的形式获取节点信息，并进行相关操作，这种方式是通过一个 visitor 对象来完成的，在 visitor 对象中定义了对于各种节点的访问函数，这样就可以针对不同的节点做出不同的处理。我们编写的 Babel 插件其实也是通过定义一个实例化 visitor 对象处理一系列的 AST 节点来完成我们圣代的修改操作。举个例子：")]),e._v(" "),a("p",[e._v("我们想要处理代码中用来加载模块的 import 命令语句")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import { Ajax } from '../lib/utils';\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("那么我们的 Babel 插件就需要定义这样的一个 visitor 对象：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("visitor: {\n            Program: {\n                enter(path, state) {\n                    console.log('start processing this module...');\n                },\n                exit(path, state) {\n                    console.log('end processing this module!');\n                }\n            },\n    \t    ImportDeclaration (path, state) {\n            \tconsole.log('processing ImportDeclaration...');\n            \t// do something\n            }\n\t}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br")])]),a("p",[e._v("当把这个插件用于遍历中时，每当处理到一个 import 语句，即 ImportDeclaration 节点时，都会自动调用 ImportDeclaration()方法，这个方法中定义了处理 import 语句具体操作。ImportDeclaration()都是在进入 ImportDeclaration 节点时调用的，我们也可以让插件在退出节点时调用方法进行处理。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("visitor: {\n            ImportDeclaration: {\n                enter(path, state) {\n                    console.log('start processing ImportDeclaration...');\n                    // do something\n                },\n                exit(path, state) {\n                    console.log('end processing ImportDeclaration!');\n                    // do something\n                }\n            },\n\t}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br")])]),a("p",[e._v("当进入 ImportDeclaration 节点时调用 enter()方法，退出 ImportDeclaration 节点时调用 exit()方法。上面的 Program 节点（Program 节点可以通俗地解释为一个模块节点）也是一样的道理。值得注意的是，AST 的遍历采用深度优先遍历，所以上述 import 代码块的 AST 遍历的过程如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("─ Program.enter()\n  ─ ImportDeclaration.enter()\n  ─ ImportDeclaration.exit()\n─ Program.exit()\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("h4",{attrs:{id:"_2-5-path"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-path"}},[e._v("#")]),e._v(" 2.5 Path")]),e._v(" "),a("p",[e._v("从上面的 visitor 对象中，可以看到每次访问节点方法时，都会传入一个 path 参数，这个 path 参数中包含了节点的信息以及节点和所在的位置，以供对特定节点进行操作。具体来说 Path 是表示两个节点之间连接的对象。这个对象不仅包含了当前节点的信息，也有当前节点的父节点的信息，同时也包含了添加、更新、移动和删除节点有关的其他很多方法。具体地，Path 对象包含的属性和方法主要如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("── 属性\n  - node   当前节点\n  - parent  父节点\n  - parentPath 父path\n  - scope   作用域\n  - context  上下文\n  - ...\n── 方法\n  - get   当前节点\n  - findParent  向父节点搜寻节点\n  - getSibling 获取兄弟节点\n  - replaceWith  用AST节点替换该节点\n  - replaceWithMultiple 用多个AST节点替换该节点\n  - insertBefore  在节点前插入节点\n  - insertAfter 在节点后插入节点\n  - remove   删除节点\n  - ...\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br")])]),a("h4",{attrs:{id:"_2-6-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-state"}},[e._v("#")]),e._v(" 2.6 State")]),e._v(" "),a("p",[e._v("状态是抽象语法树 AST 转换的敌人，状态管理会不断牵扯我们的精力，而且几乎所有你对状态的假设，总是会有一些未考虑到的语法最终证明你的假设是错误的。")]),e._v(" "),a("h4",{attrs:{id:"_2-7-scopes-作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-scopes-作用域"}},[e._v("#")]),e._v(" 2.7 Scopes(作用域)")]),e._v(" "),a("p",[e._v("这里的作用域其实跟 js 说的作用域是一个道理，也就是说 babel 在处理 AST 时也需要考虑作用域的问题，比如函数内外的同名变量需要区分开来，这里直接拿 Babel 手册里的一个例子解释一下。考虑下列代码：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function square(n) {\n  return n * n;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("我们来写一个把 n 重命名为 x 的 visitor。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('visitor: {\n\t    FunctionDeclaration(path) {\n                const param = path.node.params[0];\n                paramName = param.name;\n                param.name = "x";\n             },\n\n            Identifier(path) {\n                if (path.node.name === paramName) {\n                  path.node.name = "x";\n                }\n             }\n\t}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br")])]),a("h3",{attrs:{id:"三、babel-使用方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、babel-使用方法"}},[e._v("#")]),e._v(" 三、Babel 使用方法")]),e._v(" "),a("ul",[a("li",[e._v("使用方法")]),e._v(" "),a("li",[e._v("插件")]),e._v(" "),a("li",[e._v("配置文件")]),e._v(" "),a("li",[e._v("preset")]),e._v(" "),a("li",[e._v("执行顺序")]),e._v(" "),a("li",[e._v("插件和 preset 的配置项")]),e._v(" "),a("li",[e._v("env (重点)")])]),e._v(" "),a("h4",{attrs:{id:"_3-1-使用方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-使用方法"}},[e._v("#")]),e._v(" 3.1 使用方法")]),e._v(" "),a("p",[e._v("总共存在三种方法：")]),e._v(" "),a("ul",[a("li",[e._v("使用单体文件(standalone script)")]),e._v(" "),a("li",[e._v("命令行(cli)")]),e._v(" "),a("li",[e._v("构建工具的插件(webpack 的 babel-loader,rollup 的 rollup-plugin-babel)。")])]),e._v(" "),a("p",[e._v("其中后面两种比较常见。第二种多见于 package.json 中的"),a("code",[e._v("scripts")]),e._v("段落中的某条命令；第三种就直接集成到构建工具中。")]),e._v(" "),a("p",[e._v("这三种方式只有入口不同而已，调用的 babel 内核，处理方式都是一样的，所以我们先不纠结入口的问题。")]),e._v(" "),a("h4",{attrs:{id:"_3-2-插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-插件"}},[e._v("#")]),e._v(" 3.2 插件")]),e._v(" "),a("p",[e._v("babel 本身不具有任何转化功能，它把转化的功能都分解到一个个 plugin 里面。因此当我们不配置任何插件时，经过 babel 的代码和输入是相同的。")]),e._v(" "),a("p",[e._v("插件总共分为两种：")]),e._v(" "),a("ul",[a("li",[e._v("当我们添加"),a("strong",[e._v("语法插件")]),e._v("之后，在解析这一步就使得 babel 能够解析更多的语法。（顺带一提，babel 内部使用的解析类库叫做 babylon，并非 babel 自行开发）")])]),e._v(" "),a("p",[e._v("举个简单的例子，当我们定义或者调用方法时，最后一个参数之后是不允许增加逗号的，如"),a("code",[e._v("callFoo(param1, param2,)")]),e._v("就是非法的。如果源码是这种写法，经过 babel 之后就会提示语法错误。")]),e._v(" "),a("p",[e._v("但最近的 JS 提案中已经允许了这种新的写法(让代码 diff 更加清晰)。为了避免 babel 报错，就需要增加语法插件"),a("code",[e._v("babel-plugin-syntax-trailing-function-commas")])]),e._v(" "),a("ul",[a("li",[e._v("当我们添加"),a("strong",[e._v("转译插件")]),e._v("之后，在转换这一步把源码转换并输出。这也是我们使用 babel 最本质的需求。")])]),e._v(" "),a("p",[e._v("比起语法插件，转译插件其实更好理解，比如箭头函数"),a("code",[e._v("(a) => a")]),e._v("就会转化为"),a("code",[e._v("function (a) {return a}")]),e._v("。完成这个工作的插件叫做"),a("code",[e._v("babel-plugin-transform-es2015-arrow-functions")]),e._v("。")]),e._v(" "),a("p",[e._v("同一类语法可能同时存在语法插件版本和转译插件版本。如果我们使用了转译插件，就不用再使用语法插件了。")]),e._v(" "),a("h4",{attrs:{id:"_3-3-配置文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-配置文件"}},[e._v("#")]),e._v(" 3.3 配置文件")]),e._v(" "),a("p",[e._v("既然插件是 babel 的根本，那如何使用呢？总共分为 2 个步骤：")]),e._v(" "),a("ol",[a("li",[e._v("将插件的名字增加到配置文件中(根目录下创建 .babelrc 或者 package.json 的"),a("code",[e._v("babel")]),e._v("里面，格式相同)")]),e._v(" "),a("li",[e._v("使用"),a("code",[e._v("npm install babel-plugin-xxx")]),e._v("进行安装")])]),e._v(" "),a("h4",{attrs:{id:"_3-4-preset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-preset"}},[e._v("#")]),e._v(" 3.4 preset")]),e._v(" "),a("p",[e._v("preset 分为以下几种：")]),e._v(" "),a("ol",[a("li",[e._v("官方内容，目前包括 env,react, flow, minify 等。这里最重要的是 env，后面会详细介绍。")]),e._v(" "),a("li",[e._v("stage-x，这里面包含的都是当年最新规范的草案，每年更新。\n"),a("ul",[a("li",[e._v("Stage 0 - 稻草人：只是一个想法，经过 TC39 成员提出即可。")]),e._v(" "),a("li",[e._v("Stage 1 - 提案：初步尝试。")]),e._v(" "),a("li",[e._v("Stage 2 - 初稿：完成初步规范。")]),e._v(" "),a("li",[e._v("Stage 3 - 候选：完成规范和浏览器初步实现。")]),e._v(" "),a("li",[e._v("Stage 4 - 完成：将被添加到下一年度发布。\n例如"),a("code",[e._v("syntax-dynamic-import")]),e._v("就是 stage-2 的内容，"),a("code",[e._v("transform-object-rest-spread")]),e._v("就是 stage-3 的内容。")])])])]),e._v(" "),a("p",[e._v("此外，低一级的 stage 会包含所有高级 stage 的内容，例如 stage-1 会包含 stage-2, stage-3 的所有内容。")]),e._v(" "),a("p",[e._v("stage-4 在下一年更新会直接放到 env 中，所以没有单独的 stage-4 可供使用。")]),e._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[e._v("es201x,latest")])]),e._v(" "),a("p",[e._v("这些是已经纳入到标准规范的语法。例如 es2015 包含 "),a("code",[e._v("arrow-functions")]),e._v("，es2017 包含 "),a("code",[e._v("syntax-trailing-function-commas")]),e._v("。但因为 env 的出现，使得 es2016 和 es2017 都已经废弃。所以我们经常可以看到 es2015 被单独列出来，但极少看到其他两个。")]),e._v(" "),a("p",[e._v("latest 是 env 的雏形，它是一个每年更新的 preset，目的是包含所有 es201x。但也是因为更加灵活的 env 的出现，已经废弃。")]),e._v(" "),a("h4",{attrs:{id:"_3-5-执行顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-执行顺序"}},[e._v("#")]),e._v(" 3.5 执行顺序")]),e._v(" "),a("p",[e._v("很简单的几条原则：")]),e._v(" "),a("ul",[a("li",[e._v("Plugin 会运行在 Preset 之前。")]),e._v(" "),a("li",[e._v("Plugin 会从前到后顺序执行。")]),e._v(" "),a("li",[e._v("Preset 的顺序则"),a("strong",[e._v("刚好相反")]),e._v("(从后向前)。")])]),e._v(" "),a("p",[e._v("preset 的逆向顺序主要是为了保证向后兼容，因为大多数用户的编写顺序是"),a("code",[e._v("['es2015', 'stage-0']")]),e._v("。这样必须先执行"),a("code",[e._v("stage-0")]),e._v("才能确保 babel 不报错。因此我们编排 preset 的时候，也要注意顺序，"),a("strong",[e._v("其实只要按照规范的时间顺序列出即可")]),e._v("。")]),e._v(" "),a("h4",{attrs:{id:"_3-6-插件和-preset-的配置项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-插件和-preset-的配置项"}},[e._v("#")]),e._v(" 3.6 插件和 preset 的配置项")]),e._v(" "),a("p",[e._v("简略情况下，插件和 preset 只要列出字符串格式的名字即可。但如果某个 preset 或者插件需要一些配置项(或者说参数)，就需要把自己先变成数组。第一个元素依然是字符串，表示自己的名字；第二个元素是一个对象，即配置对象。")]),e._v(" "),a("p",[e._v("最需要配置的当属 env，如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('"presets": [\n    // 带了配置项，自己变成数组\n    [\n        // 第一个元素依然是名字\n        "env",\n        // 第二个元素是对象，列出配置项\n        {\n          "module": false\n        }\n    ],\n\n    // 不带配置项，直接列出名字\n    "stage-2"\n]\n\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br")])]),a("h4",{attrs:{id:"_3-7-env-重点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-7-env-重点"}},[e._v("#")]),e._v(" 3.7 env (重点)")]),e._v(" "),a("p",[e._v("因为 env 最为常用也最重要，所以我们必须重点关注。")]),e._v(" "),a("p",[e._v("env 的核心目的是通过配置得知目标环境的特点，然后只做必要的转换。例如目标浏览器支持 es2015，那么 es2015 这个 preset 其实是不需要的，于是代码就可以小一点(一般转化后的代码总是更长)，构建时间也可以缩短一些。")]),e._v(" "),a("p",[e._v("如果不写任何任何配置项，env 等价于 latest，也等价于 es2015 + es2016 + es2017 三个相加(不包含 stage-x 中的插件)。env 包含的插件列表维护在"),a("a",{attrs:{href:"https://github.com/babel/babel-preset-env/blob/master/data/plugin-features.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("下面列出几种比较常用的配置方法：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n    "presets":[\n        {\n            "env":{\n                "targets":["last 2 versions", "safari >= 7"]\n            }\n        }\n    ]\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[e._v("如上配置将考虑所有浏览器的最新 2 个版本(safari 大于等于 7.0 的版本)的特性，将必要的代码进行转换。而这些版本已有的功能就不进行转化了。这里的语法可以参考"),a("a",{attrs:{href:"https://github.com/browserslist/browserslist",target:"_blank",rel:"noopener noreferrer"}},[e._v("browserslist"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n  "presets": [\n    ["env", {\n      "targets": {\n        "node": "6.10"\n      }\n    }]\n  ]\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[e._v("如上配置将目标设置为 nodejs，并且支持 6.10 及鸡皮疙瘩版本。也可以使用"),a("code",[e._v("node: 'current'")]),e._v("来支持最新稳定版本。例如箭头函数在 nodejs6 及以上将不被转化，但如果 nodejs 0.12 就会被转化了。")]),e._v(" "),a("p",[e._v("另外一个有用的配置项是"),a("code",[e._v("modules")]),e._v("。它的取值可以是"),a("code",[e._v("amd")]),e._v(", "),a("code",[e._v("umd")]),e._v(", "),a("code",[e._v("systemjs")]),e._v(", "),a("code",[e._v("commonjs")]),e._v(" 和 "),a("code",[e._v("false")]),e._v("。这可以让 babel 以特定的模块化格式来输出代码。如果选择"),a("code",[e._v("false")]),e._v(" 就不进行模块化处理。")]),e._v(" "),a("h3",{attrs:{id:"四、其他配套工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、其他配套工具"}},[e._v("#")]),e._v(" 四、其他配套工具")]),e._v(" "),a("ul",[a("li",[e._v("babel-cli")]),e._v(" "),a("li",[e._v("babel-node")]),e._v(" "),a("li",[e._v("babel-register")]),e._v(" "),a("li",[e._v("babel-polyfill")]),e._v(" "),a("li",[e._v("babel-runtime 和 babel-plugin-transform-runtime")]),e._v(" "),a("li",[e._v("babel-loader")]),e._v(" "),a("li",[e._v("babylon")]),e._v(" "),a("li",[e._v("babel-traverse")]),e._v(" "),a("li",[e._v("babel-types")])]),e._v(" "),a("h4",{attrs:{id:"_4-1-babel-cli"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-babel-cli"}},[e._v("#")]),e._v(" 4.1 babel-cli")]),e._v(" "),a("p",[e._v("顾名思义，cli 就是命令行工具。安装了"),a("code",[e._v("babel-cli")]),e._v("就能够在命令行中使用"),a("code",[e._v("babel")]),e._v("命令来编译文件。")]),e._v(" "),a("p",[e._v("在开发 npm package 时经常会使用如下模式：")]),e._v(" "),a("ul",[a("li",[e._v("把"),a("code",[e._v("babel-cli")]),e._v("安装为"),a("code",[e._v("devDependencies")])]),e._v(" "),a("li",[e._v("在 package.json 中添加"),a("code",[e._v("scripts")]),e._v("(比如"),a("code",[e._v("prepublish")]),e._v(")，使用"),a("code",[e._v("babel")]),e._v("命令编译文件")]),e._v(" "),a("li",[a("code",[e._v("npm puhlish")])])]),e._v(" "),a("p",[e._v("这样既可以使用较新规范的 JS 语法编写源码，同时又能支持旧版环境。因为项目可能不太大，用不到构建工具(webpack 或者 rollup)，于是在发布之前用"),a("code",[e._v("babel-cli")]),e._v("进行处理。")]),e._v(" "),a("h4",{attrs:{id:"_4-2-babel-node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-babel-node"}},[e._v("#")]),e._v(" 4.2 babel-node")]),e._v(" "),a("p",[a("code",[e._v("babel-node")]),e._v("是"),a("code",[e._v("babel-cli")]),e._v("的一部分，它不需要单独安装。")]),e._v(" "),a("p",[e._v("它的作用是在 node 环境中，直接运行 es2015 的代码，而不需要额外进行转码。例如我们有一个 js 文件以 es2015 的语法进行编写进行编写(如使用了箭头函数)。我们可以直接使用"),a("code",[e._v("babel-node es2015.js")]),e._v("进行执行，而不用再进行转码了。")]),e._v(" "),a("p",[e._v("可以说："),a("code",[e._v("babel-node")]),e._v(" = "),a("code",[e._v("babel-polyfill")]),e._v(" + "),a("code",[e._v("babel-register")]),e._v("。")]),e._v(" "),a("h4",{attrs:{id:"_4-3-babel-register"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-babel-register"}},[e._v("#")]),e._v(" 4.3 babel-register")]),e._v(" "),a("p",[e._v("babel-register 模块必写"),a("code",[e._v("require")]),e._v("命令，为它加上一个钩子。此后，每当使用"),a("code",[e._v("require")]),e._v("加载"),a("code",[e._v(".js")]),e._v("、"),a("code",[e._v(".jsx")]),e._v("、"),a("code",[e._v(".es")]),e._v("和"),a("code",[e._v(".es6")]),e._v("后缀名的文件，就会先用 babel 进行转码。")]),e._v(" "),a("p",[e._v("使用时，必须首先加载"),a("code",[e._v("require('babel-register')")]),e._v("。")]),e._v(" "),a("p",[e._v("需要注意的是，babel-register 只会对"),a("code",[e._v("require")]),e._v("命令加载的文件转码，而"),a("strong",[e._v("不会对当前文件转码")]),e._v("。")]),e._v(" "),a("p",[e._v("另外，由于它是实时转码，所以"),a("strong",[e._v("只适合在开发环境使用")]),e._v("。")]),e._v(" "),a("h4",{attrs:{id:"_4-4-babel-polyfill"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-babel-polyfill"}},[e._v("#")]),e._v(" 4.4 babel-polyfill")]),e._v(" "),a("p",[e._v("babel 默认只转换 js 语法，而不转换新的 API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法(比如"),a("code",[e._v("Object.assign")]),e._v(")都不会转码。")]),e._v(" "),a("p",[e._v("举例来说，es2015 在 Array 对象上新增了"),a("code",[e._v("Array.from")]),e._v("方法。babel 就不会转码这个方法。如果想让这个方法运行，必须使用"),a("code",[e._v("babel-polyfill")]),e._v("。(内部集成了"),a("code",[e._v("core-js")]),e._v("和"),a("code",[e._v("regenerator")]),e._v(")")]),e._v(" "),a("p",[e._v("使用时，在所有代码运行之前增加"),a("code",[e._v("require('babel-polyfill')")]),e._v("。或者更常规的操作是在"),a("code",[e._v("webpack.config.js")]),e._v("中将"),a("code",[e._v("babel-polyfill")]),e._v("作为第一个 entry。因此必须把"),a("code",[e._v("babel-polyfill")]),e._v("作为"),a("code",[e._v("dependencies")]),e._v("而不是"),a("code",[e._v("devDependencies")])]),e._v(" "),a("p",[a("code",[e._v("babel-polyfill")]),e._v("主要有两个缺点：")]),e._v(" "),a("ul",[a("li",[e._v("使用"),a("code",[e._v("babel-polyfill")]),e._v("会导致打出来的包非常大，因为"),a("code",[e._v("babel-polyfill")]),e._v("是一个整体，把所有方法都加到原型链上。比如我们只使用了"),a("code",[e._v("Array.from")]),e._v("，但它把"),a("code",[e._v("Object.defineProperty")]),e._v("也给加上了，这就是一种浪费了。这个问题可以通过单独"),a("code",[e._v("core-js")]),e._v("的某个类库来解决，"),a("code",[e._v("core-js")]),e._v("都是分开的。")]),e._v(" "),a("li",[a("code",[e._v("babel-polyfill")]),e._v("会污染全局变量，给很多类的原型链上都作了修改，如果我们开发的也是一个类库供其他开发者使用，这种情况就会变得非常不可控。")])]),e._v(" "),a("p",[e._v("因此在实际使用中，如果我们无法忍受这两个缺点(尤其是第二个)，通常我们会倾向于使用"),a("code",[e._v("babel-plugin-transform-runtime")]),e._v("。")]),e._v(" "),a("p",[e._v("但如果代码中包含高版本 js 中类型的实例方法 (例如"),a("code",[e._v("[1,2,3].includes(1)")]),e._v(")，这还是要使用 polyfill。")]),e._v(" "),a("h4",{attrs:{id:"_4-5-babel-runtime-和-babel-plugin-transform-runtime"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-babel-runtime-和-babel-plugin-transform-runtime"}},[e._v("#")]),e._v(" 4.5 babel-runtime 和 babel-plugin-transform-runtime")]),e._v(" "),a("p",[e._v("我们时常在项目中看到.babelrc 中使用"),a("code",[e._v("babel-plugin-transform-runtime")]),e._v("，而"),a("code",[e._v("package.json")]),e._v("中的"),a("code",[e._v("dependencies")]),e._v("(注意不是"),a("code",[e._v("devDependencies")]),e._v(")又包含了"),a("code",[e._v("babel-runtime")]),e._v("，那这两个是不是成套使用的呢？他们又起什么作用呢？")]),e._v(" "),a("p",[e._v("先说"),a("code",[e._v("babel-plugin-transform-runtime")]),e._v("。")]),e._v(" "),a("p",[e._v("babel 会转换 js 语法，之前已经提过了。以"),a("code",[e._v("async/await")]),e._v("举例，如果不使用这个 plugin(即默认情况)，转换后的代码大概是：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// babel 添加一个方法，把 async 转化为 generator\nfunction _asyncToGenerator(fn) { return function () {....}} // 很长很长一段\n\n// 具体使用处\nvar _ref = _asyncToGenerator(function* (arg1, arg2) {\n  yield (0, something)(arg1, arg2);\n});\n\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("p",[e._v("不用过于纠结具体的语法，只需看到，这个"),a("code",[e._v("_asyncToGenerator")]),e._v("在当前文件被定义，然后被使用了，以替换源代码的"),a("code",[e._v("await")]),e._v("。但每个被转化的文件都会插入一段 "),a("code",[e._v("_asyncToGenerator")]),e._v("这就导致重复和浪费了。")]),e._v(" "),a("p",[e._v("在使用了"),a("code",[e._v("babel-plugin-transform-runtime")]),e._v("了之后，转化后的代码会变成")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 从直接定义改为引用，这样就不会重复定义了。\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\n// 具体使用处是一样的\nvar _ref = _asyncToGenerator3(function* (arg1, arg2) {\n  yield (0, something)(arg1, arg2);\n});\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("p",[e._v("从定义方法改成引用，那重复定义就变成了重复引用，就不存在代码重复的问题了。")]),e._v(" "),a("p",[e._v("但在这里，我们也发现"),a("code",[e._v("babel-runtime")]),e._v("出场了，它就是这些方法的集合处，也因此，"),a("strong",[e._v("在使用"),a("code",[e._v("babel-plugin-transform-runtime")]),e._v("的时候必须把"),a("code",[e._v("babel-runtime")])])]),e._v(" "),a("p",[e._v("再说"),a("code",[e._v("babel-runtime")]),e._v("，它内部集成了")]),e._v(" "),a("ol",[a("li",[a("code",[e._v("core-js")]),e._v("：转换一些内置类("),a("code",[e._v("Promise")]),e._v("，"),a("code",[e._v("Symbols")]),e._v("等等)和静态方法("),a("code",[e._v("Array.from")]),e._v("等)。绝大部分转换是这里做的。自动引入。")]),e._v(" "),a("li",[a("code",[e._v("regenerator")]),e._v("：作为"),a("code",[e._v("core-js")]),e._v("的拾遗补漏，主要是"),a("code",[e._v("generator/yield")]),e._v("和"),a("code",[e._v("async/await")]),e._v("两组的支持。当代码中有使用"),a("code",[e._v("generators/async")]),e._v("时自动引入。")]),e._v(" "),a("li",[e._v("helpers，如上面的"),a("code",[e._v("asyncToGenerator")]),e._v("就是其中之一，其他还有如"),a("code",[e._v("jsx")]),e._v(", "),a("code",[e._v("classCallCheck")]),e._v("等等，可以查看"),a("a",{attrs:{href:"https://github.com/babel/babel/blob/6.x/packages/babel-helpers/src/helpers.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("babel-helpers"),a("OutboundLink")],1),e._v("。在代码中有内置的 helpers 使用时(如上面的第一段代码)移除定义，并插入引用(于是就变成了第二段代码)")])]),e._v(" "),a("p",[a("code",[e._v("babel-plugin-transform-runtime")]),a("strong",[e._v("不支持")]),e._v("实例方法（例如"),a("code",[e._v("[1,2,3].includes(1)")]),e._v("）")]),e._v(" "),a("h4",{attrs:{id:"_4-6-babel-loader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-babel-loader"}},[e._v("#")]),e._v(" 4.6 babel-loader")]),e._v(" "),a("p",[e._v("前面提过 babel 的三种使用方法，并且已经介绍过了 babel-cli。但一些大型的项目都会有构建工具 (如 webpack 或 rollup) 来进行代码构建和压缩 (uglify)。理论上来说，我们也可以对压缩后的代码进行 babel 处理，但那会非常慢。因此如果在 uglify 之前就加入 babel 处理，岂不完美？")]),e._v(" "),a("p",[e._v("所以就有了 babel 插入到构建工具内部这样的需求。以(我还算熟悉的) webpack 为例，webpack 有 loader 的概念，因此就出现了 babel-loader。")]),e._v(" "),a("p",[e._v("和"),a("code",[e._v("babel-cli")]),e._v("一样，"),a("code",[e._v("babel-loader")]),e._v("也会读取 .babelrc 或者 package.json 中的"),a("code",[e._v("babel")]),e._v("段作为自己的配置，之后的内核处理也是相同。唯一比"),a("code",[e._v("babel-cli")]),e._v("复杂的是，它需要和 webpack 交互，因此需要在 webpack 这边进行配置。比较常见的如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("module: {\n  rules: [\n    {\n      test: /\\.js$/,\n      exclude: /(node_modules|bower_components)/,\n      loader: 'babel-loader'\n    }\n  ]\n}\n\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br")])]),a("p",[e._v("如果想在这里传入 babel 的配置项，也可以把改成：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// loader: 'babel-loader' 改成如下：\nuse: {\n  loader: 'babel-loader',\n  options: {\n    // 配置项在这里\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("p",[e._v("这里的配置项优先级是最高的。但我认为放到单独的配置文件中更加清晰合理，可读性强一些。")]),e._v(" "),a("h4",{attrs:{id:"_4-7-babylon"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-babylon"}},[e._v("#")]),e._v(" 4.7 Babylon")]),e._v(" "),a("p",[e._v("可以说 Babylon 定义了把代码解析成 AST 的一套规范。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import * as babylon from "babylon";\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nbabylon.parse(code);\n// Node {\n//   type: "File",\n//   start: 0,\n//   end: 38,\n//   loc: SourceLocation {...},\n//   program: Node {...},\n//   comments: [],\n//   tokens: [...]\n// }\n\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br")])]),a("h4",{attrs:{id:"_4-8-babel-traverse"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-8-babel-traverse"}},[e._v("#")]),e._v(" 4.8 babel-traverse")]),e._v(" "),a("p",[e._v("babel-traverse 用于维护操作 AST 的状态，定义了更新、添加和移除节点的操作方法。之前也说到，path 参数里面的属性和方法都是在 babel-traverse 里面定义的。这里还是引用一个例子，将 babel-traverse 和 Babylon 一起使用来遍历和更新节点：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import * as babylon from "babylon";\nimport traverse from "babel-traverse";\n\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nconst ast = babylon.parse(code);\n\ntraverse(ast, {\n  enter(path) {\n    if (\n      path.node.type === "Identifier" &&\n      path.node.name === "n"\n    ) {\n      path.node.name = "x";\n    }\n  }\n});\n\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br")])]),a("h4",{attrs:{id:"_4-9-babel-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-9-babel-types"}},[e._v("#")]),e._v(" 4.9 babel-types")]),e._v(" "),a("p",[e._v("babel-types 是一个强大的用于处理 AST 节点的工具库，“它包含了构造、验证以及变换 AST 节点的方法。该工具库包含考虑周到的工具方法，对编写处理 AST 逻辑非常有用”")]),e._v(" "),a("p",[e._v("这里我们还是用 import 命令来演示一个例子，比如我们要判断 import 导入是什么类型的导入，这里先写出三种形式的导入：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import { Ajax } from '../lib/utils';\nimport utils from '../lib/utils';\nimport * as utils from '../lib/utils';\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("在 AST 中用于表示上面导入的三个变量的节点是不同的，分别叫做 ImportSpecifier、ImportDefaultSpecifier 和 ImportNamespaceSpecifier。如果我们只对导入指定变量的 import 命令语句做处理，那么我们的 babel 插件就可以这样写：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function plugin () {\n\treturn ({ types }) => ({\n\t    visitor: {\n\t        ImportDeclaration (path, state) {\n        \t    const specifiers = path.node.specifiers;\n        \t    specifiers.forEach((specifier) => {\n\t                if (!types.isImportDefaultSpecifier(specifier) && !types.isImportNamespaceSpecifier(specifier)) {\n            \t        // do something\n            \t    }\n    \t        })\n            }\n        }\n    })\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br")])]),a("h4",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("名称")]),e._v(" "),a("th",[e._v("作用")]),e._v(" "),a("th",[e._v("备注")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("babel-cli")]),e._v(" "),a("td",[e._v("允许命令行使用 babel 命令转译文件")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("babel-node")]),e._v(" "),a("td",[e._v("允许命令行使用 babel-node 直接转译+执行 node 文件")]),e._v(" "),a("td",[e._v("随"),a("code",[e._v("babel-cli")]),e._v("一同安装 "),a("code",[e._v("babel-node")]),e._v("="),a("code",[e._v("babel-polyfill")]),e._v("+"),a("code",[e._v("babel-register")])])]),e._v(" "),a("tr",[a("td",[e._v("babel-register")]),e._v(" "),a("td",[e._v("改写"),a("code",[e._v("require")]),e._v("命令，为其加载的文件进行转码，不对当前文件转码")]),e._v(" "),a("td",[e._v("只适用于开发环境")])]),e._v(" "),a("tr",[a("td",[e._v("babel-polyfill")]),e._v(" "),a("td",[e._v("为所有 API 增加兼容方法")]),e._v(" "),a("td",[e._v("需要在所有代码之前"),a("code",[e._v("require")]),e._v("，且体积比较大")])]),e._v(" "),a("tr",[a("td",[e._v("babel-plugin-transform-runtime & babel-runtime")]),e._v(" "),a("td",[e._v("把帮助类方法从每次使用前定义改为统一 "),a("code",[e._v("require")]),e._v("，精简代码")]),e._v(" "),a("td",[a("code",[e._v("babel-runtime")]),e._v("需要安装为依赖，而不是开发依赖")])]),e._v(" "),a("tr",[a("td",[e._v("babel-loader")]),e._v(" "),a("td",[e._v("使用 webpack 时作为一个 loader 在代码混淆之前进行代码转换")]),e._v(" "),a("td")])])]),e._v(" "),a("h3",{attrs:{id:"五、babel-插件实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、babel-插件实践"}},[e._v("#")]),e._v(" 五、Babel 插件实践")]),e._v(" "),a("h4",{attrs:{id:"_5-1-插件格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-插件格式"}},[e._v("#")]),e._v(" 5.1 插件格式")]),e._v(" "),a("p",[e._v("先从一个接收了当前"),a("code",[e._v("Babel")]),e._v("对象作为参数的"),a("code",[e._v("Function")]),e._v("开始。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export default function(bable){\n  // plugin contents\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("我们经常会这样写")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export default function({types:t}){\n  //\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("接着返回一个对象，其"),a("code",[e._v("visitor")]),e._v("属性是这个插件的主要访问者。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export default function({ types: t }) {\n  return {\n    visitor: {\n      // visitor contents\n    }\n  };\n};\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("p",[a("code",[e._v("visitor")]),e._v("中的每个函数接收 2 个参数："),a("code",[e._v("path")]),e._v("和"),a("code",[e._v("state")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export default function({types:1}){\n  return {\n    visitor:{\n      CallExpression(path, state) {}\n    }\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("h4",{attrs:{id:"_5-2-写一个简单的插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-写一个简单的插件"}},[e._v("#")]),e._v(" 5.2 写一个简单的插件")]),e._v(" "),a("p",[e._v("我们写一个简单的插件，把所有定义变量名为"),a("code",[e._v("a")]),e._v("的换成"),a("code",[e._v("b")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export default function({types:t}){\n  return {\n    visitor:{\n      VariableDeclarator(path, state) {\n        if(path.node.id.name == 'a'){\n          path.node.id = t.identifier('b')\n        }\n      }\n    }\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br")])]),a("p",[e._v("我们要把"),a("code",[e._v("id")]),e._v("属性是 a 的替换成 b 就好了。但是这里不能直接"),a("code",[e._v("path.node.id.name = 'b'")]),e._v(" 。如果操作的是 Object，就没问题，但是这里是 AST 语法树，所以想改变某个值，就是用对应的 AST 来替换，现在我们用新的标识符来替换这个属性。")]),e._v(" "),a("h3",{attrs:{id:"参考资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://juejin.im/post/5c19c5e0e51d4502a232c1c6",target:"_blank",rel:"noopener noreferrer"}},[e._v("一口(很长的)气了解 babel"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/5c21b584e51d4548ac6f6c99",target:"_blank",rel:"noopener noreferrer"}},[e._v("深入 Babel，这一篇就够了"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/XSzQ5nkLI369CDhMZtF-MQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端中的编译原理 - 从零打造一个实用的 Babel 插件"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/HdIvS75nJ0JFStoNPIl7Iw",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端工程师需要了解的 Babel 知识"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/5d94bfbf5188256db95589be",target:"_blank",rel:"noopener noreferrer"}},[e._v("深入浅出 Babel 上篇：架构和原理 + 实战"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/5da12397e51d4578364f6ffa",target:"_blank",rel:"noopener noreferrer"}},[e._v("深入浅出 Babel 下篇：既生 Plugin 何生 Macros"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Babel 插件手册"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/frontend9/fe9-library/issues/154",target:"_blank",rel:"noopener noreferrer"}},[e._v("Babel 插件原理的理解与深入"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/27289600",target:"_blank",rel:"noopener noreferrer"}},[e._v("Babel 是如何读懂 JS 代码的"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/5ddff3abe51d4502d56bd143",target:"_blank",rel:"noopener noreferrer"}},[e._v("不容错过的 Babel7 知识"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"联系作者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#联系作者"}},[e._v("#")]),e._v(" 联系作者")]),e._v(" "),a("div",{attrs:{align:"center"}},[a("p",[e._v("\n        平凡世界，贵在坚持。\n    ")]),e._v(" "),a("img",{attrs:{src:e.$withBase("/about/contact.png")}})])])}),[],!1,null,null,null);s.default=t.exports}}]);