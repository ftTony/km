(window.webpackJsonp=window.webpackJsonp||[]).push([[169],{399:function(a,e,r){"use strict";r.r(e);var t=r(4),s=Object(t.a)({},(function(){var a=this,e=a.$createElement,r=a._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"js-内存泄漏、监控和分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js-内存泄漏、监控和分析","aria-hidden":"true"}},[a._v("#")]),a._v(" JS 内存泄漏、监控和分析")]),a._v(" "),r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),r("p",[a._v("本人平时学习及收集内容，欢迎参入一起讨论。")]),a._v(" "),r("h2",{attrs:{id:"内容"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内容","aria-hidden":"true"}},[a._v("#")]),a._v(" 内容")]),a._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"}},[a._v("内存泄漏的定义以及为什么发生内存泄漏？")])]),a._v(" "),r("li",[r("a",{attrs:{href:"#%E4%BA%8C%E3%80%81%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E5%BC%95%E8%B5%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"}},[a._v("哪些情况会引起内存泄漏")])]),a._v(" "),r("li",[r("a",{attrs:{href:"#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95"}},[a._v("内存泄漏的识别方法")])])]),a._v(" "),r("h3",{attrs:{id:"一、内存泄漏的定义以及为什么发生内存泄漏？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、内存泄漏的定义以及为什么发生内存泄漏？","aria-hidden":"true"}},[a._v("#")]),a._v(" 一、内存泄漏的定义以及为什么发生内存泄漏？")]),a._v(" "),r("p",[r("strong",[a._v("内存泄漏")]),a._v("是指申请的内存没有及时回收掉，被泄漏了。")]),a._v(" "),r("p",[a._v("虽然前端有垃圾回收机制，但当某块无用的内存，却无法被垃圾回收机制认为是垃圾时，也就发生内存泄漏了")]),a._v(" "),r("p",[a._v("而垃圾回收机制通常是使用标志清除策略，简单说，也就是引用引用从根节点开始是否可达来判定是否是垃圾")]),a._v(" "),r("p",[a._v("上面是发生内存泄漏的根本原因，直接原因则是，当不同生命周期的两个东西相互通信时，一方生命到期该回收了，去被另一方还持有时，也就发生内存泄漏了")]),a._v(" "),r("h3",{attrs:{id:"二、哪些情况会引起内存泄漏"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、哪些情况会引起内存泄漏","aria-hidden":"true"}},[a._v("#")]),a._v(" 二、哪些情况会引起内存泄漏")]),a._v(" "),r("ul",[r("li",[a._v("意外的全局变量")]),a._v(" "),r("li",[a._v("遗忘的定时器")]),a._v(" "),r("li",[a._v("使用不当的闭包")]),a._v(" "),r("li",[a._v("遗漏的 DOM 元素")]),a._v(" "),r("li",[a._v("网络回调")])]),a._v(" "),r("h4",{attrs:{id:"_2-1-意外的全局变量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-意外的全局变量","aria-hidden":"true"}},[a._v("#")]),a._v(" 2.1 意外的全局变量")]),a._v(" "),r("p",[a._v("全局变量的生命周期最长，直到页面关闭前，它都存活着，所以全局变量上的内存一直不会被回收")]),a._v(" "),r("p",[a._v("当全局变量使用不当，没有及时回收（手动赋值 null），或者拼写错误等将某个变量挂载到全局变量时，也就发生内存泄漏了")]),a._v(" "),r("p",[a._v("示例代码：")]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("function foo(){\n    bar1 = 'some text';         // 没有声明变量  实际上是全局变量 => window.bar1\n    this.bar2= 'some text';     //  全局变量=> window.bar2\n}\nfoo();\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br")])]),r("p",[a._v("在这个例子中，意外的创建了两个全局变量 bar1 和 bar2")]),a._v(" "),r("h4",{attrs:{id:"_2-2-遗忘的定时器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-遗忘的定时器","aria-hidden":"true"}},[a._v("#")]),a._v(" 2.2 遗忘的定时器")]),a._v(" "),r("p",[a._v("setTimeout 和 setInterval 是由浏览器专门线程来维护它的生命周期，所以当在某个页面使用了定时器，当该页面销毁时，没有手动去释放清理这些定时器的话，那么这些定时器还是存活着的")]),a._v(" "),r("p",[a._v("也就是说，定时器的生命周期并不挂靠在页面上，所以当在当前页面的 js 里通过定时器注册了某个回调函数，而该回调函数内又持有当前页面某个变量或某些 DOM 元素时，就会导致即使页面销毁了，由于定时器持有该页面部分引用而造成页面无法正常被回收，从而导致内存泄漏了")]),a._v(" "),r("p",[a._v("如果此时再次打开同个页面，内存中其实是有双份页面数据的，如果多次关闭、打开，那么内存泄漏会越来越严重")]),a._v(" "),r("p",[a._v("而且这种场景很容易出现，因为使用定时器的人很容易遗忘清除")]),a._v(" "),r("p",[a._v("代码如下：")]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("var serverData = loadData();\nsetInterval(function(){\n    var render = document.getElementById('render');\n    if(render){\n        render.innerHTML = JSON.stringify(serverData);\n    }\n},5000)\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br"),r("span",{staticClass:"line-number"},[a._v("6")]),r("br"),r("span",{staticClass:"line-number"},[a._v("7")]),r("br")])]),r("p",[a._v("如果后续 renderer 元素被移除，整个定时器实际上没有任何作用。但如果你没有回收定时器，整个定时器依然有效, 不但定时器无法被内存回收， 定时器函数中的依赖也无法回收。在这个案例中的 serverData 也无法被回收。")]),a._v(" "),r("h4",{attrs:{id:"_2-3-使用不当的闭包"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-使用不当的闭包","aria-hidden":"true"}},[a._v("#")]),a._v(" 2.3 使用不当的闭包")]),a._v(" "),r("p",[a._v("函数本身会持有它定义时所在的记法环境的引用，但通常情况下，使用完函数后，该函数所申请的内存都会被回收了")]),a._v(" "),r("p",[a._v("但当函数再返回一个函数时，由于返回的函数持有有外部函数的词法环境，而返回的函数又被其他生命周期东西所持有，导致外部函数虽然执行完了，但内存却无法被回收")]),a._v(" "),r("p",[a._v("所以，返回的函数，它的生命周期应尽量不宜过长，方便该装饰能够及时被回收")]),a._v(" "),r("p",[a._v("正常来说，闭包并不是内存泄漏，因为这种持有外部函数词法环境本就闭包的特性，就是为了让这块内存不被回收，因为可能在未来还需要用到，但这无疑会造成内存的消耗，所以，不宜烂用就是了")]),a._v(" "),r("p",[a._v("相关代码：")]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("var theThing = null;\nvar replaceThing = function(){\n    var originalThing = theThing;\n    var unused = function(){\n        if(originalThing){  // 对于 'originalThing'的引用\n            console.log('hi');\n        }\n    };\n    theThing = {\n        longStr: new Array(100000).join('*'),\n        someMethod:function(){\n            console.log('message');\n        }\n    }\n}\nsetInterval(replaceThing,1000);\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br"),r("span",{staticClass:"line-number"},[a._v("6")]),r("br"),r("span",{staticClass:"line-number"},[a._v("7")]),r("br"),r("span",{staticClass:"line-number"},[a._v("8")]),r("br"),r("span",{staticClass:"line-number"},[a._v("9")]),r("br"),r("span",{staticClass:"line-number"},[a._v("10")]),r("br"),r("span",{staticClass:"line-number"},[a._v("11")]),r("br"),r("span",{staticClass:"line-number"},[a._v("12")]),r("br"),r("span",{staticClass:"line-number"},[a._v("13")]),r("br"),r("span",{staticClass:"line-number"},[a._v("14")]),r("br"),r("span",{staticClass:"line-number"},[a._v("15")]),r("br"),r("span",{staticClass:"line-number"},[a._v("16")]),r("br")])]),r("h4",{attrs:{id:"_2-4-遗漏的-dom-元素"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-遗漏的-dom-元素","aria-hidden":"true"}},[a._v("#")]),a._v(" 2.4 遗漏的 DOM 元素")]),a._v(" "),r("p",[a._v("DOM 元素的生命周期正常是取决于是否挂载在 DOM 树上，当从 DOM 树上移除时，也就可以被销毁回收了")]),a._v(" "),r("p",[a._v("但如果某个 DOM 元素，在 js 中也持有它的引用时，那么它的生命周期就由 js 和是否在 DOM 树上两者决定了，记得移除时，两个地方都需要去清理才能正常回收它")]),a._v(" "),r("h4",{attrs:{id:"_2-5-网络回调"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-网络回调","aria-hidden":"true"}},[a._v("#")]),a._v(" 2.5 网络回调")]),a._v(" "),r("p",[a._v("某此场景中，在某个页面发起网络请求，并注册一个回调，且回调函数内持有该页面某些内容，那么，当该页面销毁时，应该注销网络的回调，否则，因为网络持有页面部分内容，也会导致页面部分内容无法被回收")]),a._v(" "),r("h3",{attrs:{id:"三、内存泄漏的识别方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、内存泄漏的识别方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 三、内存泄漏的识别方法")]),a._v(" "),r("ul",[r("li",[a._v("使用 Chrome 任务管理器实时监视内存使用打开 chrome 浏览器")]),a._v(" "),r("li",[a._v("利用 Chrome 时间轴记录可视化内存泄漏")]),a._v(" "),r("li",[a._v("使用堆快照发现已经分离 DOM 树的内存泄漏")]),a._v(" "),r("li",[a._v("按函数调查内存分配打开面板")])]),a._v(" "),r("p",[a._v("具体分析和监控可参考"),r("a",{attrs:{href:"https://mp.weixin.qq.com/s/5qDzvMLx_DAMWOwU7dFNWA",target:"_blank",rel:"noopener noreferrer"}},[a._v("讲讲 js 的内存泄漏、如何监控和分析"),r("OutboundLink")],1)]),a._v(" "),r("h4",{attrs:{id:"_3-1-使用-chrome-任务管理器实时监视内存使用打开-chrome-浏览器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-使用-chrome-任务管理器实时监视内存使用打开-chrome-浏览器","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.1 使用 Chrome 任务管理器实时监视内存使用打开 chrome 浏览器")]),a._v(" "),r("p",[a._v("点击右上角主菜单，选择"),r("code",[a._v("更多工具->任务管理器")]),a._v("，这样就开启了任务管理器面板，然后再右键点击任务管理器的不及格标题并启用 JavaScript 使用的内存，能看到这样的面板：")]),a._v(" "),r("p",[a._v("下面两列可以告诉您与页面的内存使用有关的不同信息：")]),a._v(" "),r("p",[r("img",{attrs:{src:"performance48.png",alt:"images"}})]),a._v(" "),r("ol",[r("li",[r("code",[a._v("内存占用空间(Memory)")]),a._v("列表示原生内存。DOM 节点存储在原生内存中。如果此值正在增大，则说明正在创建 DOM 节点。")]),a._v(" "),r("li",[r("code",[a._v("JavaScript使用的内存(JavaScript Memory)")]),a._v("列表表示 JS 堆。此列包含两个值。您感兴趣的值是实时数字（括号中的数字）。实时数字表示您的页面上的可到达对象正在使用的内存量。如果此数字在增大，要么是正在创建新对象，要么是现有对象正在增长。")])]),a._v(" "),r("p",[a._v("当你页面稳定下来之后，这两个的值还在上涨，你就可以查一查是否内存泄漏了。")]),a._v(" "),r("h4",{attrs:{id:"_3-2-利用-chrome-时间轴记录可视化内存泄漏"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-利用-chrome-时间轴记录可视化内存泄漏","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.2 利用 Chrome 时间轴记录可视化内存泄漏")]),a._v(" "),r("p",[a._v("Performance(时间轴)面板能够直观实时显示 JS 内存使用情况、节点数量、监听器数量等。")]),a._v(" "),r("p",[a._v("打开 Chrome 浏览器，调出调试面板(DevTools)，点击"),r("code",[a._v("Performance")]),a._v("选项(低版本是 Timeline)，勾选 Memory 复选框。一种比较好的做法是使用强制垃圾回收开始和结束记录。在记录时点击 Collect garbage 按钮 (强制垃圾回收按钮) 可以强制进行垃圾回收。 所以录制顺序可以这样：开始录制前先点击垃圾回收--\x3e点击开始录制--\x3e点击垃圾回收--\x3e点击结束录制。 面板介绍如图：")]),a._v(" "),r("p",[r("img",{attrs:{src:"performance49.png",alt:"images"}})]),a._v(" "),r("p",[a._v("录制结果如图：")]),a._v(" "),r("p",[r("img",{attrs:{src:"performance50.png",alt:"images"}})]),a._v(" "),r("p",[a._v("首先，从图中我们可以看出不同颜色的曲线代表的含义，这里主要关注 JS 堆内存、节点数量、监听器数量。鼠标移到曲线上，可以在左下角显示具体数据。在实际使用过程中，如果您看到这种 JS 堆大小或节点大小不断增大的模式，则可能存在内存泄漏。")]),a._v(" "),r("h4",{attrs:{id:"_3-3-使用堆快照发现已经分离-dom-树的内存泄漏"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-使用堆快照发现已经分离-dom-树的内存泄漏","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.3 使用堆快照发现已经分离 DOM 树的内存泄漏")]),a._v(" "),r("p",[a._v("只有页面的 DOM 树或 JavaScript 代码不再引用 DOM 节点时，DOM 节点才会被作为垃圾进行回收。如果某个节点已从 DOM 树移除，但某些 JavaScript 仍然引用它，我们称此节点为“已分离”，已分离的 DOM 节点是内存泄漏的常见原因。")]),a._v(" "),r("p",[a._v("同理，调出调试面板，点击 "),r("code",[a._v("Memory")]),a._v("，然后选择 "),r("code",[a._v("Heap Snapshot")]),a._v("，然后点击进行录制。录制完成后，选中录制结果，在 "),r("code",[a._v("Class filter")]),a._v(" 文本框中键入 "),r("code",[a._v("Detached")]),a._v("，搜索已分离的 DOM 树。 以这段代码为例：")]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("<html>\n<head>\n</head>\n<body>\n<button id=\"createBtn\">增加节点</button>\n<script>\nvar detachedNodes;\n\nfunction create() {\n  var ul = document.createElement('ul');\n  for (var i = 0; i < 10; i++) {\n    var li = document.createElement('li');\n    ul.appendChild(li);\n  }\n  detachedTree = ul;\n}\n\ndocument.getElementById('createBtn').addEventListener('click', create);\n<\/script>\n</body>\n</html>\n\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br"),r("span",{staticClass:"line-number"},[a._v("6")]),r("br"),r("span",{staticClass:"line-number"},[a._v("7")]),r("br"),r("span",{staticClass:"line-number"},[a._v("8")]),r("br"),r("span",{staticClass:"line-number"},[a._v("9")]),r("br"),r("span",{staticClass:"line-number"},[a._v("10")]),r("br"),r("span",{staticClass:"line-number"},[a._v("11")]),r("br"),r("span",{staticClass:"line-number"},[a._v("12")]),r("br"),r("span",{staticClass:"line-number"},[a._v("13")]),r("br"),r("span",{staticClass:"line-number"},[a._v("14")]),r("br"),r("span",{staticClass:"line-number"},[a._v("15")]),r("br"),r("span",{staticClass:"line-number"},[a._v("16")]),r("br"),r("span",{staticClass:"line-number"},[a._v("17")]),r("br"),r("span",{staticClass:"line-number"},[a._v("18")]),r("br"),r("span",{staticClass:"line-number"},[a._v("19")]),r("br"),r("span",{staticClass:"line-number"},[a._v("20")]),r("br"),r("span",{staticClass:"line-number"},[a._v("21")]),r("br"),r("span",{staticClass:"line-number"},[a._v("22")]),r("br")])]),r("p",[a._v("点击几下，然后记录。可以得到以下信息：")]),a._v(" "),r("p",[r("img",{attrs:{src:"performance51.png",alt:"images"}})]),a._v(" "),r("p",[a._v("旧版的面板，还会有颜色标注，黄色的对象实例表示它被 JS 代码引用，红色的对象实例表示被黄色节点引用的游离节点。上图是新版本的，不会有颜色标识。但是还是可以一个个来看，如上图，点开节点，可以看到下面的引用信息，上面可以看出，有个 HTMLUListElement(ul 节点)被 window.detachedNodes 引用。再结合代码，原来是没有加 var/let/const 声明，导致其成了全局变量,所以 DOM 无法释放。")]),a._v(" "),r("h4",{attrs:{id:"_3-4-按函数调查内存分配打开面板"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-按函数调查内存分配打开面板","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.4 按函数调查内存分配打开面板")]),a._v(" "),r("p",[a._v("点击 JavaScript Profiler,如果没看到这个选项，你可以点调试面板右上角的三个点，选择 more tools，然后选择。")]),a._v(" "),r("p",[a._v("操作步骤：点 start->在页面进行你要检测的操作->点 stop。")]),a._v(" "),r("p",[r("img",{attrs:{src:"performance52.png",alt:"images"}})]),a._v(" "),r("p",[a._v("DevTools 按函数显示内存分配明细。默认视图为 Heavy (Bottom Up)，将分配了最多内存的函数显示在最上方，还有函数的位置，你可以看看是哪些函数占用内存较多。")]),a._v(" "),r("h3",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料","aria-hidden":"true"}},[a._v("#")]),a._v(" 参考资料")]),a._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/qq449245884/xiaozhi/issues/36",target:"_blank",rel:"noopener noreferrer"}},[a._v("前端面试：谈谈 JS 垃圾回收机制"),r("OutboundLink")],1)]),a._v(" "),r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzIyNDU2NTc5Mw==&mid=2247483715&idx=1&sn=00600d07ce4fd2b465d6cc7692d050f0&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[a._v("Node.js 内存管理和 V8 垃圾回收机制"),r("OutboundLink")],1)]),a._v(" "),r("li",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/25736931",target:"_blank",rel:"noopener noreferrer"}},[a._v("如何分析 Node.js 中的内存泄漏？"),r("OutboundLink")],1)]),a._v(" "),r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/sMV4KyUb6RORJ4la7MfC4Q",target:"_blank",rel:"noopener noreferrer"}},[a._v("浏览器垃圾回收机制与 Vue 项目内存泄漏场景分析"),r("OutboundLink")],1)]),a._v(" "),r("li",[r("a",{attrs:{href:"https://sanyuan0704.github.io/frontend_daily_question/week07/038.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("V8 引擎如何进行垃圾内存的回收？"),r("OutboundLink")],1)]),a._v(" "),r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/1SGodqhTRM9mBy0Q9J0qow",target:"_blank",rel:"noopener noreferrer"}},[a._v("一文搞懂 V8 引擎的垃圾回收"),r("OutboundLink")],1)]),a._v(" "),r("li",[r("a",{attrs:{href:"https://juejin.im/post/5dcb7f706fb9a04aad01615a",target:"_blank",rel:"noopener noreferrer"}},[a._v("V8 引擎垃圾内存回收原理解析"),r("OutboundLink")],1)]),a._v(" "),r("li",[r("a",{attrs:{href:"https://time.geekbang.org/column/article/131233",target:"_blank",rel:"noopener noreferrer"}},[a._v("13 | 垃圾回收：垃圾数据是如何自动回收的？"),r("OutboundLink")],1)]),a._v(" "),r("li",[r("a",{attrs:{href:"https://juejin.im/post/5db2beb8e51d455b450a64b4",target:"_blank",rel:"noopener noreferrer"}},[a._v("Chrome 浏览器垃圾回收机制与内存泄漏分析"),r("OutboundLink")],1)]),a._v(" "),r("li",[r("a",{attrs:{href:"yq.aliyun.com/articles/592878"}},[a._v("解读 V8 GC Log（一）: Node.js 应用背景与 GC 基础知识")])]),a._v(" "),r("li",[r("a",{attrs:{href:"yq.aliyun.com/articles/592880"}},[a._v("解读 V8 GC Log（二）: 堆内外内存的划分与 GC 算法")])])]),a._v(" "),r("h2",{attrs:{id:"联系作者"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#联系作者","aria-hidden":"true"}},[a._v("#")]),a._v(" 联系作者")]),a._v(" "),r("div",{attrs:{align:"center"}},[r("p",[a._v("\n        平凡世界，贵在坚持。\n    ")]),a._v(" "),r("img",{attrs:{src:a.$withBase("/about/contact.png")}})])])}),[],!1,null,null,null);e.default=s.exports}}]);