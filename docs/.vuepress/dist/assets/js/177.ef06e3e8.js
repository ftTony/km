(window.webpackJsonp=window.webpackJsonp||[]).push([[177],{398:function(a,_,v){"use strict";v.r(_);var t=v(13),s=Object(t.a)({},(function(){var a=this,_=a.$createElement,v=a._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"js-编译器，解释引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js-编译器，解释引擎"}},[a._v("#")]),a._v(" JS 编译器，解释引擎")]),a._v(" "),v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),v("p",[a._v("本人平时学习及收集内容，欢迎参入一起讨论。")]),a._v(" "),v("h2",{attrs:{id:"内容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内容"}},[a._v("#")]),a._v(" 内容")]),a._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"}},[a._v("编译过程")])]),a._v(" "),v("li",[v("a",{attrs:{href:"#%E4%BA%8C%E3%80%81%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90"}},[a._v("实战分析")])]),a._v(" "),v("li",[v("a",{attrs:{href:"#%E4%B8%89%E3%80%81jit-%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96"}},[a._v("JIT 引擎优化")])])]),a._v(" "),v("h3",{attrs:{id:"一、编译过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、编译过程"}},[a._v("#")]),a._v(" 一、编译过程")]),a._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#_1-1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"}},[a._v("词法分析")])]),a._v(" "),v("li",[v("a",{attrs:{href:"#_1-2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"}},[a._v("语法分析")])]),a._v(" "),v("li",[v("a",{attrs:{href:"#_1-3-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"}},[a._v("代码生成")])]),a._v(" "),v("li",[v("a",{attrs:{href:"#_1-4-%E9%A2%84%E7%BC%96%E8%AF%91"}},[a._v("预编译")])]),a._v(" "),v("li",[v("a",{attrs:{href:"#_1-5-%E8%A7%A3%E9%87%8A%E5%99%A8%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C"}},[a._v("解释器引擎执行")])]),a._v(" "),v("li",[v("a",{attrs:{href:"#_1-6-%E4%BD%9C%E7%94%A8%E5%9F%9F"}},[a._v("作用域")])])]),a._v(" "),v("p",[a._v("接下来的案例均根据以下代码进行。")]),a._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = 10;\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br")])]),v("h4",{attrs:{id:"_1-1-词法分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-词法分析"}},[a._v("#")]),a._v(" 1.1 词法分析")]),a._v(" "),v("p",[a._v("把输入的字符串分解为一些对编程语言有意义的代码块（词法单元）。例如上文案例会被解析成"),v("code",[a._v("var")]),a._v("，"),v("code",[a._v("a")]),a._v("，"),v("code",[a._v("=")]),a._v("，"),v("code",[a._v("10")]),a._v("。")]),a._v(" "),v("h4",{attrs:{id:"_1-2-语法分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-语法分析"}},[a._v("#")]),a._v(" 1.2 语法分析")]),a._v(" "),v("p",[a._v("这个过程会将词法单元转换成一棵抽象语法树(Abstract Syntax Tree，AST)。")]),a._v(" "),v("h4",{attrs:{id:"_1-3-代码生成"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-代码生成"}},[a._v("#")]),a._v(" 1.3 代码生成")]),a._v(" "),v("p",[a._v("将 AST 代码转换为可执行代码。简单来说，就是将 AST 转为一组"),v("code",[a._v("机器指令")]),a._v("，用来创建一个叫做 a 的变量（包括分配内存等），并将一个值 10 存储在 a 中。")]),a._v(" "),v("h4",{attrs:{id:"_1-4-预编译"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-预编译"}},[a._v("#")]),a._v(" 1.4 预编译")]),a._v(" "),v("ul",[v("li",[a._v("在引擎执行代码之前，在当前作用域下，会把带有 var 和 function 关键字的事先声明，并保存在当前作用域内中（这也就是亦是声明提升和函数声明提升的原因）。")]),a._v(" "),v("li",[a._v("变量和函数在内的声明都在任何代码执行前被处理。")]),a._v(" "),v("li",[a._v("函数声明优先于变量声明提升，出现在后面的函数声明可以覆盖之前的声明。")])]),a._v(" "),v("p",[a._v("在预编译阶段会执行以下操作：")]),a._v(" "),v("ul",[v("li",[a._v("在编译器，遇到 var a 时，会查找同一作用域是否存在同名变量。\n"),v("ul",[v("li",[a._v("如果存在，则忽略该变量声明。")]),a._v(" "),v("li",[a._v("如果不存在，则会在"),v("code",[a._v("当前作用域中")]),a._v("创建一个 a 变量。")])])])]),a._v(" "),v("h4",{attrs:{id:"_1-5-解释器引擎执行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-解释器引擎执行"}},[a._v("#")]),a._v(" 1.5 解释器引擎执行")]),a._v(" "),v("p",[a._v("解释器引擎，常用的就是 Chrome V8，和 Firefox SpiderMonkey 引擎。")]),a._v(" "),v("ul",[v("li",[a._v("在引擎执行 a=10 代码时，会查找同一作用域是否存在 a 变量。\n"),v("ul",[v("li",[a._v("如果存在，则进行赋值操作。")]),a._v(" "),v("li",[a._v("如果不存在，则会在上层作用域中寻找 a。")]),a._v(" "),v("li",[a._v("如果都找不到 a，那就在全局作用域去创建 a，并赋值（严格模式会报错）。")])])])]),a._v(" "),v("h4",{attrs:{id:"_1-6-作用域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-作用域"}},[a._v("#")]),a._v(" 1.6 作用域")]),a._v(" "),v("p",[a._v("负责收集并维护所有的标识符（变量）。在 ES6 以前没有块级作用域，只有函数级作用域，但 catch 跟 with 模块除外。")]),a._v(" "),v("p",[a._v("在编译器编译变量声明时，或者解释器引擎使用变量时，有一个 LHS 和 RHS 概念。")]),a._v(" "),v("ul",[v("li",[a._v("LHS 可以理解为变量赋值等号左边的部分，用于"),v("strong",[a._v("查询变量是否声明")]),a._v("。")]),a._v(" "),v("li",[a._v("RHS 可以理解为变量赋值等号右边的部分，用于"),v("strong",[a._v("查询变量的值")]),a._v("。")])]),a._v(" "),v("h3",{attrs:{id:"二、实战分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、实战分析"}},[a._v("#")]),a._v(" 二、实战分析")]),a._v(" "),v("p",[a._v("接下来，我们根据以下代码进行 js 编译流程分析。")]),a._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a;\na = 2;\nconsole.log(a);\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br"),v("span",{staticClass:"line-number"},[a._v("2")]),v("br"),v("span",{staticClass:"line-number"},[a._v("3")]),v("br")])]),v("ol",[v("li",[a._v("编译器解析 var a，执行 LHS 查询，询问作用域，当前作用域有 a 吗？")]),a._v(" "),v("li",[a._v("作用域回复，没有。")]),a._v(" "),v("li",[a._v("于是编译器就在当前作用域上，创建了一个 a。")]),a._v(" "),v("li",[a._v("编译器执行到 a=2，生成机器代码，交给引擎执行。")]),a._v(" "),v("li",[a._v("解释引擎开始执行 a=2，首先进行 LHS 查询，询问作用域，当前作用域有 a 吗？")]),a._v(" "),v("li",[a._v("作用域回复，有，因为已经被编译器创建了。")]),a._v(" "),v("li",[a._v("执行赋值操作（如果没有，则会继续询问上层作用域）。")])]),a._v(" "),v("p",[a._v("至此 var a;a=2;执行完毕。")]),a._v(" "),v("ol",{attrs:{start:"8"}},[v("li",[a._v("引擎执行 console.log(a);执行 RHS 查询，询问作用域，当前作用域有 console 吗？")]),a._v(" "),v("li",[a._v("作用域回复，没有，但在全局作用域找到了。")]),a._v(" "),v("li",[a._v("解释引擎继续执行 console.log(a)，首先执行 RHS 查询，询问作用域，当前作用域有 a 吗？")]),a._v(" "),v("li",[a._v("作用域回复，有，并返回 a。")]),a._v(" "),v("li",[a._v("引擎执行 console.log(a)打印操作。")])]),a._v(" "),v("h3",{attrs:{id:"三、jit-引擎优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、jit-引擎优化"}},[a._v("#")]),a._v(" 三、JIT 引擎优化")]),a._v(" "),v("p",[a._v("JS 是解释型语言且弱类型，在生成 AST 之后，就开始一边编译，一边解释，但是有个弊端，当某段代码被多次执行时，就会进行多次编译解析操作，特别是在一个循环内，将消耗大量的性能。")]),a._v(" "),v("p",[a._v("JIT 是编译型语言和解释性语言的混合，在一边编译，一边解释时做了一些优化，常用的优化有以下几点。")]),a._v(" "),v("ol",[v("li",[v("strong",[a._v("监视器")]),a._v(" 在 js 引擎中增加一个监视器，监视器监控着代码的运行情况，记录代码一共运行了多少次，如何运行的等信息，如果同一行代码运行了几次，这个代码就被标记成了"),v("code",[a._v("warm")]),a._v("，如果运行了很多次，则被标记成"),v("code",[a._v("hot")]),a._v("。")]),a._v(" "),v("li",[v("strong",[a._v("基线编译器")]),a._v(" 如果一段代码变成了"),v("code",[a._v("warm")]),a._v("，那么 JIT 就把它送到基线编译器去编译，并且把编译结果存储起来。比如：监视器监视到了某行、某个变量执行同样的代码、使用了同样的变量类型，就会把编译后的版本，替换这一行代码的执行，并且存储。")]),a._v(" "),v("li",[v("strong",[a._v("优化编译器")]),a._v(" 如果一个代码段变得"),v("code",[a._v("hot")]),a._v("，监视器会把它发送到优化编译器。生成一个更快速和高效的代码版本出来，并且存储。例如：循环加一个对象属性时，假设它是 INT 类型，优先做 INT 类型的判断。")]),a._v(" "),v("li",[v("strong",[a._v("去优化")]),a._v(" 可是对 JS 从来就没有确定这么一说，前 99 个对象属性保持着 INT 类型，可能第 100 个就没有这个属性了，那么这时候 JIT 会认为做了一个错误的假设，并且把优化代码丢掉，执行过程将会回到解释器或者基线编译器，这一过程叫做优化。")])]),a._v(" "),v("p",[v("strong",[a._v("JIT 案例")])]),a._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a;\nfor(var i=0;i<10;i++){\n    if(i>5){\n        a='a';\n    }else{\n        a+=i;\n    }\n}\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br"),v("span",{staticClass:"line-number"},[a._v("2")]),v("br"),v("span",{staticClass:"line-number"},[a._v("3")]),v("br"),v("span",{staticClass:"line-number"},[a._v("4")]),v("br"),v("span",{staticClass:"line-number"},[a._v("5")]),v("br"),v("span",{staticClass:"line-number"},[a._v("6")]),v("br"),v("span",{staticClass:"line-number"},[a._v("7")]),v("br"),v("span",{staticClass:"line-number"},[a._v("8")]),v("br")])]),v("p",[a._v("如果 a 和 i 一直都 number 类型，但 js 是弱类型，在执行时，还是会先判断左右两边的类型，这样判断下去很费时，于是 JIT 做了以下两点优化：")]),a._v(" "),v("p",[a._v("增加一个监视器，每一步代码的执行情况。")]),a._v(" "),v("ol",[v("li",[a._v("将 warm 代码加入基线编译器，如果监视器监视到执行同样的代码和同样的类型，就会直接复用已编译的版本。")]),a._v(" "),v("li",[a._v("将 hot 代码加入优化编译器，为了更快的执行，编译器要会做假设，即将 a 和 i 类型假设为 number，并缓存起来，下一次直接执行 number 类型相加。")]),a._v(" "),v("li",[a._v("如果 hot 代码中的假设不成立了，如 i>5 之后，i 就变成一个 string 类型了，这时候就执行（去优化）操作，重置到基线编译结果。")])]),a._v(" "),v("blockquote",[v("p",[v("strong",[a._v("什么时候会进行编译优化呢？")])]),a._v(" "),v("p",[a._v("在一行代码多次执行时，会被标记 warm，被更多次执行时，会被标记 hot。warm 会被加入到基线编译器，hot 会被加入到优化编译器。")])]),a._v(" "),v("h3",{attrs:{id:"参考资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[a._v("#")]),a._v(" 参考资料")]),a._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://lmjben.github.io/blog/js-principle.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("JS 编译器，解释引擎"),v("OutboundLink")],1)])]),a._v(" "),v("h2",{attrs:{id:"联系作者"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#联系作者"}},[a._v("#")]),a._v(" 联系作者")]),a._v(" "),v("div",{attrs:{align:"center"}},[v("p",[a._v("\n        平凡世界，贵在坚持。\n    ")]),a._v(" "),v("img",{attrs:{src:a.$withBase("/about/contact.png")}})])])}),[],!1,null,null,null);_.default=s.exports}}]);