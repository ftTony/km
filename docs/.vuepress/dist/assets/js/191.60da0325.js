(window.webpackJsonp=window.webpackJsonp||[]).push([[191],{259:function(e,t,r){"use strict";r.r(t);var a=r(4),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"csrf-攻击"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#csrf-攻击","aria-hidden":"true"}},[e._v("#")]),e._v(" CSRF 攻击")]),e._v(" "),r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),r("p",[e._v("本人平时学习及收集内容，欢迎参入一起讨论。")]),e._v(" "),r("h2",{attrs:{id:"内容"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内容","aria-hidden":"true"}},[e._v("#")]),e._v(" 内容")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-crsf"}},[e._v("什么是 CRSF")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#%E4%BA%8C%E3%80%81crsf-%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"}},[e._v("CRSF 原理是什么")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#%E4%B8%89%E3%80%81crsf-%E9%98%B2%E5%BE%A1%E6%89%8B%E6%AE%B5"}},[e._v("CRSF 防御手段")])])]),e._v(" "),r("h3",{attrs:{id:"一、什么是-crsf"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是-crsf","aria-hidden":"true"}},[e._v("#")]),e._v(" 一、什么是 CRSF")]),e._v(" "),r("p",[e._v("CSRF（Cross Site Request Forgery），中文是跨站点请求伪造。CSRF 攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。")]),e._v(" "),r("h3",{attrs:{id:"二、crsf-原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、crsf-原理是什么","aria-hidden":"true"}},[e._v("#")]),e._v(" 二、CRSF 原理是什么")]),e._v(" "),r("p",[r("img",{attrs:{src:"csrf.jpg",alt:""}})]),e._v(" "),r("p",[e._v("从上图可以看出，要完成一次 CSRF 攻击，受害者必须依次完成两个步骤：")]),e._v(" "),r("ol",[r("li",[e._v("登录受信任网站 A，并在本地生成 Cookie。")]),e._v(" "),r("li",[e._v("在不登出 A 的情况下，访问危险网站 B。")])]),e._v(" "),r("p",[e._v("示例一、使用 get 请求")]),e._v(" "),r("p",[e._v("银行网站 A，它以 GET 请求来完成银行转账的操作，如："),r("code",[e._v("http://www.mybank.com/Transfer.php?toBankId=11&money=1000")])]),e._v(" "),r("p",[e._v("危险网站 B，它里面有一段 HTML 的代码如下：")]),e._v(" "),r("p",[r("code",[e._v("<img src=http://www.mybank.com/Transfer.php?toBankId=11&money=1000>")])]),e._v(" "),r("p",[e._v("银行网站 A 违反了 HTTP 规范，使用 GET 请求更新资源。在访问危险网站 B 的之前，你已经登录了银行网站 A，而 B 中的"),r("img"),e._v("以 GET 的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站 A 的 Cookie 发出 Get 请求，去获取资源"),r("code",[e._v("http://www.mybank.com/Transfer.php?toBankId=11&money=1000")]),e._v("，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作......")]),e._v(" "),r("p",[e._v("示例二、使用 POST 请求完成转账操作")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('<html>\n　　<head>\n　　　　<script type="text/javascript">\n　　　　　　function steal()\n　　　　　　{\n          　　　　 iframe = document.frames["steal"];\n　　     　　      iframe.document.Submit("transfer");\n　　　　　　}\n　　　　<\/script>\n　　</head>\n\n　　<body onload="steal()">\n　　　　<iframe name="steal" display="none">\n　　　　　　<form method="POST" name="transfer"　action="http://www.myBank.com/Transfer.php">\n　　　　　　　　<input type="hidden" name="toBankId" value="11">\n　　　　　　　　<input type="hidden" name="money" value="1000">\n　　　　　　</form>\n　　　　</iframe>\n　　</body>\n</html>\n')])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br"),r("span",{staticClass:"line-number"},[e._v("12")]),r("br"),r("span",{staticClass:"line-number"},[e._v("13")]),r("br"),r("span",{staticClass:"line-number"},[e._v("14")]),r("br"),r("span",{staticClass:"line-number"},[e._v("15")]),r("br"),r("span",{staticClass:"line-number"},[e._v("16")]),r("br"),r("span",{staticClass:"line-number"},[e._v("17")]),r("br"),r("span",{staticClass:"line-number"},[e._v("18")]),r("br"),r("span",{staticClass:"line-number"},[e._v("19")]),r("br"),r("span",{staticClass:"line-number"},[e._v("20")]),r("br")])]),r("p",[e._v("总结：CSRF 攻击是源于 WEB 的隐式身份验证机制！WEB 的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！")]),e._v(" "),r("h3",{attrs:{id:"三、crsf-防御手段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、crsf-防御手段","aria-hidden":"true"}},[e._v("#")]),e._v(" 三、CRSF 防御手段")]),e._v(" "),r("p",[e._v("目前防御 CSRF 攻击主要有三种策略")]),e._v(" "),r("ul",[r("li",[e._v("验证 HTTP Referer 字段；")]),e._v(" "),r("li",[e._v("在请求地址中添加 token 并验证；")]),e._v(" "),r("li",[e._v("在 HTTP 头中自定义属性并验证;")])]),e._v(" "),r("h4",{attrs:{id:"_3-1-验证-http-referer-字段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-验证-http-referer-字段","aria-hidden":"true"}},[e._v("#")]),e._v(" 3.1 验证 http referer 字段")]),e._v(" "),r("p",[e._v("根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问"),r("code",[e._v("http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory")]),e._v("，用户必须先登陆 bank.example，然后通过点页面上的按钮来触发转帐事件。这时，该转帐请求的 Referer 值就是转账按钮所在页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实话 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证期 Referer 值，如果是以 bank.example 域名开头，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。")]),e._v(" "),r("p",[e._v("这种方法的显而见的好处就是简单易行，网站的普通人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统任何已有代码和逻辑，没有风险，非常便捷。")]),e._v(" "),r("p",[e._v("然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。")]),e._v(" "),r("p",[e._v("即使是使用最新浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中某信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。")]),e._v(" "),r("h4",{attrs:{id:"_3-2-在请求地址中添加-token-并验证"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-在请求地址中添加-token-并验证","aria-hidden":"true"}},[e._v("#")]),e._v(" 3.2 在请求地址中添加 token 并验证")]),e._v(" "),r("p",[e._v("CSRF 攻击之所能够成功，是为黑客可以完全伪造用户的请求，该请求中用户验证信息都是存在于 cookie 中，因此黑客可以不知道这此验证的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者内容不正确，则认为可能是 csrf 攻击而拒绝该请求。")]),e._v(" "),r("p",[e._v("这种方法要比检查 referer 要安全一些，token 可以在用户登陆报到产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 "),r("code",[e._v("http://url?csrftoken=tokenvalue")]),e._v("。而对于 POST 请求来说，要在 form 的最后加上"),r("code",[e._v("<input type=”hidden” name=”csrftoken” value=”tokenvalue”/>")]),e._v("，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javasript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态的 htmtl 代码，这种方法就没有作用，还需要程序员手动添加 token。")]),e._v(" "),r("p",[e._v("该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。")]),e._v(" "),r("h4",{attrs:{id:"_3-3-在-http-头中自定义属性并验证"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-在-http-头中自定义属性并验证","aria-hidden":"true"}},[e._v("#")]),e._v(" 3.3 在 HTTP 头中自定义属性并验证")]),e._v(" "),r("p",[e._v("这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。")]),e._v(" "),r("h3",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料","aria-hidden":"true"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CSRF 攻击的应对之道"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("浅谈 CSRF 攻击方式"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"联系作者"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#联系作者","aria-hidden":"true"}},[e._v("#")]),e._v(" 联系作者")]),e._v(" "),r("div",{attrs:{align:"center"}},[r("p",[e._v("\n        平凡世界，贵在坚持。\n    ")]),e._v(" "),r("img",{attrs:{src:e.$withBase("/about/contact.png")}})])])}),[],!1,null,null,null);t.default=n.exports}}]);