(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{315:function(a,t,r){"use strict";r.r(t);var s=r(4),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"高级排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#高级排序","aria-hidden":"true"}},[a._v("#")]),a._v(" 高级排序")]),a._v(" "),r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),r("p",[a._v("本人平时学习及收集内容，欢迎参入一起讨论。")]),a._v(" "),r("h2",{attrs:{id:"内容"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内容","aria-hidden":"true"}},[a._v("#")]),a._v(" 内容")]),a._v(" "),r("ul",[r("li",[a._v("希尔排序")]),a._v(" "),r("li",[a._v("归并排序")]),a._v(" "),r("li",[a._v("快速排序")]),a._v(" "),r("li",[a._v("堆排序")]),a._v(" "),r("li",[a._v("计数排序")]),a._v(" "),r("li",[a._v("桶排序")]),a._v(" "),r("li",[a._v("基数排序")])]),a._v(" "),r("h3",{attrs:{id:"一、希尔排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、希尔排序","aria-hidden":"true"}},[a._v("#")]),a._v(" 一、希尔排序")]),a._v(" "),r("h4",{attrs:{id:"_1-1-算法简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-算法简介","aria-hidden":"true"}},[a._v("#")]),a._v(" 1.1 算法简介")]),a._v(" "),r("blockquote",[r("p",[a._v("希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第 4 版》的合著者 Robert Sedgewick 提出的。")])]),a._v(" "),r("h4",{attrs:{id:"_1-2-算法描述和实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-算法描述和实现","aria-hidden":"true"}},[a._v("#")]),a._v(" 1.2 算法描述和实现")]),a._v(" "),r("p",[a._v("先将整个待排序的记录序列分割成为苦干子序列分别进行直接插入排序，具体算法描述：")]),a._v(" "),r("ul",[r("li",[a._v("选择一个增量序列 t1，t2，...，tk，其中 ti>tj,tk=1;")]),a._v(" "),r("li",[a._v("按增量序列个数 k，对序列进行 k 趟排序")]),a._v(" "),r("li",[a._v("每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。")])]),a._v(" "),r("p",[r("strong",[a._v("JavaScript 代码实现")])]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("function shellSort(arr){\n    var len = arr.length,\n        temp,\n        gap = 1;\n   console.time('希尔排序耗时：');\n   while(gap<len/5){\n       gap = gap*5+1;\n   }\n   for(gap;gap>0;gap=Math.floor(gap/5)){\n       for(var i = gap;i<len;i++){\n           temp=arr[i];\n           for(var j=i-gap;i>=0 && arr[j]>temp;j-=gap){\n               arr[j+gap]=arr[j];\n           }\n           arr[j+gap]=temp;\n       }\n   }\n   console.timeEnd('希尔排序耗时：')\n   return arr;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br"),r("span",{staticClass:"line-number"},[a._v("6")]),r("br"),r("span",{staticClass:"line-number"},[a._v("7")]),r("br"),r("span",{staticClass:"line-number"},[a._v("8")]),r("br"),r("span",{staticClass:"line-number"},[a._v("9")]),r("br"),r("span",{staticClass:"line-number"},[a._v("10")]),r("br"),r("span",{staticClass:"line-number"},[a._v("11")]),r("br"),r("span",{staticClass:"line-number"},[a._v("12")]),r("br"),r("span",{staticClass:"line-number"},[a._v("13")]),r("br"),r("span",{staticClass:"line-number"},[a._v("14")]),r("br"),r("span",{staticClass:"line-number"},[a._v("15")]),r("br"),r("span",{staticClass:"line-number"},[a._v("16")]),r("br"),r("span",{staticClass:"line-number"},[a._v("17")]),r("br"),r("span",{staticClass:"line-number"},[a._v("18")]),r("br"),r("span",{staticClass:"line-number"},[a._v("19")]),r("br"),r("span",{staticClass:"line-number"},[a._v("20")]),r("br"),r("span",{staticClass:"line-number"},[a._v("21")]),r("br"),r("span",{staticClass:"line-number"},[a._v("22")]),r("br")])]),r("h4",{attrs:{id:"_1-3-希尔排序图示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-希尔排序图示","aria-hidden":"true"}},[a._v("#")]),a._v(" 1.3 希尔排序图示")]),a._v(" "),r("p",[r("img",{attrs:{src:"sort08.gif",alt:"images"}})]),a._v(" "),r("h4",{attrs:{id:"_1-4-算法分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-算法分析","aria-hidden":"true"}},[a._v("#")]),a._v(" 1.4 算法分析")]),a._v(" "),r("ul",[r("li",[a._v("最佳情况：T(n) = O(nlog2 n)")]),a._v(" "),r("li",[a._v("最坏情况：T(n) = O(nlog2 n)")]),a._v(" "),r("li",[a._v("平均情况：T(n) =O(nlog n)")])]),a._v(" "),r("h3",{attrs:{id:"二、归并排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、归并排序","aria-hidden":"true"}},[a._v("#")]),a._v(" 二、归并排序")]),a._v(" "),r("h4",{attrs:{id:"_2-1-算法简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-算法简介","aria-hidden":"true"}},[a._v("#")]),a._v(" 2.1 算法简介")]),a._v(" "),r("blockquote",[r("p",[a._v("和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择好的多，因为始终都是 O(n log n）的时间复杂度。代价是需要额外的内存空间。")])]),a._v(" "),r("blockquote",[r("p",[a._v("归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个序列有序，再使子序列段间有序。若将两个序表合并合并成一个有序表，称为 2-路归并。")])]),a._v(" "),r("h4",{attrs:{id:"_2-2-算法描述和实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-算法描述和实现","aria-hidden":"true"}},[a._v("#")]),a._v(" 2.2 算法描述和实现")]),a._v(" "),r("p",[r("strong",[a._v("具体算法描述如下：")])]),a._v(" "),r("ul",[r("li",[a._v("把长度为 n 的输入序列分成两个长度为"),r("code",[a._v("n/2")]),a._v("的子序列；")]),a._v(" "),r("li",[a._v("对这两个序列分别采用归并排序；")]),a._v(" "),r("li",[a._v("将两个排序好的子序列合并成一个最终的排序序列")])]),a._v(" "),r("p",[r("strong",[a._v("JavaScript 代码实现：")])]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("function mergeSort(arr){\n    var len = arr.length;\n    if(len<2){\n        return arr;\n    }\n    var mddle = Math.floor(len/2),\n        left = arr.slice(0,middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left),mergeSort(right));\n}\n\nfunction merge(left,right){\n    var result = [];\n    console.time('归并排序耗时');\n    while(left.length && right.length){\n        if(left[0]<=right[0]){\n            result.push(left.shift());\n        }else{\n            result.push(right.shift());\n        }\n    }\n\n    while(left.length) result.push(left.shift())\n\n    while(right.length) result.push(right.shift());\n\n    console.timeEnd('归并排序耗时');\n    return result;\n}\n\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(mergeSort(arr));\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br"),r("span",{staticClass:"line-number"},[a._v("6")]),r("br"),r("span",{staticClass:"line-number"},[a._v("7")]),r("br"),r("span",{staticClass:"line-number"},[a._v("8")]),r("br"),r("span",{staticClass:"line-number"},[a._v("9")]),r("br"),r("span",{staticClass:"line-number"},[a._v("10")]),r("br"),r("span",{staticClass:"line-number"},[a._v("11")]),r("br"),r("span",{staticClass:"line-number"},[a._v("12")]),r("br"),r("span",{staticClass:"line-number"},[a._v("13")]),r("br"),r("span",{staticClass:"line-number"},[a._v("14")]),r("br"),r("span",{staticClass:"line-number"},[a._v("15")]),r("br"),r("span",{staticClass:"line-number"},[a._v("16")]),r("br"),r("span",{staticClass:"line-number"},[a._v("17")]),r("br"),r("span",{staticClass:"line-number"},[a._v("18")]),r("br"),r("span",{staticClass:"line-number"},[a._v("19")]),r("br"),r("span",{staticClass:"line-number"},[a._v("20")]),r("br"),r("span",{staticClass:"line-number"},[a._v("21")]),r("br"),r("span",{staticClass:"line-number"},[a._v("22")]),r("br"),r("span",{staticClass:"line-number"},[a._v("23")]),r("br"),r("span",{staticClass:"line-number"},[a._v("24")]),r("br"),r("span",{staticClass:"line-number"},[a._v("25")]),r("br"),r("span",{staticClass:"line-number"},[a._v("26")]),r("br"),r("span",{staticClass:"line-number"},[a._v("27")]),r("br"),r("span",{staticClass:"line-number"},[a._v("28")]),r("br"),r("span",{staticClass:"line-number"},[a._v("29")]),r("br"),r("span",{staticClass:"line-number"},[a._v("30")]),r("br"),r("span",{staticClass:"line-number"},[a._v("31")]),r("br"),r("span",{staticClass:"line-number"},[a._v("32")]),r("br")])]),r("h4",{attrs:{id:"_2-3-动图演示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-动图演示","aria-hidden":"true"}},[a._v("#")]),a._v(" 2.3 动图演示")]),a._v(" "),r("p",[r("img",{attrs:{src:"sort09.gif",alt:"images"}})]),a._v(" "),r("h4",{attrs:{id:"_2-4-算法分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-算法分析","aria-hidden":"true"}},[a._v("#")]),a._v(" 2.4 算法分析")]),a._v(" "),r("ul",[r("li",[a._v("最佳情况：T(n) = O(n)")]),a._v(" "),r("li",[a._v("最差情况：T(n) = O(nlogn)")]),a._v(" "),r("li",[a._v("平均情况：T(n) = O(nlogn)")])]),a._v(" "),r("h3",{attrs:{id:"三、快速排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、快速排序","aria-hidden":"true"}},[a._v("#")]),a._v(" 三、快速排序")]),a._v(" "),r("h4",{attrs:{id:"_3-1-算法简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-算法简介","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.1 算法简介")]),a._v(" "),r("blockquote",[r("p",[a._v("快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。")])]),a._v(" "),r("h4",{attrs:{id:"_3-2-算法描述和实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-算法描述和实现","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.2 算法描述和实现")]),a._v(" "),r("p",[a._v("快速排序使用分治法来的把一个串分为两个子串。具体算法描述如下：")]),a._v(" "),r("ul",[r("li",[a._v("从数列中挑出一个元素，称为“基准”；")]),a._v(" "),r("li",[a._v("重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就牌数列的中间位置。这个称为分区操作；")]),a._v(" "),r("li",[a._v("递归地把小于基准值元素的子数列和大于基准值元素的子数列和大于苦准值元素的子数列排序。")])]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("function quickSort(array,left,right){\n    console.time('1.快速排序耗时');\n    console.time('1.快速排序耗时');\n}\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br")])]),r("h4",{attrs:{id:"_3-3-动图演示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-动图演示","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.3 动图演示")]),a._v(" "),r("h4",{attrs:{id:"_3-4-算法分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-算法分析","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.4 算法分析")]),a._v(" "),r("ul",[r("li",[a._v("最佳情况：T(n)=O(nlogn)")]),a._v(" "),r("li",[a._v("最差情况：T(n)=O(n2)")]),a._v(" "),r("li",[a._v("平均情况：T(n)=O(nlogn)")])]),a._v(" "),r("h3",{attrs:{id:"四、堆排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四、堆排序","aria-hidden":"true"}},[a._v("#")]),a._v(" 四、堆排序")]),a._v(" "),r("h4",{attrs:{id:"_4-1-算法简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-算法简介","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.1 算法简介")]),a._v(" "),r("blockquote",[r("p",[a._v("堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个挖完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。")])]),a._v(" "),r("h4",{attrs:{id:"_4-2-算法描述和实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-算法描述和实现","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.2 算法描述和实现")]),a._v(" "),r("p",[r("strong",[a._v("具体算法描述如下：")])]),a._v(" "),r("ul",[r("li",[a._v("将初始待排序关键字序列(R1,R2....Rn)构建成大顶堆，此堆为初始的无序区；")])]),a._v(" "),r("p",[r("strong",[a._v("JavaScript 代码实现")])]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br")])]),r("h4",{attrs:{id:"_4-3-动图演示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-动图演示","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.3 动图演示")]),a._v(" "),r("h4",{attrs:{id:"_4-4-算法分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-算法分析","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.4 算法分析")]),a._v(" "),r("h3",{attrs:{id:"五、桶排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#五、桶排序","aria-hidden":"true"}},[a._v("#")]),a._v(" 五、桶排序")]),a._v(" "),r("h4",{attrs:{id:"_5-1-算法简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-算法简介","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.1 算法简介")]),a._v(" "),r("h4",{attrs:{id:"_5-2-算法描述和实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-算法描述和实现","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.2 算法描述和实现")]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br")])]),r("h4",{attrs:{id:"_5-3-动图演示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-动图演示","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.3 动图演示")]),a._v(" "),r("h4",{attrs:{id:"_5-4-算法分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-算法分析","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.4 算法分析")]),a._v(" "),r("h3",{attrs:{id:"六、基数排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#六、基数排序","aria-hidden":"true"}},[a._v("#")]),a._v(" 六、基数排序")]),a._v(" "),r("h4",{attrs:{id:"_6-1-算法简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-算法简介","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.1 算法简介")]),a._v(" "),r("h4",{attrs:{id:"_6-2-算法描述和实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-算法描述和实现","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.2 算法描述和实现")]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br")])]),r("h4",{attrs:{id:"_6-3-动图演示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-动图演示","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.3 动图演示")]),a._v(" "),r("h4",{attrs:{id:"_6-4-算法分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-算法分析","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4 算法分析")]),a._v(" "),r("h3",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料","aria-hidden":"true"}},[a._v("#")]),a._v(" 参考资料")]),a._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://blog.damonare.cn/2016/12/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/",target:"_blank",rel:"noopener noreferrer"}},[a._v("十大经典排序算法总结（javascript 描述）"),r("OutboundLink")],1)]),a._v(" "),r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg",target:"_blank",rel:"noopener noreferrer"}},[a._v("十大经典排序算法动画，看我就够了！"),r("OutboundLink")],1)]),a._v(" "),r("li",[r("a",{attrs:{href:"https://time.geekbang.org/column/article/41913",target:"_blank",rel:"noopener noreferrer"}},[a._v("排序（下）：如何用快排思想在 O(n)内查找第 K 大元素？"),r("OutboundLink")],1)]),a._v(" "),r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/3GOOMguWaNaY1MvRBKYACQ",target:"_blank",rel:"noopener noreferrer"}},[a._v("【图解数据结构】 一组动画彻底理解快速排序"),r("OutboundLink")],1)])]),a._v(" "),r("h2",{attrs:{id:"联系作者"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#联系作者","aria-hidden":"true"}},[a._v("#")]),a._v(" 联系作者")]),a._v(" "),r("div",{attrs:{align:"center"}},[r("p",[a._v("\n        平凡世界，贵在坚持。\n    ")]),a._v(" "),r("img",{attrs:{src:a.$withBase("/about/contact.png")}})])])}),[],!1,null,null,null);t.default=e.exports}}]);