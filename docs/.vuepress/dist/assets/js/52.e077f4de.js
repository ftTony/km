(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{271:function(a,t,n){"use strict";n.r(t);var s=n(13),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"平衡树-avl"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#平衡树-avl"}},[a._v("#")]),a._v(" 平衡树(AVL)")]),a._v(" "),n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),n("p",[a._v("本人平时学习及收集内容，欢迎参入一起讨论。")]),a._v(" "),n("h2",{attrs:{id:"内容"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内容"}},[a._v("#")]),a._v(" 内容")]),a._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"}},[a._v("为什么要有平衡二叉树")])]),a._v(" "),n("li",[n("a",{attrs:{href:"#%E4%BA%8C%E3%80%81%E5%AE%9A%E4%B9%89"}},[a._v("定义")])]),a._v(" "),n("li",[n("a",{attrs:{href:"#%E4%B8%89%E3%80%81%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90"}},[a._v("平衡因子")])])]),a._v(" "),n("h3",{attrs:{id:"一、为什么要有平衡二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、为什么要有平衡二叉树"}},[a._v("#")]),a._v(" 一、为什么要有平衡二叉树")]),a._v(" "),n("p",[a._v("二叉搜索树一定程度上可以提高搜索效率，但是当原序列有序时，例如序列"),n("code",[a._v("A={1,2,3,4,5,6}")]),a._v(",构造二叉搜索树如图。依据此序列构造的二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为 O(n)。")]),a._v(" "),n("p",[n("img",{attrs:{src:"tree12.jpg",alt:"images"}})]),a._v(" "),n("p",[a._v("在此二叉搜索树中查找元素 6 需要查找 6 次。")]),a._v(" "),n("p",[a._v("二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。同样的序列 A，将其改为下图的方式存储，查找元素 6 时只需比较 3 次，查找效率提升一倍。")]),a._v(" "),n("p",[n("img",{attrs:{src:"tree13.jpg",alt:"images"}})]),a._v(" "),n("p",[a._v("可以看出当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。")]),a._v(" "),n("p",[n("strong",[a._v("这种左右子树的高度相差不超过 1 的树为平衡二叉树。")])]),a._v(" "),n("h3",{attrs:{id:"二、定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、定义"}},[a._v("#")]),a._v(" 二、定义")]),a._v(" "),n("p",[n("strong",[a._v("平衡二叉查找树：")]),a._v(" 是基于二分法的策略提高数据的查找速度的二叉树的数据结构。由前苏联的数学家 Adelse-Velskil 和 Landis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。它具有如下几个性质：")]),a._v(" "),n("ul",[n("li",[a._v("可以是空树。")]),a._v(" "),n("li",[a._v("假如不是空树，任何一个节点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。")])]),a._v(" "),n("h3",{attrs:{id:"三、平衡因子"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、平衡因子"}},[a._v("#")]),a._v(" 三、平衡因子")]),a._v(" "),n("p",[a._v("定义：某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子，平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0、1 或者-1，分别对应着左右子树等高，左子树比较高，右子树比较高。")]),a._v(" "),n("h3",{attrs:{id:"四、avl-树插入时的失衡与调整"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四、avl-树插入时的失衡与调整"}},[a._v("#")]),a._v(" 四、AVL 树插入时的失衡与调整")]),a._v(" "),n("p",[a._v("在对 AVL 树添加或移除节点后，我们要计算节点的高度并验证树是否需要进行平衡。向 AVL 树插入节点时，可以执行单旋转或双旋转两种平衡操作，分别对应四种场景。")]),a._v(" "),n("ul",[n("li",[n("strong",[a._v("左-左（LL）：")]),a._v(" 向右的单旋转")]),a._v(" "),n("li",[n("strong",[a._v("右-右（RR）：")]),a._v(" 向左的单旋转")]),a._v(" "),n("li",[n("strong",[a._v("左-右（LR）：")]),a._v(" 向右的双旋转（先 LL 旋转，再 RR 旋转）")]),a._v(" "),n("li",[n("strong",[a._v("右-左（RL）：")]),a._v(" 向左的双旋转（先 RR 旋转，再 LL 旋转）")])]),a._v(" "),n("h4",{attrs:{id:"_4-1-左-左：向右的单旋转"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-左-左：向右的单旋转"}},[a._v("#")]),a._v(" 4.1 左-左：向右的单旋转")]),a._v(" "),n("p",[a._v("这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的。")]),a._v(" "),n("p",[a._v("执行的操作过程：")]),a._v(" "),n("ul",[n("li",[a._v("与平衡操作想着的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为+2）所在的位置")])]),a._v(" "),n("p",[a._v("相关代码：")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("rotationLL(node){\n    const tmp = node.left;\n    node.left = tmp.right\n    tmp.right = node;\n    return tmp;\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br")])]),n("h4",{attrs:{id:"_4-2-右-右（rr）-向左的单旋转"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-右-右（rr）-向左的单旋转"}},[a._v("#")]),a._v(" 4.2 右-右（RR）:向左的单旋转")]),a._v(" "),n("p",[a._v("右-右的情况和左左的情况相反。它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的。")]),a._v(" "),n("p",[a._v("操作步骤：")]),a._v(" "),n("ul",[n("li",[a._v("与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为-2）所在的位置；")]),a._v(" "),n("li",[a._v("节点 X 的右子树操持不变；")]),a._v(" "),n("li",[a._v("将节点 Y 的右子节点置为节点 X 的左节点 Z；")]),a._v(" "),n("li",[a._v("将节点 X 的左子节点置为节点 Y；")])]),a._v(" "),n("p",[a._v("相关代码：")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("rotationRR(node){\n    const tmp = node.right;\n    node.right = tmp.left;\n    tmp.left = node;\n    return tmp;\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br")])]),n("h4",{attrs:{id:"_4-3-左-右（lr）：向右的双旋转"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-左-右（lr）：向右的双旋转"}},[a._v("#")]),a._v(" 4.3 左-右（LR）：向右的双旋转")]),a._v(" "),n("p",[a._v("这种情况出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重。")]),a._v(" "),n("p",[a._v("执行的操作：")]),a._v(" "),n("ul",[n("li",[a._v("将节点 X 置于节点 Y（平衡因子为-2）所在的位置；")]),a._v(" "),n("li",[a._v("将节点 Z 的左子节点置为节点 X 的右子节点；")]),a._v(" "),n("li",[a._v("将节点 Y 的右子节点置为节点 X 的左子节点；")]),a._v(" "),n("li",[a._v("将节点 X 的右子节点置为节点 Y；")]),a._v(" "),n("li",[a._v("将节点 X 的左子节点置为节点 Z；")])]),a._v(" "),n("p",[a._v("相关代码：")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("rotationLR(node){\n    node.left = this.rotationRR(node.left);\n    return this.rotationLL(node);\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br")])]),n("h4",{attrs:{id:"_4-4-右-左（rl）：向左的双旋转"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-右-左（rl）：向左的双旋转"}},[a._v("#")]),a._v(" 4.4 右-左（RL）：向左的双旋转")]),a._v(" "),n("p",[a._v("右-左的情况和左-右的情况相反。这种情况出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重。")]),a._v(" "),n("p",[a._v("执行的操作：")]),a._v(" "),n("ul",[n("li",[a._v("将节点 X 置于节点 Y（平衡因子为+2）所在的位置；")]),a._v(" "),n("li",[a._v("将节点 Y 的左子节点置为节点 X 的右子节点；")]),a._v(" "),n("li",[a._v("将节点 Z 的右子节点置为节点 X 的左子节点；")]),a._v(" "),n("li",[a._v("将节点 X 的左子节点置为节点 Y；")]),a._v(" "),n("li",[a._v("将节点 X 的右子节点置为节点 Z；")])]),a._v(" "),n("p",[a._v("相关代码：")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("rotationRL(node){\n    node.right = this.rotationLL(node.right);\n    return this.rotationRR(node);\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br")])]),n("h3",{attrs:{id:"五、avl-树的四种插入节点方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#五、avl-树的四种插入节点方式"}},[a._v("#")]),a._v(" 五、AVL 树的四种插入节点方式")]),a._v(" "),n("p",[a._v("假设一颗 AVL 树的某个节点为 A，有四种操作会使 A 的左右子树高度差大于 1，从而破坏了原有 AVL 树的平衡性。平衡二叉树插入节点的情况分为以下四种：")]),a._v(" "),n("table",[n("thead",[n("tr",[n("th",[a._v("插入方式")]),a._v(" "),n("th",[a._v("描述")]),a._v(" "),n("th",[a._v("旋转方式")])])]),a._v(" "),n("tbody",[n("tr",[n("td",[a._v("LL")]),a._v(" "),n("td",[a._v("在 A 的"),n("strong",[a._v("左子树")]),a._v("根节点的"),n("strong",[a._v("左子树")]),a._v("上插入节点而破坏平衡")]),a._v(" "),n("td",[a._v("右旋转")])]),a._v(" "),n("tr",[n("td",[a._v("RR")]),a._v(" "),n("td",[a._v("在 A 的"),n("strong",[a._v("右子树")]),a._v("根节点的"),n("strong",[a._v("右子树")]),a._v("上插入节点而破坏平衡")]),a._v(" "),n("td",[a._v("左旋转")])]),a._v(" "),n("tr",[n("td",[a._v("LR")]),a._v(" "),n("td",[a._v("在 A 的"),n("strong",[a._v("左子树")]),a._v("根节点的"),n("strong",[a._v("右子树")]),a._v("上插入节点而破坏平衡")]),a._v(" "),n("td",[a._v("先左旋后右旋转")])]),a._v(" "),n("tr",[n("td",[a._v("RL")]),a._v(" "),n("td",[a._v("在 A 的"),n("strong",[a._v("右子树")]),a._v("根节点的"),n("strong",[a._v("左子树")]),a._v("上插入节点而破坏平衡")]),a._v(" "),n("td",[a._v("先右旋后左旋转")])])])]),a._v(" "),n("p",[n("strong",[a._v("插入相关代码")])]),a._v(" "),n("p",[a._v("在向 AVL 树插入节点后，我们需要检查树是否需要进行平衡，因此要使用递归计算以每个插入的节点为根的节点的平衡因子，然后对每种情况应用正确的旋转。")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("insert(key){\n    this.root = this.insertNode(this.root,key);\n}\ninsertNode(node,key){\n    // 像在BST树中一样插入节点\n    if(node == null){\n        return new Node(key);\n    }else if (this.compareFn(key,node.key)===Compare.LESS_THAN){\n        node.left = this.insertNode(node.left,key);\n    }else if(this.compareFn(key,node.key)===Compare.BIGGER_THAN){\n        node.right = this.insertNode(node.right,key);\n    }else{\n        return node;        // 重复的键\n    }\n    // 如果需要，将树进行平衡操作\n    const balanceFactor = this.getBalanceFactor(node);\n    if(balanceFactor === BalanceFactor.UNBALANCED_LEFT){\n        if(this.compareFn(key,node.left.key) === Compare.LESS_THAN){\n            node = this.rotationLL(node);\n        }else{\n            return this.rottionLR(node);\n        }\n    }\n    if(balanceFactor === BalanceFactor.UNBALANCED_RIGHT){\n        if(this.compareFn(key,node.right.key)===Compare.BIGGER_THAN){\n            node = this.rotationRR(node);\n        }else{\n            return this.rotationRL(node);\n        }\n    }\n    return node;\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br"),n("span",{staticClass:"line-number"},[a._v("26")]),n("br"),n("span",{staticClass:"line-number"},[a._v("27")]),n("br"),n("span",{staticClass:"line-number"},[a._v("28")]),n("br"),n("span",{staticClass:"line-number"},[a._v("29")]),n("br"),n("span",{staticClass:"line-number"},[a._v("30")]),n("br"),n("span",{staticClass:"line-number"},[a._v("31")]),n("br"),n("span",{staticClass:"line-number"},[a._v("32")]),n("br")])]),n("p",[a._v("如果在向左侧子树插入节点后树不平衡了，我们需要比较是否插入的键小于左侧子节点的键。如果是，我们要进行 LL 旋转。否则，要进行 LR 旋转。")]),a._v(" "),n("p",[a._v("如果在向右侧子树插入节点后树不平衡了，我们需要比较是否插入的键小于右侧子节点的键。如果是，我们要进行 RR 旋转。否则，要进行 RL 旋转。")]),a._v(" "),n("p",[n("strong",[a._v("删除相关代码")])]),a._v(" "),n("p",[a._v("除了移除节点外，我们还要难移除后树是否还是平衡的，如果不是，就要进行必要的旋转操作。")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("removeNode(node,key){\n    node = super.removeNode(node,key);\n    if(node == null){\n        return node;    // null，不需要进行平衡\n    }\n    //  检测树是否平衡\n    const balanceFactor = this.getBalanceFactor(node);\n    if(balanceFactor === BalanceFactor.UNBALANCED_LEFT){\n        const balanceFactorLeft = this.getBalanceFactor(node.left);\n        if(balanceFactorLeft === BalanceFactor.BALANCED || balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT){\n            return this.rotationLL(node);\n        }\n        if(balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT){\n            return this.rotationLR(node.left);\n        }\n    }\n    if(balanceFactor === BalanceFactor.UNBALANCED_RIGTH){\n        const balanceFactorRight = this.getBalanceFactor(node.right);\n        if(balanceFactorRight === BalanceFactor.BALANCED || balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT){\n            return this.rotationRR(node);\n        }\n        if(balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT){\n            return this.rotationRL(node.right);\n        }\n    }\n    return node;\n}\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br"),n("span",{staticClass:"line-number"},[a._v("26")]),n("br"),n("span",{staticClass:"line-number"},[a._v("27")]),n("br")])]),n("p",[a._v("如果在从左侧子树移除节点后树不平衡了，我们要计算左侧子树的平衡因子。如果左侧子树向左不平衡，要进行 LL 旋转；如果左侧子树向右不平衡，要进行 LR 旋转。")]),a._v(" "),n("p",[a._v("最后一种情况是，如果在从右侧子树移除节点后树不平衡了，我们要计算右侧子树的平衡因子。如果右侧子树向右不平衡，要进行 RR 旋转；如果右侧子树向左不平衡，要进行 LR 旋转。")]),a._v(" "),n("h3",{attrs:{id:"六、红黑树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#六、红黑树"}},[a._v("#")]),a._v(" 六、红黑树")]),a._v(" "),n("p",[a._v("红黑树是一种常见的自平衡二叉查找树，常用于关联数组、字典，在各种语言的底层实现中被广泛应用，Java 的 TreeMap 和 TreeSet 就是基于红黑树实现的。")]),a._v(" "),n("p",[a._v("在红黑树中，每个节点都遵循以下规则：")]),a._v(" "),n("ul",[n("li",[a._v("顾名思义，每个节点不是红的就是黑的；")]),a._v(" "),n("li",[a._v("树的根节点是黑的；")]),a._v(" "),n("li",[a._v("所有叶节点都是黑的（用 NULL 引用表示的节点）；")]),a._v(" "),n("li",[a._v("如果一个节点是红色的，那么它的两个子节点都是黑的；")]),a._v(" "),n("li",[a._v("不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；")]),a._v(" "),n("li",[a._v("从给定的节点到它的后代节点的所有路径包含相同数量的黑色节点")])]),a._v(" "),n("h3",{attrs:{id:"参考资料"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[a._v("#")]),a._v(" 参考资料")]),a._v(" "),n("ul",[n("li",[a._v("《学习 JavaScript 数据结构与算法》")]),a._v(" "),n("li",[n("a",{attrs:{href:"https://mp.weixin.qq.com/s/zav3hOoj6eszlOM7YfgYeA",target:"_blank",rel:"noopener noreferrer"}},[a._v("什么是平衡二叉树（AVL）"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://mp.weixin.qq.com/s/Un1LuUo4LDQC8Sl-mfg4og",target:"_blank",rel:"noopener noreferrer"}},[a._v("我画了 20 张图，给女朋友讲清楚红黑树"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://juejin.im/post/5dff59cb6fb9a0163c53ce1d",target:"_blank",rel:"noopener noreferrer"}},[a._v("通俗易懂的红黑树图解(上)"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://mp.weixin.qq.com/s/dSGIHvgth7IqEZxG11rKOA",target:"_blank",rel:"noopener noreferrer"}},[a._v("动画 | 什么是红黑树"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://mp.weixin.qq.com/s/tFJqwKa-adXW0kXGxldisg",target:"_blank",rel:"noopener noreferrer"}},[a._v("动画：二叉树在实际中的应用(下）"),n("OutboundLink")],1)]),a._v(" "),n("li",[n("a",{attrs:{href:"https://mp.weixin.qq.com/s/0nubI8XPcUJYAaEk-Eomrg",target:"_blank",rel:"noopener noreferrer"}},[a._v("动画 | 什么是二分搜索树（附伪代码）"),n("OutboundLink")],1)])]),a._v(" "),n("h2",{attrs:{id:"联系作者"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#联系作者"}},[a._v("#")]),a._v(" 联系作者")]),a._v(" "),n("div",{attrs:{align:"center"}},[n("p",[a._v("\n        平凡世界，贵在坚持。\n    ")]),a._v(" "),n("img",{attrs:{src:a.$withBase("/about/contact.png")}})])])}),[],!1,null,null,null);t.default=e.exports}}]);