<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js 相关面试题 | 小武子知识库</title>
    <meta name="description" content="用心，谈技术。大前端">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/hero.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.23dd1510.css" as="style"><link rel="preload" href="/assets/js/app.c40970e9.js" as="script"><link rel="preload" href="/assets/js/2.c7f5c1a5.js" as="script"><link rel="preload" href="/assets/js/122.9a191ee2.js" as="script"><link rel="preload" href="/assets/js/3.fb5a4386.js" as="script"><link rel="prefetch" href="/assets/js/10.1bd37a44.js"><link rel="prefetch" href="/assets/js/100.8e20d6d0.js"><link rel="prefetch" href="/assets/js/101.3c9fa76f.js"><link rel="prefetch" href="/assets/js/102.2c53546c.js"><link rel="prefetch" href="/assets/js/103.3dcaaa95.js"><link rel="prefetch" href="/assets/js/104.78661b94.js"><link rel="prefetch" href="/assets/js/105.65299879.js"><link rel="prefetch" href="/assets/js/106.ab731e5b.js"><link rel="prefetch" href="/assets/js/107.b728f32f.js"><link rel="prefetch" href="/assets/js/108.ff0b8f9f.js"><link rel="prefetch" href="/assets/js/109.13d76b41.js"><link rel="prefetch" href="/assets/js/11.61939ed3.js"><link rel="prefetch" href="/assets/js/110.b9c9303f.js"><link rel="prefetch" href="/assets/js/111.284fb75d.js"><link rel="prefetch" href="/assets/js/112.b3229d3d.js"><link rel="prefetch" href="/assets/js/113.c9ef2c8f.js"><link rel="prefetch" href="/assets/js/114.0574f15a.js"><link rel="prefetch" href="/assets/js/115.7d7f3939.js"><link rel="prefetch" href="/assets/js/116.1082fbb3.js"><link rel="prefetch" href="/assets/js/117.a82e7603.js"><link rel="prefetch" href="/assets/js/118.d06d3bfa.js"><link rel="prefetch" href="/assets/js/119.524e1084.js"><link rel="prefetch" href="/assets/js/12.820effe9.js"><link rel="prefetch" href="/assets/js/120.8203a215.js"><link rel="prefetch" href="/assets/js/121.fdcc81f6.js"><link rel="prefetch" href="/assets/js/123.754e06e5.js"><link rel="prefetch" href="/assets/js/124.153c75c6.js"><link rel="prefetch" href="/assets/js/125.d0471739.js"><link rel="prefetch" href="/assets/js/126.8c2dfe44.js"><link rel="prefetch" href="/assets/js/127.d90ae996.js"><link rel="prefetch" href="/assets/js/128.a8f0e48e.js"><link rel="prefetch" href="/assets/js/129.73f5bdc8.js"><link rel="prefetch" href="/assets/js/13.eb8f366e.js"><link rel="prefetch" href="/assets/js/130.48cdd5af.js"><link rel="prefetch" href="/assets/js/131.6fbe4f75.js"><link rel="prefetch" href="/assets/js/132.edfdc530.js"><link rel="prefetch" href="/assets/js/133.aa069ab5.js"><link rel="prefetch" href="/assets/js/134.f82cf443.js"><link rel="prefetch" href="/assets/js/135.3d0dc0de.js"><link rel="prefetch" href="/assets/js/136.ac1fe088.js"><link rel="prefetch" href="/assets/js/137.86d98288.js"><link rel="prefetch" href="/assets/js/138.2cafc925.js"><link rel="prefetch" href="/assets/js/139.b7f13cc4.js"><link rel="prefetch" href="/assets/js/14.b1ea70cc.js"><link rel="prefetch" href="/assets/js/140.d3ad7cb2.js"><link rel="prefetch" href="/assets/js/141.6d50061f.js"><link rel="prefetch" href="/assets/js/142.f9551284.js"><link rel="prefetch" href="/assets/js/143.6bfc4565.js"><link rel="prefetch" href="/assets/js/144.17535cf3.js"><link rel="prefetch" href="/assets/js/145.1afa8a09.js"><link rel="prefetch" href="/assets/js/146.20fd4cdd.js"><link rel="prefetch" href="/assets/js/147.140fc619.js"><link rel="prefetch" href="/assets/js/148.60b52088.js"><link rel="prefetch" href="/assets/js/149.bf707cfb.js"><link rel="prefetch" href="/assets/js/15.18324539.js"><link rel="prefetch" href="/assets/js/150.46099244.js"><link rel="prefetch" href="/assets/js/151.ca22f320.js"><link rel="prefetch" href="/assets/js/152.2f22a1c3.js"><link rel="prefetch" href="/assets/js/153.4347e5cb.js"><link rel="prefetch" href="/assets/js/154.9b4a7e4d.js"><link rel="prefetch" href="/assets/js/155.5d51257b.js"><link rel="prefetch" href="/assets/js/156.2e2bce3f.js"><link rel="prefetch" href="/assets/js/157.4cbc030c.js"><link rel="prefetch" href="/assets/js/158.2de10cda.js"><link rel="prefetch" href="/assets/js/159.94f4d0cb.js"><link rel="prefetch" href="/assets/js/16.6cf0429e.js"><link rel="prefetch" href="/assets/js/160.3cbb2abe.js"><link rel="prefetch" href="/assets/js/161.73c137dc.js"><link rel="prefetch" href="/assets/js/162.0a9070ee.js"><link rel="prefetch" href="/assets/js/163.b3409082.js"><link rel="prefetch" href="/assets/js/164.07a7ee0b.js"><link rel="prefetch" href="/assets/js/165.858cc7ab.js"><link rel="prefetch" href="/assets/js/166.658a9dd4.js"><link rel="prefetch" href="/assets/js/167.f56f7638.js"><link rel="prefetch" href="/assets/js/168.2b81ccee.js"><link rel="prefetch" href="/assets/js/169.b7ce28cc.js"><link rel="prefetch" href="/assets/js/17.a66ab52c.js"><link rel="prefetch" href="/assets/js/170.d21e8b9c.js"><link rel="prefetch" href="/assets/js/171.8f4e47c6.js"><link rel="prefetch" href="/assets/js/172.11f4bca0.js"><link rel="prefetch" href="/assets/js/173.a3dd63ec.js"><link rel="prefetch" href="/assets/js/174.f89ee86b.js"><link rel="prefetch" href="/assets/js/175.eda0ff69.js"><link rel="prefetch" href="/assets/js/176.42719a60.js"><link rel="prefetch" href="/assets/js/177.fa75d2f9.js"><link rel="prefetch" href="/assets/js/178.2fbd1a03.js"><link rel="prefetch" href="/assets/js/179.f722e0db.js"><link rel="prefetch" href="/assets/js/18.2683541a.js"><link rel="prefetch" href="/assets/js/180.516c0ef5.js"><link rel="prefetch" href="/assets/js/181.523eafa8.js"><link rel="prefetch" href="/assets/js/182.68cec107.js"><link rel="prefetch" href="/assets/js/183.1d06f3d4.js"><link rel="prefetch" href="/assets/js/184.acb7d417.js"><link rel="prefetch" href="/assets/js/185.fb79a702.js"><link rel="prefetch" href="/assets/js/186.4d6ce8ed.js"><link rel="prefetch" href="/assets/js/187.50a27854.js"><link rel="prefetch" href="/assets/js/188.3a45ab3d.js"><link rel="prefetch" href="/assets/js/189.679e8453.js"><link rel="prefetch" href="/assets/js/19.e9f416b2.js"><link rel="prefetch" href="/assets/js/190.df9de0f1.js"><link rel="prefetch" href="/assets/js/191.36360d11.js"><link rel="prefetch" href="/assets/js/192.29c05707.js"><link rel="prefetch" href="/assets/js/193.5ff37602.js"><link rel="prefetch" href="/assets/js/194.b6e5f1d3.js"><link rel="prefetch" href="/assets/js/195.8d5d9925.js"><link rel="prefetch" href="/assets/js/196.8f281b36.js"><link rel="prefetch" href="/assets/js/197.6f939576.js"><link rel="prefetch" href="/assets/js/198.c2ae4a9d.js"><link rel="prefetch" href="/assets/js/199.c0597f31.js"><link rel="prefetch" href="/assets/js/20.c75409b7.js"><link rel="prefetch" href="/assets/js/200.24b74193.js"><link rel="prefetch" href="/assets/js/201.45aa9454.js"><link rel="prefetch" href="/assets/js/202.529ec5e7.js"><link rel="prefetch" href="/assets/js/203.c085240e.js"><link rel="prefetch" href="/assets/js/204.5c9c4ca1.js"><link rel="prefetch" href="/assets/js/205.ce2a645d.js"><link rel="prefetch" href="/assets/js/206.92fc7221.js"><link rel="prefetch" href="/assets/js/207.86c4ec1b.js"><link rel="prefetch" href="/assets/js/208.4b83d46a.js"><link rel="prefetch" href="/assets/js/209.197f7372.js"><link rel="prefetch" href="/assets/js/21.859bd6ba.js"><link rel="prefetch" href="/assets/js/210.0c7cd42d.js"><link rel="prefetch" href="/assets/js/211.22841173.js"><link rel="prefetch" href="/assets/js/212.76d4668e.js"><link rel="prefetch" href="/assets/js/213.f68d1832.js"><link rel="prefetch" href="/assets/js/214.abf957aa.js"><link rel="prefetch" href="/assets/js/215.f391ef5d.js"><link rel="prefetch" href="/assets/js/216.4354b097.js"><link rel="prefetch" href="/assets/js/217.6946cf07.js"><link rel="prefetch" href="/assets/js/218.9071e8c7.js"><link rel="prefetch" href="/assets/js/219.62e1bacb.js"><link rel="prefetch" href="/assets/js/22.99ba97f7.js"><link rel="prefetch" href="/assets/js/220.871926ae.js"><link rel="prefetch" href="/assets/js/221.e34464ed.js"><link rel="prefetch" href="/assets/js/222.9dcbbc94.js"><link rel="prefetch" href="/assets/js/223.05e4a053.js"><link rel="prefetch" href="/assets/js/224.08164565.js"><link rel="prefetch" href="/assets/js/225.3de588b0.js"><link rel="prefetch" href="/assets/js/226.a9a5d370.js"><link rel="prefetch" href="/assets/js/227.f858214f.js"><link rel="prefetch" href="/assets/js/228.eb88257c.js"><link rel="prefetch" href="/assets/js/229.b3240535.js"><link rel="prefetch" href="/assets/js/23.185b8fea.js"><link rel="prefetch" href="/assets/js/230.ffb1001d.js"><link rel="prefetch" href="/assets/js/231.4c0b3ec3.js"><link rel="prefetch" href="/assets/js/232.a7ee83ed.js"><link rel="prefetch" href="/assets/js/233.55adb8b3.js"><link rel="prefetch" href="/assets/js/234.7382e531.js"><link rel="prefetch" href="/assets/js/235.25ece0a0.js"><link rel="prefetch" href="/assets/js/236.ff6f2972.js"><link rel="prefetch" href="/assets/js/237.91468aff.js"><link rel="prefetch" href="/assets/js/238.082fe32d.js"><link rel="prefetch" href="/assets/js/239.548d2c89.js"><link rel="prefetch" href="/assets/js/24.5b6660c1.js"><link rel="prefetch" href="/assets/js/240.7dd2b2c0.js"><link rel="prefetch" href="/assets/js/241.f839282a.js"><link rel="prefetch" href="/assets/js/242.5b1c24d0.js"><link rel="prefetch" href="/assets/js/243.75b9e971.js"><link rel="prefetch" href="/assets/js/244.26669af6.js"><link rel="prefetch" href="/assets/js/245.c405ac90.js"><link rel="prefetch" href="/assets/js/246.4ea725c8.js"><link rel="prefetch" href="/assets/js/247.15748b28.js"><link rel="prefetch" href="/assets/js/248.e2ed4d3b.js"><link rel="prefetch" href="/assets/js/249.ec764597.js"><link rel="prefetch" href="/assets/js/25.21c8e8c5.js"><link rel="prefetch" href="/assets/js/250.7a30e7f4.js"><link rel="prefetch" href="/assets/js/251.8aa581fb.js"><link rel="prefetch" href="/assets/js/252.c40d9005.js"><link rel="prefetch" href="/assets/js/253.547824c3.js"><link rel="prefetch" href="/assets/js/254.bf3da329.js"><link rel="prefetch" href="/assets/js/255.c4765a2f.js"><link rel="prefetch" href="/assets/js/256.be83ef8f.js"><link rel="prefetch" href="/assets/js/257.2daf23fb.js"><link rel="prefetch" href="/assets/js/258.1bc42661.js"><link rel="prefetch" href="/assets/js/259.18d365de.js"><link rel="prefetch" href="/assets/js/26.880cbbd2.js"><link rel="prefetch" href="/assets/js/260.7f69b0ff.js"><link rel="prefetch" href="/assets/js/261.719ea459.js"><link rel="prefetch" href="/assets/js/262.b2d92c17.js"><link rel="prefetch" href="/assets/js/263.55062ded.js"><link rel="prefetch" href="/assets/js/264.71932296.js"><link rel="prefetch" href="/assets/js/265.471e7bdf.js"><link rel="prefetch" href="/assets/js/266.38cbf3da.js"><link rel="prefetch" href="/assets/js/267.42bb114d.js"><link rel="prefetch" href="/assets/js/268.12f00a94.js"><link rel="prefetch" href="/assets/js/269.1e4eabfe.js"><link rel="prefetch" href="/assets/js/27.80fb639e.js"><link rel="prefetch" href="/assets/js/270.db45ed35.js"><link rel="prefetch" href="/assets/js/271.d64af46b.js"><link rel="prefetch" href="/assets/js/272.178203b3.js"><link rel="prefetch" href="/assets/js/273.bd21539e.js"><link rel="prefetch" href="/assets/js/274.17cdef2b.js"><link rel="prefetch" href="/assets/js/275.188d70a0.js"><link rel="prefetch" href="/assets/js/276.144c30ce.js"><link rel="prefetch" href="/assets/js/277.5c099769.js"><link rel="prefetch" href="/assets/js/278.dd60beac.js"><link rel="prefetch" href="/assets/js/279.ddf07f53.js"><link rel="prefetch" href="/assets/js/28.f5fec614.js"><link rel="prefetch" href="/assets/js/280.4befc55d.js"><link rel="prefetch" href="/assets/js/281.c07d3b22.js"><link rel="prefetch" href="/assets/js/282.7ba9a4a1.js"><link rel="prefetch" href="/assets/js/283.89a2d35a.js"><link rel="prefetch" href="/assets/js/284.87c98875.js"><link rel="prefetch" href="/assets/js/285.7110e63e.js"><link rel="prefetch" href="/assets/js/286.eb3e647f.js"><link rel="prefetch" href="/assets/js/287.3ad60519.js"><link rel="prefetch" href="/assets/js/288.84aa1b13.js"><link rel="prefetch" href="/assets/js/289.5c263c7e.js"><link rel="prefetch" href="/assets/js/29.9908c78c.js"><link rel="prefetch" href="/assets/js/290.34430c5a.js"><link rel="prefetch" href="/assets/js/291.944b5f57.js"><link rel="prefetch" href="/assets/js/292.b9a0733e.js"><link rel="prefetch" href="/assets/js/30.34bb962f.js"><link rel="prefetch" href="/assets/js/31.65acd4bc.js"><link rel="prefetch" href="/assets/js/32.77d04032.js"><link rel="prefetch" href="/assets/js/33.69e03757.js"><link rel="prefetch" href="/assets/js/34.90a860f7.js"><link rel="prefetch" href="/assets/js/35.053cdcb5.js"><link rel="prefetch" href="/assets/js/36.b9d6e586.js"><link rel="prefetch" href="/assets/js/37.df4278da.js"><link rel="prefetch" href="/assets/js/38.7f0ad1d1.js"><link rel="prefetch" href="/assets/js/39.3087fb3d.js"><link rel="prefetch" href="/assets/js/4.66c85cad.js"><link rel="prefetch" href="/assets/js/40.d94477b6.js"><link rel="prefetch" href="/assets/js/41.6cbb6fe4.js"><link rel="prefetch" href="/assets/js/42.93a62ef3.js"><link rel="prefetch" href="/assets/js/43.c3d1e2d1.js"><link rel="prefetch" href="/assets/js/44.fe6dcf90.js"><link rel="prefetch" href="/assets/js/45.9637347f.js"><link rel="prefetch" href="/assets/js/46.e37bd7d2.js"><link rel="prefetch" href="/assets/js/47.f17684e0.js"><link rel="prefetch" href="/assets/js/48.a5b242e7.js"><link rel="prefetch" href="/assets/js/49.25631c99.js"><link rel="prefetch" href="/assets/js/5.162e5946.js"><link rel="prefetch" href="/assets/js/50.b0dccb6e.js"><link rel="prefetch" href="/assets/js/51.bb115efc.js"><link rel="prefetch" href="/assets/js/52.a562af5b.js"><link rel="prefetch" href="/assets/js/53.918c55ab.js"><link rel="prefetch" href="/assets/js/54.df92ac76.js"><link rel="prefetch" href="/assets/js/55.2ff93588.js"><link rel="prefetch" href="/assets/js/56.846b5407.js"><link rel="prefetch" href="/assets/js/57.314b9920.js"><link rel="prefetch" href="/assets/js/58.076f02e0.js"><link rel="prefetch" href="/assets/js/59.94b7c142.js"><link rel="prefetch" href="/assets/js/6.3ee933b5.js"><link rel="prefetch" href="/assets/js/60.34a17555.js"><link rel="prefetch" href="/assets/js/61.60e64873.js"><link rel="prefetch" href="/assets/js/62.d4c18fad.js"><link rel="prefetch" href="/assets/js/63.b01ac5ae.js"><link rel="prefetch" href="/assets/js/64.167ecb25.js"><link rel="prefetch" href="/assets/js/65.8b7fd4ae.js"><link rel="prefetch" href="/assets/js/66.ec783047.js"><link rel="prefetch" href="/assets/js/67.1d98f48a.js"><link rel="prefetch" href="/assets/js/68.84a0fdc5.js"><link rel="prefetch" href="/assets/js/69.45991f9e.js"><link rel="prefetch" href="/assets/js/7.d1943d20.js"><link rel="prefetch" href="/assets/js/70.cbeb0042.js"><link rel="prefetch" href="/assets/js/71.d844f970.js"><link rel="prefetch" href="/assets/js/72.109be50e.js"><link rel="prefetch" href="/assets/js/73.370a700a.js"><link rel="prefetch" href="/assets/js/74.58c90c0f.js"><link rel="prefetch" href="/assets/js/75.34b46d1f.js"><link rel="prefetch" href="/assets/js/76.04623a57.js"><link rel="prefetch" href="/assets/js/77.4aa16d9f.js"><link rel="prefetch" href="/assets/js/78.75127a1b.js"><link rel="prefetch" href="/assets/js/79.da8ffe9a.js"><link rel="prefetch" href="/assets/js/8.d944b1d8.js"><link rel="prefetch" href="/assets/js/80.126e536a.js"><link rel="prefetch" href="/assets/js/81.021df4de.js"><link rel="prefetch" href="/assets/js/82.96d7e454.js"><link rel="prefetch" href="/assets/js/83.92546031.js"><link rel="prefetch" href="/assets/js/84.7dc07ebc.js"><link rel="prefetch" href="/assets/js/85.3f6eda79.js"><link rel="prefetch" href="/assets/js/86.f50b0c4c.js"><link rel="prefetch" href="/assets/js/87.7bb4b9c0.js"><link rel="prefetch" href="/assets/js/88.20c7fe37.js"><link rel="prefetch" href="/assets/js/89.e9f54a72.js"><link rel="prefetch" href="/assets/js/9.2fda250d.js"><link rel="prefetch" href="/assets/js/90.d5a35b83.js"><link rel="prefetch" href="/assets/js/91.8461d8dd.js"><link rel="prefetch" href="/assets/js/92.07f26d35.js"><link rel="prefetch" href="/assets/js/93.51682ff9.js"><link rel="prefetch" href="/assets/js/94.b65d2ab6.js"><link rel="prefetch" href="/assets/js/95.4cbdf8d0.js"><link rel="prefetch" href="/assets/js/96.4e338dc9.js"><link rel="prefetch" href="/assets/js/97.8e891b26.js"><link rel="prefetch" href="/assets/js/98.6a285a87.js"><link rel="prefetch" href="/assets/js/99.cecddc3f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.23dd1510.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">小武子知识库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/js/" class="nav-link">
  javascript
</a></div><div class="nav-item"><a href="/css/" class="nav-link">
  css
</a></div><div class="nav-item"><a href="/html5/" class="nav-link">
  HTML5
</a></div><div class="nav-item"><a href="/tool/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  软件工程
</a></div><div class="nav-item"><a href="/cs/" class="nav-link">
  计算机基础
</a></div><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/materials/" class="nav-link">
  资料收集
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于作者
</a></div><div class="nav-item"><a href="https://www.github.com/fttony" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/js/" class="nav-link">
  javascript
</a></div><div class="nav-item"><a href="/css/" class="nav-link">
  css
</a></div><div class="nav-item"><a href="/html5/" class="nav-link">
  HTML5
</a></div><div class="nav-item"><a href="/tool/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  软件工程
</a></div><div class="nav-item"><a href="/cs/" class="nav-link">
  计算机基础
</a></div><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/materials/" class="nav-link">
  资料收集
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于作者
</a></div><div class="nav-item"><a href="https://www.github.com/fttony" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>js相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/js-interview1.html" class="active sidebar-link">js 相关面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/js-interview1.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/interview/js-interview1.html#内容" class="sidebar-link">内容</a></li><li class="sidebar-sub-header"><a href="/interview/js-interview1.html#联系作者" class="sidebar-link">联系作者</a></li></ul></li><li><a href="/interview/js-interview2.html" class="sidebar-link">js 面试题二</a></li><li><a href="/interview/js-interview3.html" class="sidebar-link">js 面试题三</a></li><li><a href="/interview/js-interview4.html" class="sidebar-link">js 面试题四</a></li><li><a href="/interview/es6-interview.html" class="sidebar-link">es6 面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>css相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/css-interview1.html" class="sidebar-link">CSS 相关面试题一</a></li><li><a href="/interview/css-interview2.html" class="sidebar-link">CSS 相关面试题二</a></li><li><a href="/interview/css-interview3.html" class="sidebar-link">CSS 相关面试题三</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTML相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/html5-interview.html" class="sidebar-link">HTML5 面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>框架相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/vue-interview.html" class="sidebar-link">vue 相关面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>node相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/node-interview.html" class="sidebar-link">node 面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>计算机基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/net-interview.html" class="sidebar-link">网络面试题</a></li><li><a href="/interview/offer.html" class="sidebar-link">指剑 offer 相关题</a></li><li><a href="/interview/leetcode.html" class="sidebar-link">leetcode相关题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/browser-interview.html" class="sidebar-link">浏览器相关面试题</a></li><li><a href="/interview/performance-interview.html" class="sidebar-link">性能相关面试题</a></li><li><a href="/interview/webpack-interview.html" class="sidebar-link">webpack 面试题</a></li><li><a href="/interview/project-interview.html" class="sidebar-link">前端工程面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>面试技巧</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/interview-skill1.html" class="sidebar-link">面试技巧——简历篇</a></li><li><a href="/interview/interview-skill2.html" class="sidebar-link">面试技巧——答问题篇</a></li><li><a href="/interview/interview-skill3.html" class="sidebar-link">面试技巧——HR 篇</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其它</span> <!----></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js-相关面试题"><a href="#js-相关面试题" class="header-anchor">#</a> js 相关面试题</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>本人平时学习及收集内容，欢迎参入一起讨论。</p> <h2 id="内容"><a href="#内容" class="header-anchor">#</a> 内容</h2> <ul><li>基本类型有哪几种？null 是对象吗？基本数据类型和复杂数据类型存储有什么区别？</li> <li>typeof 是否正确判断类型? instanceof 呢？ instanceof 的实现原理是什么？</li> <li>for of , for in 和 forEach,map 的区别。</li> <li>如何判断一个变量是不是数组？</li> <li>类数组和数组的区别是什么？</li> <li>== 和 === 有什么区别？</li> <li>[] == ![]</li> <li>ES6 中的 class 和 ES5 的类有什么区别？</li> <li>数组的哪些 API 会改变原数组？</li> <li>let、const 以及 var 的区别是什么？</li> <li>在 JS 中什么是变量提升？什么是暂时性死区？</li> <li>如何正确的判断 this? 箭头函数的 this 是什么？</li> <li>词法作用域和 this 的区别。</li> <li>谈谈你对 JS 执行上下文栈和作用域链的理解。</li> <li>什么是闭包？闭包的作用是什么？闭包有哪些使用场景？</li> <li>call、apply 有什么区别？call,aplly 和 bind 的内部是如何实现的？</li> <li>new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？</li> <li>谈谈你对原型的理解？</li> <li>什么是原型链？【原型链解决的是什么问题？】</li> <li>prototype 和 <code>__proto__</code> 区别是什么？</li> <li>使用 ES5 实现一个继承？</li> <li>什么是深拷贝？深拷贝和浅拷贝有什么区别？</li> <li>防抖和节流的区别是什么？防抖和节流的实现。</li> <li>取数组的最大值（ES5、ES6）</li> <li>ES6 新的特性有哪些？</li> <li>setTimeout 倒计时为什么会出现误差？</li> <li>为什么 0.1 + 0.2 != 0.3 ?</li> <li>promise 有几种状态, Promise 有什么优缺点 ?</li> <li>Promise 构造函数是同步还是异步执行，then 中的方法呢 ?promise 如何实现 then 处理 ?</li> <li>Promise 和 setTimeout 的区别 ?</li> <li>如何实现 Promise.all ?</li> <li>如何实现 Promise.finally ?</li> <li>什么是函数柯里化？实现 sum(1)(2)(3) 返回结果是 1,2,3 之和</li> <li>说一说 JS 异步发展史</li> <li>谈谈对 async/await 的理解，async/await 的实现原理是什么?</li> <li>使用 async/await 需要注意什么？</li> <li>如何实现 Promise.race？</li> <li>可遍历数据结构的有什么特点？</li> <li>requestAnimationFrame 和 setTimeout/setInterval 有什么区别？使用 requestAnimationFrame 有哪些好处？</li> <li>JS 类型转换的规则是什么？</li> <li>简述下对 webWorker 的理解？</li> <li>ES6 模块和 CommonJS 模块的差异？</li> <li>浏览器事件代理机制的原理是什么？</li> <li>js 如何自定义事件？</li> <li>跨域的方法有哪些？原理是什么？</li> <li>js 异步加载的方式有哪些？</li> <li>下面代码 a 在什么情况中打印出 1？</li> <li>下面这段代码的输出是什么？</li> <li>实现双向绑定 Proxy 与 Object.defineProperty 相比优劣如何?</li> <li>Object.is() 与比较操作符 ===、== 有什么区别？</li> <li>什么是事件循环？Node 事件循环和 JS 事件循环的差异是什么？</li></ul> <h3 id="_1-基本类型有哪几种？null-是对象吗？基本数据类型和复杂数据类型存储有什么区别？"><a href="#_1-基本类型有哪几种？null-是对象吗？基本数据类型和复杂数据类型存储有什么区别？" class="header-anchor">#</a> 1.基本类型有哪几种？null 是对象吗？基本数据类型和复杂数据类型存储有什么区别？</h3> <ul><li>基本类型有 6 种，分别是 undefined,null,bool,string,number,symbol(ES6 新增)。</li> <li>虽然 typeof null 返回的值是 object,但是 null 不是对象，而是基本数据类型的一种。</li> <li>基本数据类型存储在栈内存，存储的是值。</li> <li>复杂数据类型的值存储在堆内存，地址（指向堆中的值）存储在栈内存。当我们把对象赋值给另外一个变量的时候，复制的是地址，指向同一块内存空间，当其中一个对象改变时，另一个对象也会变化。</li></ul> <h3 id="_2-typeof-是否正确判断类型-instanceof-呢？-instanceof-的实现原理是什么？"><a href="#_2-typeof-是否正确判断类型-instanceof-呢？-instanceof-的实现原理是什么？" class="header-anchor">#</a> 2.typeof 是否正确判断类型? instanceof 呢？ instanceof 的实现原理是什么？</h3> <p>首先 typeof 能够正确的判断基本数据类型，但是除了 null, typeof null 输出的是对象。
但是对象来说，typeof 不能正确的判断其类型， typeof 一个函数可以输出 'function',而除此之外，输出的全是 object,这种情况下，我们无法准确的知道对象的类型。</p> <p>instanceof 可以准确的判断复杂数据类型，但是不能正确判断基本数据类型。</p> <p>instanceof 是通过原型链判断的，A instanceof B, 在 A 的原型链中层层查找，是否有原型等于 <code>B.prototype</code>，如果一直找到 A 的原型链的顶端(null;即 <code>Object.__proto__.__proto__</code>),仍然不等于 <code>B.prototype</code>，那么返回 false，否则返回 true.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// L instanceof R
function instance_of(L, R) {//L 表示左表达式，R 表示右表达式
    var O = R.prototype;// 取 R 的显式原型
    L = L.__proto__;    // 取 L 的隐式原型
    while (true) {
        if (L === null) //已经找到顶层
            return false;
        if (O === L)   //当 O 严格等于 L 时，返回 true
            return true;
        L = L.__proto__;  //继续向上一层原型链查找
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="_3-for-of-for-in-和-foreach-map-的区别。"><a href="#_3-for-of-for-in-和-foreach-map-的区别。" class="header-anchor">#</a> 3.for of , for in 和 forEach,map 的区别。</h3> <ul><li>for...of 循环：具有 iterator 接口，就可以用 for...of 循环遍历它的成员(属性值)。for...of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象、Generator 对象，以及字符串。for...of 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。对于普通的对象，for...of 结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。可以中断循环。</li> <li>for...in 循环：遍历对象自身的和继承的可枚举的属性, 不能直接获取属性值。可以中断循环。</li> <li>forEach: 只能遍历数组，不能中断，没有返回值(或认为返回值是 undefined)。</li> <li>map: 只能遍历数组，不能中断，返回值是修改后的数组。</li></ul> <h3 id="_4-如何判断一个变量是不是数组？"><a href="#_4-如何判断一个变量是不是数组？" class="header-anchor">#</a> 4.如何判断一个变量是不是数组？</h3> <ul><li>使用 Array.isArray 判断，如果返回 true, 说明是数组</li> <li>使用 instanceof Array 判断，如果返回 true, 说明是数组</li> <li>使用 Object.prototype.toString.call 判断，如果值是 [object Array], 说明是数组</li> <li>通过 constructor 来判断，如果是数组，那么 <code>arr.constructor === Array</code>. (不准确，因为我们可以指定 <code>obj.constructor = Array</code>)</li></ul> <h3 id="_5-类数组和数组的区别是什么？"><a href="#_5-类数组和数组的区别是什么？" class="header-anchor">#</a> 5.类数组和数组的区别是什么？</h3> <ol><li>拥有 length 属性，其它属性（索引）为非负整数（对象中的索引会被当做字符串来处理）;</li> <li>不具有数组所具有的方法；</li></ol> <p>类数组是一个普通对象，而真实的数组是 Array 类型。</p> <p>常见的类数组有: 函数的参数 arguments, DOM 对象列表(比如通过 document.querySelectorAll 得到的列表), jQuery 对象 (比如 <code>$(&quot;div&quot;)</code>).</p> <p>任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。</p> <p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。</p> <h3 id="_6-和-有什么区别？"><a href="#_6-和-有什么区别？" class="header-anchor">#</a> 6.== 和 === 有什么区别？</h3> <p>=== 不需要进行类型转换，只有类型相同并且值相等时，才返回 true.</p> <p>== 如果两者类型不同，首先需要进行类型转换。具体流程如下:</p> <ol><li>首先判断两者类型是否相同，如果相等，判断值是否相等.</li> <li>如果类型不同，进行类型转换</li> <li>判断比较的是否是 null 或者是 undefined, 如果是, 返回 true .</li> <li>判断两者类型是否为 string 和 number, 如果是, 将字符串转换成 number</li> <li>判断其中一方是否为 boolean, 如果是, 将 boolean 转为 number 再进行判断</li> <li>判断其中一方是否为 object 且另一方为 string、number 或者 symbol , 如果是, 将 object 转为原始类型再进行判断</li></ol> <h4 id="思考："><a href="#思考：" class="header-anchor">#</a> 思考：.[] == ![]</h4> <p>我们来分析一下: <code>[] == ![]</code>是 true 还是 false？</p> <ol><li>首先，我们需要知道 ! 优先级是高于 == (更多运算符优先级可查看: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener noreferrer">运算符优先级<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)</li> <li><code>![]</code>引用类型转换成布尔值都是 true,因此<code>![]</code>的是 false</li> <li>根据上面的比较步骤中的第五条，其中一方是 boolean，将 boolean 转为 number 再进行判断，false 转换成 number，对应的值是 0.</li> <li>根据上面比较步骤中的第六条，有一方是 number，那么将 object 也转换成 Number,空数组转换成数字，对应的值是 0.(空数组转换成数字，对应的值是 0，如果数组中只有一个数字，那么转成 number 就是这个数字，其它情况，均为 NaN)</li> <li>0 == 0; 为 true</li></ol> <h3 id="_8-es6-中的-class-和-es5-的类有什么区别？"><a href="#_8-es6-中的-class-和-es5-的类有什么区别？" class="header-anchor">#</a> 8.ES6 中的 class 和 ES5 的类有什么区别？</h3> <ol><li>ES6 class 内部所有定义的方法都是不可枚举的；</li> <li>ES6 class 必须使用 new 调用；</li> <li>ES6 class 不存在变量提升；</li> <li>ES6 class 默认即是严格模式；</li> <li>ES6 class 子类必须在父类的构造函数中调用 super()，这样才有 this 对象；ES5 中类继承的关系是相反的，先有子类的 this，然后用父类的方法应用在 this 上。</li></ol> <h3 id="_9-数组的哪些-api-会改变原数组？"><a href="#_9-数组的哪些-api-会改变原数组？" class="header-anchor">#</a> 9.数组的哪些 API 会改变原数组？</h3> <p>修改原数组的 API 有:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>splice/reverse/fill/copyWithin/sort/push/pop/unshift/shift
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>不修改原数组的 API 有:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>slice/map/forEach/every/filter/reduce/entries/find/concat
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注: 数组的每一项是简单数据类型，且未直接操作数组的情况下(稍后会对此题重新作答)。</p> <h3 id="_10-let、const-以及-var-的区别是什么？"><a href="#_10-let、const-以及-var-的区别是什么？" class="header-anchor">#</a> 10.let、const 以及 var 的区别是什么？</h3> <ol><li>let 和 const 定义的变量不会出现变量提升，而 var 定义的变量会提升。</li> <li>let 和 const 是 JS 中的块级作用域</li> <li>let 和 const 不允许重复声明(会抛出错误)</li> <li>let 和 const 定义的变量在定义语句之前，如果使用会抛出错误(形成了暂时性死区)，而 var 不会。</li> <li>const 声明一个只读的常量。一旦声明，常量的值就不能改变(如果声明是一个对象，那么不能改变的是对象的引用地址)</li></ol> <h3 id="_11-在-js-中什么是变量提升？什么是暂时性死区？"><a href="#_11-在-js-中什么是变量提升？什么是暂时性死区？" class="header-anchor">#</a> 11.在 JS 中什么是变量提升？什么是暂时性死区？</h3> <p>变量提升就是变量在声明之前就可以使用，值为 undefined。</p> <p>在代码块内，使用 let/const 命令声明变量之前，该变量都是不可用的(会抛出错误)。这在语法上，称为“暂时性死区”。暂时性死区也意味着 typeof 不再是一个百分安全的操作。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>typeof x; // ReferenceError(暂时性死区，抛错)
let x;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p> <h3 id="_12-如何正确的判断-this-箭头函数的-this-是什么？"><a href="#_12-如何正确的判断-this-箭头函数的-this-是什么？" class="header-anchor">#</a> 12.如何正确的判断 this? 箭头函数的 this 是什么？</h3> <p>this 的绑定规则有四种：默认绑定，隐匿绑定，显式绑定，new 绑定</p> <ol><li>函数是否在 new 中调用(new 绑定)，如果是，那么 this 绑定的是新创建的对象【前提是构造函数中没有返回对象或者 function，否则 this 指向返回的对象/function】</li> <li>函数是否通过 call,apply 调用，或者使用了 bind (即硬绑定)，如果是，那么 this 绑定的就是指定的对象。</li> <li>函数是否在某个上下文对象中调用(隐式绑定)，如果是的话，this 绑定的是那个上下文对象。一般是 obj.foo()</li> <li>如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到 undefined，否则绑定到全局对象。</li> <li>如果把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind, 这些值在调用时会被忽略，实际应用的是默认绑定规则。</li> <li>箭头函数没有自己的 this, 它的 this 继承于上一层代码块的 this。</li></ol> <p>如果 this 的知识点，您还不太懂，请戳: <a href="https://km.xiaowuzi.info/js/es5-this.html" target="_blank" rel="noopener noreferrer">this 理解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_13-词法作用域和-this-的区别。"><a href="#_13-词法作用域和-this-的区别。" class="header-anchor">#</a> 13.词法作用域和 this 的区别。</h3> <ul><li>词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的</li> <li>this 是在调用时被绑定的，this 指向什么，完全取决于函数的调用位置(关于 this 的指向问题，本文已经有说明)</li></ul> <h3 id="_14-谈谈你对-js-执行上下文栈和作用域链的理解。"><a href="#_14-谈谈你对-js-执行上下文栈和作用域链的理解。" class="header-anchor">#</a> 14.谈谈你对 JS 执行上下文栈和作用域链的理解。</h3> <p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境, JS 执行上下文栈可以认为是一个存储函数调用的栈结构，遵循先进后出的原则。</p> <ul><li>JavaScript 执行在单线程上，所有的代码都是排队执行。</li> <li>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</li> <li>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行-完成后，当前函数的执行上下文出栈，并等待垃圾回收。</li> <li>浏览器的 JS 执行引擎总是访问栈顶的执行上下文。</li> <li>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</li></ul> <p>作用域链：无论是 LHS 还是 RHS 查询，都会在当前的作用域开始查找，如果没有找到，就会向上级作用域继续查找目标标识符，每次上升一个作用域，一直到全局作用域为止。</p> <p>如果执行上下文及上下文栈不理解的话，请戳<a href="https://km.xiaowuzi.info/js/es5-execution-context.html" target="_blank" rel="noopener noreferrer">执行上下文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_15-什么是闭包？闭包的作用是什么？闭包有哪些使用场景？"><a href="#_15-什么是闭包？闭包的作用是什么？闭包有哪些使用场景？" class="header-anchor">#</a> 15.什么是闭包？闭包的作用是什么？闭包有哪些使用场景？</h3> <p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包最常用的方式就是在一个函数内部创建另一个函数。</p> <p>闭包的作用有:</p> <ol><li>封装私有变量</li> <li>模仿块级作用域(ES5 中没有块级作用域)</li> <li>实现 JS 的模块</li></ol> <p>如果闭包不理解的话，请戳<a href="https://km.xiaowuzi.info/js/es5-closure.html" target="_blank" rel="noopener noreferrer">闭包<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_16-call、apply-有什么区别？call-aplly-和-bind-的内部是如何实现的？"><a href="#_16-call、apply-有什么区别？call-aplly-和-bind-的内部是如何实现的？" class="header-anchor">#</a> 16.call、apply 有什么区别？call,aplly 和 bind 的内部是如何实现的？</h3> <p>请戳以下两个链接：</p> <ul><li><a href="https://km.xiaowuzi.info/js/es5-apply-call-bind.html" target="_blank" rel="noopener noreferrer">apply&amp;bind&amp;call.<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/cs-learning-record/javascript-series/blob/master/javascript/apply%26bind%26call%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0.md" target="_blank" rel="noopener noreferrer">apply&amp;bind&amp;call 模拟实现<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="_17-new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？"><a href="#_17-new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？" class="header-anchor">#</a> 17.new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？</h3> <p>请戳链接：<a href="https://km.xiaowuzi.info/js/es5-news.html" target="_blank" rel="noopener noreferrer">new 模拟实现<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_18-谈谈你对原型的理解？"><a href="#_18-谈谈你对原型的理解？" class="header-anchor">#</a> 18.谈谈你对原型的理解？</h3> <p>请戳链接：<a href="https://km.xiaowuzi.info/js/es5-prototype.html" target="_blank" rel="noopener noreferrer">原型与原型链<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_19-什么是原型链？【原型链解决的是什么问题？】"><a href="#_19-什么是原型链？【原型链解决的是什么问题？】" class="header-anchor">#</a> 19.什么是原型链？【原型链解决的是什么问题？】</h3> <h3 id="_20-prototype-和-proto-区别是什么？"><a href="#_20-prototype-和-proto-区别是什么？" class="header-anchor">#</a> 20.prototype 和 <code>__proto__</code> 区别是什么？</h3> <h3 id="_21-使用-es5-实现一个继承？"><a href="#_21-使用-es5-实现一个继承？" class="header-anchor">#</a> 21.使用 ES5 实现一个继承？</h3> <p>请戳链接：<a href="https://km.xiaowuzi.info/js/es5-extends.html" target="_blank" rel="noopener noreferrer">继承<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_22-什么是深拷贝？深拷贝和浅拷贝有什么区别？"><a href="#_22-什么是深拷贝？深拷贝和浅拷贝有什么区别？" class="header-anchor">#</a> 22.什么是深拷贝？深拷贝和浅拷贝有什么区别？</h3> <p>请戳链接：<a href="https://km.xiaowuzi.info/js/js-clone.html" target="_blank" rel="noopener noreferrer">JS 的浅拷贝与深拷贝<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_23-防抖和节流的区别是什么？防抖和节流的实现。"><a href="#_23-防抖和节流的区别是什么？防抖和节流的实现。" class="header-anchor">#</a> 23.防抖和节流的区别是什么？防抖和节流的实现。</h3> <p>请戳链接：<a href="https://km.xiaowuzi.info/js/js-debounce.html" target="_blank" rel="noopener noreferrer">节流与防抖动<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_24-取数组的最大值（es5、es6）"><a href="#_24-取数组的最大值（es5、es6）" class="header-anchor">#</a> 24.取数组的最大值（ES5、ES6）</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>// ES5 的写法
Math.max.apply(null,[14,3,77,30]);

// ES6 的写法
Math.max(...[14,3,77,30]);

// reduce
[14,3,77,30].reduce((accumulator,currentValue){
    return accumulator = accumulator &gt; currentValue ? accumulator : currentValue
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_25-es6-新的特性有哪些？"><a href="#_25-es6-新的特性有哪些？" class="header-anchor">#</a> 25.ES6 新的特性有哪些？</h3> <ol><li>新增了块级作用域(let,const)</li> <li>提供了定义类的语法糖(class)</li> <li>新增了一种基本数据类型(Symbol)</li> <li>新增了变量的解构赋值</li> <li>函数参数允许设置默认值，引入了 rest 参数，新增了箭头函数</li> <li>数组新增了一些 API，如 isArray/from/of 方法，数组实例新增了 entries()，keys()和 values()等方法</li> <li>对象和数组新增了扩展运算符</li> <li>ES6 新增了模块化(import/export)</li> <li>ES6 新增了 Set 和 Map 数组结构</li> <li>ES6 原生提供了 Proxy 构造函数，用来生成 Proxy 实例</li> <li>ES6 新增了生成器(Generator)和遍历器(Iterator)</li></ol> <h3 id="_26-settimeout-倒计时为什么会出现误差？"><a href="#_26-settimeout-倒计时为什么会出现误差？" class="header-anchor">#</a> 26.setTimeout 倒计时为什么会出现误差？</h3> <p>setTimeout()只是将事件插入了“任务队列”，必须等当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码消耗时间很长，也有可能要等很久。所以并没办法保证回调函数一定会在 setTimeout()指定的时间执行。所以，setTimeout 的第二个参数表示的是最少时间，并非是确切时间。</p> <h3 id="_27-为什么-0-1-0-2-0-3"><a href="#_27-为什么-0-1-0-2-0-3" class="header-anchor">#</a> 27.为什么 0.1 + 0.2 != 0.3 ?</h3> <p>参考<a href="https://km.xiaowuzi.info/js/js-precision.html" target="_blank" rel="noopener noreferrer">js 精度丢失问题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_28-promise-有几种状态-promise-有什么优缺点"><a href="#_28-promise-有几种状态-promise-有什么优缺点" class="header-anchor">#</a> 28.promise 有几种状态, Promise 有什么优缺点 ?</h3> <p>promise 有三种状态：fulfilled,rejected,pending.</p> <p>Promise 的优点：</p> <ul><li></li></ul> <h3 id="_29-promise-构造函数是同步还是异步执行，then-中的方法呢-promise-如何实现-then-处理"><a href="#_29-promise-构造函数是同步还是异步执行，then-中的方法呢-promise-如何实现-then-处理" class="header-anchor">#</a> 29.Promise 构造函数是同步还是异步执行，then 中的方法呢 ?promise 如何实现 then 处理 ?</h3> <p>Promise 的构造函数是同步执行的。then 中的方法是异步的。promise 的 then 实现，详见<a href="https://km.xiaowuzi.info/js/es6-promise.html" target="_blank" rel="noopener noreferrer">Promise 对象<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_30-promise-和-settimeout-的区别"><a href="#_30-promise-和-settimeout-的区别" class="header-anchor">#</a> 30.Promise 和 setTimeout 的区别 ?</h3> <p>Promise 是微任务，setTimeout 是宏任务，同一个事件循环中，promise.then 总是先于 setTimeout 执行。</p> <h3 id="_31-如何实现-promise-all"><a href="#_31-如何实现-promise-all" class="header-anchor">#</a> 31.如何实现 Promise.all ?</h3> <p>要实现 Promise.all 首先我们需要知道 Promise.all 的功能：</p> <ol><li>如果传入的参数是一个空的可迭代对象，那么</li> <li>如果传入的参数不包含任何 promise，则返回一个异步完成.promises 中所有的 promise 都</li> <li>如果参数中有一个 promise 失败，那么 Promise.all 返回的 promise 对象失败</li> <li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>Promise.all = function(promise){
    return new Promise((resolve,reject)=&gt;{
        let index = 0;
        let result = [];
        if(promise.length === 0){
            resolve(result);
        }else{
            function processValue(i,data){
                result[i] = data;
                if(++index === promises.length){
                    resolve(result);
                }
            }
            for(let i =0; i&lt;promises.length;i++){
                // promises[i] 可能是普通值
                Promise.resolve(promise[i]).then((data)=&gt;{
                    processValue(i,data);
                },(err)=&gt;{
                    reject(err);
                    return;
                })
            }
        }
    })
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h3 id="_32-如何实现-promise-finally"><a href="#_32-如何实现-promise-finally" class="header-anchor">#</a> 32.如何实现 Promise.finally ?</h3> <p>不管成功还是失败，都会走到 finally 中，并且 finally 之后，还可以继续 then，并且将值原封不动的传递给后面的 then.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Promise.prototype.finally = function (callback){
    return this.then((value)=&gt;{
        reutrn Promise.resolve(callback()).then(()=&gt;{
            return value;
        })
    },(err)=&gt;{
        return Promise.resolve(callback()).then(()=&gt;{
            throw err;
        })
    })
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_33-什么是函数柯里化？实现-sum-1-2-3-返回结果是-1-2-3-之和"><a href="#_33-什么是函数柯里化？实现-sum-1-2-3-返回结果是-1-2-3-之和" class="header-anchor">#</a> 33.什么是函数柯里化？实现 sum(1)(2)(3) 返回结果是 1,2,3 之和</h3> <h3 id="_34-说一说-js-异步发展史"><a href="#_34-说一说-js-异步发展史" class="header-anchor">#</a> 34.说一说 JS 异步发展史</h3> <p>异步最早的解决方案是回调函数，如果事件的回调，setInterval/setTimeout 中的回调。但是回调函数有一个很常见的问题，就是回调地狱的问题；</p> <p>为了解决回调地铁的问题，社区提出了 Promise 解决方案，ES6 将其写进了语言标准。Promise 解决了回调地狱的问题，但是 Promise 也存在一些问题，如错误不能被 try catch，而且使用 Promise 的链式调用，其实并没有从根本上解决回调地狱的问题，只是换了一种写法。</p> <p>ES6 中引入了 Generator 函数，Generator 是一种异步编程解决方案，Generator 函数是协程在 ES6 的实现最大特点就是可以交出函数的执行权，Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用 yield 语句注明。但是 Generator 使用起来较为复杂。</p> <h3 id="_35-谈谈对-async-await-的理解，async-await-的实现原理是什么"><a href="#_35-谈谈对-async-await-的理解，async-await-的实现原理是什么" class="header-anchor">#</a> 35.谈谈对 async/await 的理解，async/await 的实现原理是什么?</h3> <p>async/await 就是 Generator 的语法糖，使得异步操作变得更加方便。来张图对比一下：</p> <p><img src="js-async-interview.png" alt="images"></p> <p>async 函数就是将 Genterator 函数的星号（<code>*</code>）替换成 async，将 yield 替换成 await。</p> <blockquote><p>我们说 async 是 Generator 的语法糖，那么这个糖究竟甜在哪呢？</p></blockquote> <ol><li>async 函数内置执行器，函数调用之后，会自动执行，输出最后结果。而 Generator 需要调用 next 或者配合 co 模块使用。</li> <li>更好的语义，async 和 await，比如星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li></ol> <h3 id="_36-使用-async-await-需要注意什么？"><a href="#_36-使用-async-await-需要注意什么？" class="header-anchor">#</a> 36.使用 async/await 需要注意什么？</h3> <ol><li>await 命令后面的 Promise 对象，运行结果可能是 rejected，此时等同于 async 函数返回的 Promise 对象被 reject，因此需要加上错误处理，可以给每个 await 后的 Promise 增加 catch 方法；也可以将 await 的代码放在<code>try...catch</code>中。</li> <li>多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 下面两种写法都可以同时触发
// 方法一
async function f1(){
    await Promise.all([
        new Promise((resolve)=&gt;{
            setTimeout(resolve,600);
        }),
        new Promise((resolve)=&gt;{
            setTimeout(resolve,600)
        })
    ])
}

// 方法二
async function f2(){
    let fn1 = new Promise((resolve)=&gt;{
        setTimeout(resolve,800)
    });

    let fn2 = new Promise((resolve)=&gt;{
        setTimeout(resolve,800);
    });
    await fn1;
    await fn2;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><ol start="3"><li>await 命令只能用在 async 函数之中，如果用在普通函数，会报错。</li> <li>async 函数可以保留运行堆栈。</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>/**
*   函数a内部运行了一异步任务b()。当b()运行的时候，函数a()不会中断，而是继续执行。
*   等到b() 运行结束，可能a()早就运行结束了，b()所在上下文环境已经消失了。
*   如果b()或c()报错，错误堆栈将不包括a()。
*/
function b(){
    return new Promise((resolve,reject)=&gt;{
        setTimeout(resolve,200)
    });
}
function c(){
    throw Error(10);
}
const a = ()=&gt;{
    b().then(()=&gt;c);
}
a();
/**
* 改成async函数
*/
const m = async()=&gt;{
    await b();
    c();
};
m();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>报错信息如下，可以看出 async 函数可以保留运行堆栈。</p> <p><img src="js-async02.png" alt="images"></p> <h3 id="_37-如何实现-promise-race？"><a href="#_37-如何实现-promise-race？" class="header-anchor">#</a> 37.如何实现 Promise.race？</h3> <p>在代码实现前，我们需要先了解 Promise.race 的特点：</p> <ol><li>Promise.race 返回的仍然是一个 Promise。它的状态与第一个完成的 Promise 的状态相同。它可以是完成（resolve），也可以是失败（rejects），这个取决于第一个 Promise 是哪一种状态。</li> <li>如果传入的参数是不可迭代的，那么将会抛出错误。</li> <li>如果传的参数数组是空，那么返回的 promise 将永远等待。</li> <li>如果迭代包含一个或多个非承诺值或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>Promise.race = function(promise){
    // promise 必须是一个可遍历的数组结构，否则抛错
    return new Promise((resolve,reject)=&gt;{
        if(typeof promises[Symbol.iterator] !=='function'){
            // 真实不是这个错误
            Promise.reject('args is not iteratable!');
        }
        if(promises.length===0){
            return;
        }else{
            for(let i=0;i&lt;promises.length;i++){
                Promise.resolve(promises[i]).then((data)=&gt;{
                    resolve(data);
                    return;
                },(err)=&gt;{
                    reject(err);
                    return;
                })
            }
        }
    });
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>测试代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 一直在等待态
Promise.race([]).then((data)=&gt;{
    console.log('success',data);
},(err)=&gt;{
    console.log('err',err);
});

// 抛错
Promise.race().then((data)=&gt;{
    console.log('success',data);
},(err)=&gt;{
    console.log('err',err);
});

Promise.race([
    new Promise((resolve,reject)=&gt;{
        setTimeout(()=&gt;{resolve(100)},1000)
    }),
    new Promise((resolve,reject)=&gt;{
        setTimeout(()=&gt;{resolve(200)},200)
    }),
    new Promise((resolve,reject)=&gt;{
        setTimeout(()=&gt;{reject(100)},100)
    })
]).then((data){
    console.log(data);
},(err)=&gt;{
    console.log(err);
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h3 id="_38-可遍历数据结构的有什么特点？"><a href="#_38-可遍历数据结构的有什么特点？" class="header-anchor">#</a> 38.可遍历数据结构的有什么特点？</h3> <p>一个对象如果要具备可被 for...of 循环调用的 Iterator 接口，就必须在其 Symbol.iterator 的属性上部署遍历器生成方法(或者原型链上的对象具有该方法)</p> <p><strong>PS:</strong> 遍历器根本特征就是具有 next 方法。每次调用 next 方法，都会返回一个代表当前成员的信息对象，具有 value 和 done 两个属性。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 如为对象添加Iterator接口；
let obj = {
    name:'Yvette',
    age: 18,
    job: 'engineer',
    [Symbol.iterator](){
        const self = this;
        const keys = Object.keys(self);
        let self = this;
        const keys = Object.keys(self);
        let index = 0;
        return {
            next(){
                if(index &lt; keys.length){
                    return {
                        value: self[keys[index++]],
                        done:false
                    }
                }else{
                    return { value:undefined,done:true};
                }
            }
        }
    }
}

for(let item of obj){
    console.log(item);          // Yvette 18 engineer
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>使用 Generator 函数()简写 Symbol.iterator 方法，可以简写如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let obj = {
    name: 'Yvette',
    age: 18,
    job: 'engineer',
    * [Symbol.iterator] () {
        const self = this;
        const keys = Object.keys(self);
        for (let index=0;index&lt;keys.length;index++){
            yield self[keys[index]];    // yield 表达式仅能使用在Generator函数中
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="原生具备-iterator-接口的数据结构如下"><a href="#原生具备-iterator-接口的数据结构如下" class="header-anchor">#</a> 原生具备 Iterator 接口的数据结构如下</h4> <ul><li>Array</li> <li>Map</li> <li>Set</li> <li>String</li> <li>TypedArray</li> <li>函数的 arguments 对象</li> <li>NodeList 对象</li> <li>ES6 的数组、Set、Map 都部署了以下三个方法：entries()/keys()/values()，调用后都返回遍历器对象</li></ul> <h3 id="_39-requestanimationframe-和-settimeout-setinterval-有什么区别？使用-requestanimationframe-有哪些好处？"><a href="#_39-requestanimationframe-和-settimeout-setinterval-有什么区别？使用-requestanimationframe-有哪些好处？" class="header-anchor">#</a> 39.requestAnimationFrame 和 setTimeout/setInterval 有什么区别？使用 requestAnimationFrame 有哪些好处？</h3> <p>在 requestAnimationFrame 之前，我们主要使用 setTimeout/setInterval 来编写 JS 动画。</p> <p>编写动画的关键是循环间隔的设置，一方面，循环间隔足够短，动画效果才能显得平滑流畅；另一方面，循环间隔还要足够长，才能确保浏览器有能力沉浸产生变化 。</p> <p>大部分的电脑显示器的刷新频率是 60HZ，也就是每秒钟重绘 60 次。大多数浏览器都会对重绘操作加以限制，不走过显示器的重绘频率，因为即使超过那个频率用户体验也不会提升。因此，最平滑动画的最佳循环间隔是 1000ms/60，约为 16.7ms。</p> <p>setTimeout/setInterval 有一个显著的缺陷在于时间不是精确的，setTimeout/setInterval 只能保证延时或间隔不小于设定的时间。因为它们实际上只是把任务添加到任务队列中，但是如果前面的任务还没有执行完成。它们必须要等待。</p> <p>requestAnmationFrame 才有的是系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，千万过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p> <p>综上所述，requestAnmationFrame 和 setTimeout/setInterval 在编写动画时相对，优点如下：</p> <ol><li>requestAnimationFrame 不需要设置时间，采用系统时间间隔，能达到最佳的动画效果。</li> <li>requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，再一次重绘或回流中就完成。</li> <li>当 requestAnimationFrame()运行在后台标签页或者隐藏的<code>&lt;iframe&gt;</code>里时，requestAnimationFrame()会被暂停调用以提升性能和电池寿命（大多数浏览器中）。</li></ol> <h3 id="_40-js-类型转换的规则是什么？"><a href="#_40-js-类型转换的规则是什么？" class="header-anchor">#</a> 40.JS 类型转换的规则是什么？</h3> <p>请戳链接：<a href="https://km.xiaowuzi.info/js/es5-type.html" target="_blank" rel="noopener noreferrer">JS 数据类型与数据类型转换<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_41-简述下对-webworker-的理解？"><a href="#_41-简述下对-webworker-的理解？" class="header-anchor">#</a> 41.简述下对 webWorker 的理解？</h3> <p>HTML5 则提出了 Web Worker 标准，表示 js 允许多线程，但是子线程完全受主线程控制并且不能操作 dom，只有主线程可以操作 dom，所以 js 本质上依然是单线程语言。</p> <p>web worker 就是在 js 单线程执行的基础上开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完之后再回到主线程上，在这个过程中不影响主线程的执行。子线程与主线程之间提供了数据交互的接口 postMessage 和 onmessage，来进行数据发送和接收。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var worker = new Worker('./worker.js');     // 创建一个子线程
worker.postMessage('Hello');
worker.onmessage = function(e){
    console.log(e.data);    // Hi
    worker.terminate(); // 结束线程
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>// worker.js
onmessage = function(e){
    console.log(e.data);        // Hello
    postMessage('Hi');
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>请戳链接：<a href="https://km.xiaowuzi.info/html5/webwork.html" target="_blank" rel="noopener noreferrer">web work 学习<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_42-es6-模块和-commonjs-模块的差异？"><a href="#_42-es6-模块和-commonjs-模块的差异？" class="header-anchor">#</a> 42.ES6 模块和 CommonJS 模块的差异？</h3> <p>请戳链接：<a href="https://km.xiaowuzi.info/js/js-module.html" target="_blank" rel="noopener noreferrer">js 模块化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_43-浏览器事件代理机制的原理是什么？"><a href="#_43-浏览器事件代理机制的原理是什么？" class="header-anchor">#</a> 43.浏览器事件代理机制的原理是什么？</h3> <p>请戳链接：<a href="https://km.xiaowuzi.info/js/es5-event.html" target="_blank" rel="noopener noreferrer">js 事件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_44-js-如何自定义事件？"><a href="#_44-js-如何自定义事件？" class="header-anchor">#</a> 44.js 如何自定义事件？</h3> <blockquote><p>自定义 DOM 事件(不考虑 IE9 之前版本)</p></blockquote> <p>自定义事件有三种方式，一种是使用<code>new Event()</code>，另一种是<code>createEvent('CustomEvent')</code>，另一种是<code>new customEvent()</code></p> <ol><li>使用<code>new Event()</code></li></ol> <p>获取不到<code>event.detail</code></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let btn = document.querySelector('#btn');
let ev = new Event('alert',{
    bubbles:true,           // 事件是否冒泡；默认值false
    cancelable:true,        // 事件能否被取消；默认值false
    composed:false
});
btn.addEventListener('alert',function(event){
    console.log(event.bubbles);     // true
    console.log(event.cancelable);      // true
    console.log(event.detail);          // undefined
},false);
btn.dispatchEvent(ev);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ol start="2"><li>使用<code>createEvent('CustomEvent')</code>（DOM3）</li></ol> <p>要创建自定义事件，可以调用<code>createEvent('CustomEvent')</code>，返回的对象有 initCustomEvent 方法，接受以下四个参数：</p> <ul><li>type：字符串，表示触发的事件类型，如此处的<code>alert</code></li> <li>bubbles：布尔值，表示事件是否冒泡</li> <li>cancelable：布尔值，表示事件是否可以取消</li> <li>detail：任意值，保存在 event 对象的 detail 属性中</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>let btn = document.querySelector('#btn');
let ev = btn.createEvent('CustomEvent');
ev.initCustomEvent('alert',true,true,'button');
btn.addEventListener('alert',function(event){
    console.log(event.bubbles); //true
    console.log(event.cancelable);//true
    console.log(event.detail); //button
},false);
btn.dispatchEvent(ev);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ol start="3"><li>使用<code>new customEvent()</code>（DOM4）</li></ol> <p>使用起来比<code>createEvent('CustomEvent')</code>更加方便</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var btn = document.querySelector('#btn');
/*
  * 第一个参数是事件类型
  * 第二个参数是一个对象
  */
var ev = new CustomEvent('alert',{
    bubbles: 'true',
    cancelable: 'true',
    detail: 'button'
});
btn.addEventListener('alert',function(event){
    console.log(event.bubbles);     // true
    console.log(event.cancelable);      // true
    console.log(event.detail);      // button
},false);
btn.dispatchEvent(ev);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><blockquote><p>自定义非 DOM 事件(观察者模式)</p></blockquote> <ul><li>EventTarget 类型有一个单独的属性 handlers,用于存储事件处理程序（观察者）。</li> <li>addHandler()用于注册给定类型事件处理程序；</li> <li>fire()用于触发一个事件；</li> <li>removeHandler()用于注销某个事件类型的事件处理程序。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>function EventTarget(){
    this.handlers = {};
}

EventTarget.prototype = {
    constructor:EventTarget,
    // 添加事件
    addHandler:function(type,handler){
        if(typeof this.handlers[type] === 'undefined'){
            this.handlers[type] = [];
        }
        this.handlers[type].push(handler);
    },
    // 触发事件
    fire:function(event){
        if(!event.target){
            event.target = this;
        }
        if(this.handlers[event.type] instanceof Array){
            const handlers = this.handlers[event.type];
            handlers.forEach((handler)=&gt;{
                handlers.forEach((handler)=&gt;{
                    handler(event);
                })
            })
        }
    },
    // 删除事件处理程序
    removeHandler:function(type,handler){
        if(this.handlers[type] instanceof Array){
            const handlers = this.handlers[type];
            for(var i=0,len=handlers.length;i&lt;len;i++){
                if(handlers[i] === handler) break;
            }
            handlers.splice(i,1);
        }
    }
}

// 使用
function handleMessage(event){
    console.log(event.message);
}
// 创建一个新对象
var target = new EventTarget();
// 添加一个事件处理程序
target.addHandler('message',handleMessage);
// 触发事件
target.fire({type:'message',message:'Hi'}); // Hi
// 删除事件处理程序
target.removeHandler('message',handleMessage);
// 再次触发事件，没有事件处理程序
target.fire({type:'message',message:'Hi'});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br></div></div><h3 id="_45-跨域的方法有哪些？原理是什么？"><a href="#_45-跨域的方法有哪些？原理是什么？" class="header-anchor">#</a> 45.跨域的方法有哪些？原理是什么？</h3> <p>请戳链接：<a href="https://km.xiaowuzi.info/project/cross-domain.html" target="_blank" rel="noopener noreferrer">跨域<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_46-js-异步加载的方式有哪些？"><a href="#_46-js-异步加载的方式有哪些？" class="header-anchor">#</a> 46.js 异步加载的方式有哪些？</h3> <ol><li><code>&lt;script&gt;</code> 的 defer 属性，HTML4 中新增</li> <li><code>&lt;script&gt;</code> 的 async 属性，HTML5 中新增</li></ol> <ul><li><code>&lt;script&gt;</code> 标签打开 defer 属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</li> <li>defer 和 async 的区别在于：defer 要等到整个页面在内存中正常渲染结束，才会执行；</li> <li>async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。defer 是“渲染完再执行”，async 是“下载完就执行”。</li> <li>如果有多个 defer 脚本，会按照它们在页面出现的顺序加载。</li> <li>多个 async 脚本是不能保证加载顺序的。</li></ul> <ol start="3"><li>动态插入 script 脚本</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>function downloadJS(){
    var element = document.createElement(&quot;script&quot;);
    element.src ='xxx.js';
    document.body.appendChild(element);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_47-下面代码-a-在什么情况中打印出-1？"><a href="#_47-下面代码-a-在什么情况中打印出-1？" class="header-anchor">#</a> 47.下面代码 a 在什么情况中打印出 1？</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>if(a===1 &amp;&amp; a == 2 &amp;&amp; a==3){
    console.log(1);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>参考资料<a href="https://juejin.im/post/5e66dc416fb9a07cab3aaa0a" target="_blank" rel="noopener noreferrer">大厂面试题分享：如何让(a===1&amp;&amp;a===2&amp;&amp;a===3)的值为 true?<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ol><li>在类型转换的时候，我们知道了对象如何转换成原始数据类型。如果部署了 Symbol.toPrimitive，那么返回的就是 Symbol.toPrimitive 的返回值。当然，我们也可以把此函数部署在 valueOf 或者是 toString 接口上，效果相同。</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 利用闭包延长作用域的特性
let a = {
    [Symbol.toPrimitive]:(function(){
        let i =1;
        return function(){
            return i++;
        }
    })()
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>(1) 比较 a==1 时，会调用[Symbol.toPrimitive]，此时 i 是 1，相等。(2) 继续比较 a==2，调用[Symbol.toPrimitive]，此时 i 是 2，相等。 (3)继续比较 a ==3，调用[Symbol.toPrimitive]，此时 i 是 3，相等。</p> <ol start="2"><li>利用 Object.defineProperty 在 window/global 上定义 a 属性，获取 a 属性时，会调用 get</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>let val = 1;
Object.defineProperty(window,'a',{
    get:function(){
        return val++;
    }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="3"><li>利用数组的特性</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>var a = [1,2,3];
a.join = a.shift;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>数组的<code>toString</code>方法返回一个字符串，该字符串由数组中的每个元素的 toString()返回值经调用 join()方法连接（由逗号隔开）组成。</p> <p>因此，我们可以重新 join 方法。返回第一个元素，并将其删除。</p> <h3 id="_48-下面这段代码的输出是什么？"><a href="#_48-下面这段代码的输出是什么？" class="header-anchor">#</a> 48.下面这段代码的输出是什么？</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Foo() {
    getName = function() {console.log(1)};
    return this;
}
Foo.getName = function() {console.log(2)};
Foo.prototype.getName = function() {console.log(3)};
var getName = function() {console.log(4)};
function getName() {console.log(5)};

Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>请戳链接：<a href="https://www.cnblogs.com/xxcanghai/p/5189353.html" target="_blank" rel="noopener noreferrer">一道常被人轻视的前端 JS 面试题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ol><li>首先预编译阶段，变量声明与函数声明提升至其对应作用域的最顶端。</li></ol> <p>因此上面的代码编译后如下（函数声明的优先级先于变量声明）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Foo(){
    getName = function(){console.log(1)}
    return this;
}
function getName() {console.log(5)};    // 函数优先(函数首先被提升)
var getName;    // 重复声明，被忽略
Foo.getName = function(){console.log(3)};
getName = function(){console.log(4)};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="2"><li><code>Foo.getName()</code>直接调用 Foo 上 getName 方法，输出 2</li> <li><code>getName()</code>输出 4，getName 被重新赋值了</li> <li><code>Foo().getName()</code>执行 Foo()，window 的 getName 被重新赋值，返回 this;浏览器环境中，非严格模式，this 指向 window，this.getName();输出为 1.如果是严格模式，this 指向 undefined，此处会抛出错误。如果是 node 环境中，this 指向 global，node 的全局变量并不挂在 global 上，因为 global.getName 对应的是 undefined，不是一个 function，会抛出错误。</li> <li><code>getName()</code>已经抛错的自然走不动这一步了；继续浏览器非严格式；window.getName 被重新赋过值，此时再调用，输出的是 1</li> <li><code>new Foo.getName()</code>考察<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener noreferrer">运算符优先级<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的知识，new 无参数列表，对应的优先级 18；成员访问操作符<code>.</code>，对应的优先级是 19。因此相当于是<code>new (Foo.getName)()</code>;new 操作符会执行的构造函数中的方法，因此此处输出为 2.</li> <li><code>new Foo().getName()</code>;new 带参数列表，对应的优先级是 19，和成员访问操作符<code>.</code>优先级相同。同级运算符，按照从左到右的顺序依次计算。<code>new Foo()</code>先初始化对象，实例上没有 getName 方法，因此需要原型上去找，即找到了<code>Foo.prototype.getName</code>，输出 3</li> <li><code>new new Foo().getName()</code>new 带参数列表，优先级 19，因此相当于是<code>new(new Foo()).getName()</code>;先初始化 Foo 的实例化对象，然后将其原型上的 getName 函数作为构造函数再次 new，输出 3</li></ol> <p>最终结果如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Foo.getName(); //2
getName();//4
Foo().getName();//1
getName();//1
new Foo.getName();//2
new Foo().getName();//3
new new Foo().getName();//3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_49-实现双向绑定-proxy-与-object-defineproperty-相比优劣如何"><a href="#_49-实现双向绑定-proxy-与-object-defineproperty-相比优劣如何" class="header-anchor">#</a> 49.实现双向绑定 Proxy 与 Object.defineProperty 相比优劣如何?</h3> <ol><li>Object.definedProperty 的作用是劫持一个对象的属性，劫持属性的 getter 和 setter 方法，在对象的属性发生变化时进行特定的操作。而 Proxy 劫持的是整个对象。</li> <li>Proxy 会返回一个代理对象，我们只需要操作新对象即可，而<code>Object.definedProperty</code>只遍历对象属性直接修改。</li> <li>Object.definedProperty 不支持数组，更准确的说是不支持数组的各种 API，因为如果仅仅考虑 array[i]=value 这种情况，是可以劫持的，但是这种劫持意义不大。而 Proxy 可以把持数组的各种 API。</li> <li>尽管 Object.definedPropery 有诸多缺陷，但是其兼容性好于 Proxy.</li></ol> <p>PS:Vue2.x 使用 Object.definedProperty 实现数据双向绑定，V3.0 则使用了 Proxy.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 拦截器
let obj = {};
let temp = 'Tony';
Object.defineProperty(obj,'name',{
    get(){
        console.log('读取成功');
        return temp
    },
    set(value){
        console.log('设置成功');
        temp = value;
    }
})

obj.name = '小武子';
console.log(obj.name);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>PS:Object.defineProperty 定义出来的属性，默认是不可枚举，不可理性，不可配置【无法 delete】</p> <p>我们可以看到 Proxy 会支持整个对象，读取对象中的属性或者是个性属性值，那么就会被劫持。但是有点需要注意，复杂数据类型，监控的是引用地址，而不值，如果引用地址没有改变，那么不会触发 set。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let obj = {name:'Tony',hobbits:['travel','reading'],info:{
    age:30,
    job:'engineer'
}}
let p = new Proxy(obj,{
    get(target,key){
        // 第三个参数是proxy，一般不使用ss
        console.log('读取成功');
        return Reflect.get(target,key);
    },
    set(target,key,value){
        if(key === 'length') return true;      // 如果是数组长度的变化，返回
        console.log('设置成功');
        return Reflect.set([target,key,value]);
    }
});
p.name = '小武子';    // 设置成功
p.age = 30;
p.hobbits.push('photography'); //读取成功;注意不会触发设置成功
p.info.age = 18; //读取成功;不会触发设置成功
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>最后，我们再看下对于数组的支持，Object.definedProperty 和 Proxy 的差别</p> <p>Object.definedProperty 可以将数组的索引作为属性进行支持，但是公示支持直接对 array[i]进行操作，不支持数组的 API，非常鸡肋。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Object.defineProperty(arry, '0', {
    get() {
        console.log(&quot;读取成功&quot;);
        return temp
    },
    set(value) {
        console.log(&quot;设置成功&quot;);
        temp = value;
    }
});

arry[0] = 10; //触发设置成功
arry.push(10); //不能被劫持
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>Proxy 可以监听到数组的变化，支持各种 API。注意数组的变化触发 get 和 set 可能不止一次，如有需要，自行根据 key 值决定是否要进行处理。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let hobbits = ['travel', 'reading'];
let p = new Proxy(hobbits, {
    get(target, key) {
        // if(key === 'length') return true; //如果是数组长度的变化，返回。
        console.log('读取成功');
        return Reflect.get(target, key);
    },
    set(target, key, value) {
        // if(key === 'length') return true; //如果是数组长度的变化，返回。
        console.log('设置成功');
        return Reflect.set([target, key, value]);
    }
});
p.splice(0,1) //触发get和set，可以被劫持
p.push('photography');//触发get和set
p.slice(1); //触发get；因为 slice 是不会修改原数组的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="_50-object-is-与比较操作符-、-有什么区别？"><a href="#_50-object-is-与比较操作符-、-有什么区别？" class="header-anchor">#</a> 50.Object.is() 与比较操作符 ===、== 有什么区别？</h3> <p>以下情况，Object.is 认为是相等</p> <ul><li>两个值都是 undefined</li> <li>两个值都是 null</li> <li>两个值都是 true 或者都是 false</li> <li>两个值是由相同个数的字符按照相同的顺序组成的字符串</li> <li>两个值指向同个对象</li> <li>都是正零 +0</li> <li>都是负零 -0</li> <li>都是 NaN</li> <li>都是除零和 NaN 外的其它同一个数字</li></ul> <p>Object.is()类似于 ===，但是有一些细微差别，如下：</p> <ol><li>NaN 和 NaN 相等</li> <li>-0 和+0 不相等</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>console.log(Object.is(NaN, NaN));//true
console.log(NaN === NaN);//false
console.log(Object.is(-0, +0)); //false
console.log(-0 === +0); //true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_51-什么是事件循环？node-事件循环和-js-事件循环的差异是什么？"><a href="#_51-什么是事件循环？node-事件循环和-js-事件循环的差异是什么？" class="header-anchor">#</a> 51.什么是事件循环？Node 事件循环和 JS 事件循环的差异是什么？</h3> <p>请戳链接：<a href="https://km.xiaowuzi.info/js/js-eventloop.html" target="_blank" rel="noopener noreferrer">理解 EventLoop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_52-1-2-3-map-parseint"><a href="#_52-1-2-3-map-parseint" class="header-anchor">#</a> 52.[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt)</h3> <h3 id="_53-typeof-null-null-instanceof-object"><a href="#_53-typeof-null-null-instanceof-object" class="header-anchor">#</a> 53.[typeof null, null instanceof Object]</h3> <h3 id="_54-3-2-1-reduce-math-pow-reduce-math-pow"><a href="#_54-3-2-1-reduce-math-pow-reduce-math-pow" class="header-anchor">#</a> 54.[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]</h3> <h3 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h3> <ul><li><a href="https://juejin.im/post/5cab0c45f265da2513734390" target="_blank" rel="noopener noreferrer">【面试篇】寒冬求职季之你必须要懂的原生 JS(上)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5cbd1e33e51d45789161d053" target="_blank" rel="noopener noreferrer">【面试篇】寒冬求职季之你必须要懂的原生 JS(中)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5c64d15d6fb9a049d37f9c20" target="_blank" rel="noopener noreferrer">中高级前端大厂面试秘籍，为你保驾护航金三银四，直通大厂(上)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5cc26dfef265da037b611738" target="_blank" rel="noopener noreferrer">(下篇)中高级前端大厂面试秘籍，寒冬中为您保驾护航，直通大厂<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5c92f499f265da612647b754" target="_blank" rel="noopener noreferrer">(中篇)中高级前端大厂面试秘籍，寒冬中为您保驾护航，直通大厂<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s/Bk07WB9hBagL590RRjC4FA" target="_blank" rel="noopener noreferrer">Javascript 面试核心考点<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s/g5Cr0N32W_z9X3qIMLOX6Q" target="_blank" rel="noopener noreferrer">Javascript 高频面试题解析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5c6ad9fde51d453c356e37d1" target="_blank" rel="noopener noreferrer">春招季如何横扫 Javascript 面试核心考点(基础版)？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5ca9de22e51d452b5372ed90" target="_blank" rel="noopener noreferrer">【周刊-1】三年大厂面试官-面试题精选及答案<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5cb0315f518825215e61ec14" target="_blank" rel="noopener noreferrer">【周刊-2】三年大厂面试官-前端面试题（偏难）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5cd82463518825692330d440" target="_blank" rel="noopener noreferrer">【周刊-3】三年大厂面试官-十道前端面试题（欢迎挑战）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://muyiy.cn/question/program/5.html" target="_blank" rel="noopener noreferrer">每日·壹题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="联系作者"><a href="#联系作者" class="header-anchor">#</a> 联系作者</h2> <div align="center"><p>
        平凡世界，贵在坚持。
    </p> <img src="/about/contact.png"></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新于:</span> <span class="time">2015/9/26 下午6:16:43</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/interview/js-interview2.html">
        js 面试题二
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----><div></div></div></div>
    <script src="/assets/js/app.c40970e9.js" defer></script><script src="/assets/js/2.c7f5c1a5.js" defer></script><script src="/assets/js/122.9a191ee2.js" defer></script><script src="/assets/js/3.fb5a4386.js" defer></script>
  </body>
</html>
