# 结构型设计模式

## 前言

本人平时学习及收集内容，欢迎参入一起讨论。

## 内容

- [外观模式](#一、外观模式)
- [适配器模式](#二、适配器模式)
- [代理模式](#三、代理模式)
- [装饰者模式](#四、装饰者模式)
- [桥接模式](#五、桥接模式)
- [组合模式](#六、组合模式)
- [享元模式](#七、享元模式)

### 一、外观模式

#### 1.1 介绍

为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使子系统更加容易使用

#### 1.2 代码

兼容浏览器事件绑定

```
let addMyEvent = function(el,ev,fn){
    if(el.addEventListener){
        el.addEventListener(ev,fn,false)
    }else if(el.attachEvent){
        el.attachEvent('on' + ev,fn)
    }else{
        el['on' + ev] = fn
    }
}
```

封装接口

```
let myEvent = {
    // ...
    stop: e = >{
        e.stopPropagation()
        e.preventDefault()
    }
}
```

#### 1.3 优点

- 减少系统相互依赖
- 提高灵活性
- 提高了安全性

#### 1.4 缺点

- 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适

#### 1.5 场景

- 设计初期，应该要有意识将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观 Facade
- 在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少他们之间的依赖。
- 在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观 Facade 也是非常合适的，为系统开发一个外观 Facade 类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和 Facade 对象交互，Facade 与遗留代码交互所有的复杂工作。

### 二、适配器模式

#### 2.1 介绍

将一个类的接口转化为了另外一接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决

#### 2.2 代码

```
class Plug{
    getName(){
        return 'iphone充电头'
    }
}

class Target{
    constructor(){
        this.plug = new Plug();
    }
    getName(){
        return this.plug.getName() + ' 适配器Type-c充电头';
    }
}

let target = new Target();
target.getName();       // iphone充电头 适配器转Type-c充电头
```

#### 2.3 优点

- 可以让任何两个没有关联的类一起运行
- 提高了类的复用
- 适配对象，适配库，适配数据

#### 2.4 缺点

- 额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可以实现性能优化）
- 如果没必要使用适配器模式的放，可以考虑重构，如果使用的话，尽量把文档完善

#### 2.5 场景

- 整合第三方 SDK
- 封装旧接口

```
// 自己封装的ajax，使用方式如下
ajax({
    url: '/getData',
    type: 'post',
    dataType: 'json',
    data:{
        test:111
    }
}).done(function(){})

// 做一层适配器
var $ = {
    ajax: function(options){
        return ajax(options)
    }
}
```

- vue 的 computed

```

```

原有 data 中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式

#### 适配器与代码模式相似

- 适配器模式：提供一个不同的接口（如不同版本的插头）
- 代码模式：提供一模一样的接口

### 三、代理模式

#### 3.1 介绍

#### 3.2 代码

```

```

#### 3.3 优点

#### 3.4 缺点

#### 3.5 场景

### 四、装饰者模式

#### 4.1 介绍

- 动态地给某个对象添加一些额外的职责，是一种实现的替代方案

#### 4.2 代码

```

```

#### 4.3 优点

#### 4.4 缺点

#### 4.5 场景

### 五、桥接模式

#### 5.1 介绍

#### 5.2 代码

```

```

#### 5.3 优点

#### 5.4 缺点

#### 5.5 场景

### 六、组合模式

#### 6.1 介绍

#### 6.2 代码

```

```

#### 6.3 优点

#### 6.4 缺点

#### 6.5 场景

### 七、享元模式

```

```

## 参考资料

- 《JavaScript 设计模式》
- [一文读懂 JS 装饰器，这是一个会打扮的装饰器](https://mp.weixin.qq.com/s/ns8jwFlLtSh4PNObWjSMrA)

### 联系作者

<div align="center">
    <p>
        平凡世界，贵在坚持。
    </p>
    <img :src="$withBase('/about/contact.png')" />
</div>
