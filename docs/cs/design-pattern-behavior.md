# 行为型设计模式

## 前言

本人平时学习及收集内容，欢迎参入一起讨论。

## 内容

- [模板方法模式](#一、模板方法模式)
- [观察者模式](#二、观察者模式)
- [状态模式](#三、状态模式)
- [策略模式](#四、策略模式)
- [职责链模式](#五、职责链模式)
- [命令模式](#六、命令模式)
- [访问者模式](#七、访问者模式)
- [中介者模式](#八、中介者模式)
- [备忘录模式](#九、备忘录模式)
- [解释器模式](#十、解释器模式)

### 一、模板方法模式

#### 1.1 介绍

#### 1.2 代码

```

```

#### 1.3 优点

#### 1.4 缺点

#### 1.5 场景

### 二、观察者模式

参考[观察者模式和发布订阅模式的区别](./design-pattern-subscription.html)

### 三、状态模式

#### 3.1 介绍

#### 3.2 代码

```

```

#### 3.3 优点

#### 3.4 缺点

#### 3.5 场景

### 四、策略模式

#### 4.1 介绍

#### 4.2 代码

```

```

#### 4.3 优点

#### 4.4 缺点

#### 4.5 场景

### 五、职责链模式

#### 5.1 介绍

使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止

#### 5.2 代码

```
//  请假审批，需要组长审批、经理审批、总监审批
class Action{
    constructor(name){
        this.name = name
        this.nextAction = null
    }
    setNextAction(action){
        this.nextAction = action
    }
    handle(){
        console.log(`${this.name} 审批`)
        if(this.nextAction != null){
            this.nextAction.handle()
        }
    }
}

let a1 = new Action('组长')
let a2 = new Action('经理')
let a3 = new Action('总监')
a1.setNextAction(a2)
a2.setNextAction(a3)
a1.handle()
```

#### 5.3 优点

- 降低耦合度。它将请求的发送者和接收者解耦。
- 简化了对象。使得对象不需要知道链的结构
- 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任
- 增加新的请求处理类很方便。

#### 5.4 缺点

- 不能保证某个请求一定会被链中的节点处理，
- 使程序中多了很多节点对象，可能再一次请求的过程中，大部分的节点并没有起到实质性的作用。他们的作用仅仅是让请求传递下去，从性能方面考虑，要避免过长的职责链到来的性能损耗。

#### 5.5 场景

- JS 中的事件冒泡
- 作用域链
- 原型链

### 六、命令模式

#### 6.1 介绍

#### 6.2 代码

```

```

#### 6.3 优点

#### 6.4 缺点

### 七、访问者模式

```

```

### 八、中介者模式

```

```

### 九、备忘录模式

#### 9.1 介绍

#### 9.2 代码

```

```

#### 9.3 优点

#### 9.4 缺点

### 十、解释器模式

```

```

### 参考资料

- 《JavaScript 设计模式》

## 联系作者

<div align="center">
    <p>
        平凡世界，贵在坚持。
    </p>
    <img :src="$withBase('/about/contact.png')" />
</div>
