# 简单排序

## 前言

本人平时学习及收集内容，欢迎参入一起讨论。

## 内容

- 排序算法说明
- 冒泡排序
- 选择排序
- 插入排序

### 一、排序算法说明

#### 1.1 定义

- **定义**：对一序列对象根据某个关关键字进行排序
- **输入**：n个数：`a1,a2,a3,…,an`
- **输出**：n个数的排列:`a1’,a2’,a3’,…,an’`，使得`a1’<=a2’<=a3’<=…<=an’`。

#### 1.2 算法优劣术语的说明

- **稳定**：如果a原本在前面，而a=b，排序之后a仍然在b的前面。
- **不稳定**：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面。
- **内排序**：所有排序操作都在内在中完成；
- **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内在的数据传输才能进行；
- **原地排序**：空间复杂度是O(1)的排序算法。
- **时间复杂度**：一个算法执行所耗费的时间。
- **空间复杂度**：运行完一个程序所需内存的大小。

关于时间复杂和空间复杂度更多了解可以点击[这里](./base-o.html)

#### 1.3 排序算法图片总结

排序对比：

![images](sort01.png)

**名词解释:**

- `n`：数据规模
- `k`：“桶”的个数
- `In-place`：占用常数内存，不占用额外内存
- `Out-place`：占用额外内存

**排序分类：**

![images](sort02.png)

### 二、冒泡排序

#### 2.1 算法描述

>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

具体算法描述如下：

- 比较相邻的元素。如果第一个比第二大，就交换它们两个；
- 对每一对相邻元素作同样的工作，

#### 2.2 代码实现

```
function bubbleSort(arr){
    var len = arr.length;
    for(var i = 0;i<len;i++){
        for(var j=0;j<len-1-i;j++){
            if (arr[j] > arr[j+1]) {        //相邻元素两两对比
                var temp = arr[j+1];        //元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}

var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
```

```
```

```

```

![images](sort03)

#### 2.3 冒泡排序动图演示

![images](sort04.png)

#### 2.4 算法分析

### 三、选择排序

#### 3.1 算法描述

#### 3.2 代码实现

### 四、插入排序

#### 4.1 算法描述

#### 4.2 代码实现

```
```

## 参考资料

- [十大经典排序算法](https://blog.damonare.cn/2016/12/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/)
- [ 排序（上）：为什么插入排序比冒泡排序更受欢迎？](https://time.geekbang.org/column/article/41802)

## 联系作者

<div align="center">
    <p>
        平凡世界，贵在坚持。
    </p>
    <img :src="$withBase('/about/contact.png')" />
</div>