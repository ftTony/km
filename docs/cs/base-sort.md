# 简单排序

## 前言

本人平时学习及收集内容，欢迎参入一起讨论。

## 内容

- 排序算法说明
- 冒泡排序
- 选择排序
- 插入排序

### 一、排序算法说明

#### 1.1 定义

- **定义**：对一序列对象根据某个关关键字进行排序
- **输入**：n个数：`a1,a2,a3,…,an`
- **输出**：n个数的排列:`a1’,a2’,a3’,…,an’`，使得`a1’<=a2’<=a3’<=…<=an’`。

#### 1.2 算法优劣术语的说明

- **稳定**：如果a原本在前面，而a=b，排序之后a仍然在b的前面。
- **不稳定**：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面。
- **内排序**：所有排序操作都在内在中完成；
- **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内在的数据传输才能进行；
- **原地排序**：空间复杂度是O(1)的排序算法。
- **时间复杂度**：一个算法执行所耗费的时间。
- **空间复杂度**：运行完一个程序所需内存的大小。

关于时间复杂和空间复杂度更多了解可以点击[这里](./base-o.html)

#### 1.3 排序算法图片总结

排序对比：

![images](sort01.png)

**名词解释:**

- `n`：数据规模
- `k`：“桶”的个数
- `In-place`：占用常数内存，不占用额外内存
- `Out-place`：占用额外内存

**排序分类：**

![images](sort02.png)

### 二、冒泡排序

#### 2.1 算法描述

>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

具体算法描述如下：

- 比较相邻的元素。如果第一个比第二大，就交换它们两个；
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
- 针对所有的元素重复以上的步骤，除了最后一个；
- 重复步骤1~3，直到排序完成。

#### 2.2 代码实现

```
function bubbleSort(arr){
    var len = arr.length;
    for(var i = 0;i<len;i++){
        for(var j=0;j<len-1-i;j++){
            if (arr[j] > arr[j+1]) {        //相邻元素两两对比
                var temp = arr[j+1];        //元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}

var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
```

> **改进冒泡排序：**设置一标志性变量pos，用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位，故在进行下一趟排序时只需要扫描到pos位置即可。

改进后算法如下：

```
function bubbleSort2(arr){
    console.time('改进后冒泡排序耗时');
    var i = arr.length -1;
    while(i>0){
        var pos =0; // 每趟开始时，无记录交换
        for(var j=0;j<i;j++){
            if(arr[j]>arr[j+1]){
                pos = j;    // 记录交换的位置
                var tmp = arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=tmp;
            }
            i = pos;    // 为下一趟排序作准备
        }
    }
    console.timeEnd('改进后冒泡排序耗时');
    return arr;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
```

> 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值，我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值（最大者和最小者），从而使排序趟数几乎减少了一半。

改进后的算法实现为:

```
function bubbleSort3(arr3){
    var low = 0;
    var high = arr.length-1;    // 设置变量的初始值
    var tmp,j;
    console.time('');
    while(low<high){
        
    }
}
```

![images](sort03)

#### 2.3 冒泡排序动图演示

![images](sort04.png)

#### 2.4 算法分析

- 最佳情况：`T(n)` = `O(n)`

> 当输入的数据已经是正序时

- 最差情况：`T(n)`=`O(n2)`

> 当输入的数据是时

- 平均情况：`T(n)`=`O(n2)`

### 三、选择排序

>表现最稳定的排序算法之一，因为无论什么数据进去都是O（n2）的时间复杂度...所以乃至它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法。

#### 3.1 算法介绍

> 选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

#### 3.2 算法描述

n个记录的直接选择排序可以经过n-1趟直接选择排序得到有序结果。具体算法描述如下：

- 初始状态：无序区为`R[1...n]`，有序区

#### 3.3 代码实现

```

```

### 四、插入排序

#### 4.1 算法描述

#### 4.2 代码实现

```
```

## 参考资料

- [十大经典排序算法](https://blog.damonare.cn/2016/12/20/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/)
- [ 排序（上）：为什么插入排序比冒泡排序更受欢迎？](https://time.geekbang.org/column/article/41802)

## 联系作者

<div align="center">
    <p>
        平凡世界，贵在坚持。
    </p>
    <img :src="$withBase('/about/contact.png')" />
</div>